{"ast":null,"code":"import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource.mjs';\nconst _CubeResource = class extends AbstractMultiResource {\n  constructor(source, options) {\n    const {\n      width,\n      height,\n      autoLoad,\n      linkBaseTexture\n    } = options || {};\n    if (source && source.length !== _CubeResource.SIDES) {\n      throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n    }\n    super(6, {\n      width,\n      height\n    });\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    }\n    this.linkBaseTexture = linkBaseTexture !== false;\n    if (source) {\n      this.initFromArray(source, options);\n    }\n    if (autoLoad !== false) {\n      this.load();\n    }\n  }\n  bind(baseTexture) {\n    super.bind(baseTexture);\n    baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n  }\n  addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n    if (linkBaseTexture === void 0) {\n      linkBaseTexture = this.linkBaseTexture;\n    }\n    if (!this.items[index]) {\n      throw new Error(`Index ${index} is out of bounds`);\n    }\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {\n      if (baseTexture.resource) {\n        this.addResourceAt(baseTexture.resource, index);\n      } else {\n        throw new Error(`CubeResource does not support copying of renderTexture.`);\n      }\n    } else {\n      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n      baseTexture.parentTextureArray = this.baseTexture;\n      this.items[index] = baseTexture;\n    }\n    if (baseTexture.valid && !this.valid) {\n      this.resize(baseTexture.realWidth, baseTexture.realHeight);\n    }\n    this.items[index] = baseTexture;\n    return this;\n  }\n  upload(renderer, _baseTexture, glTexture) {\n    const dirty = this.itemDirtyIds;\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      const side = this.items[i];\n      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {\n        if (side.valid && side.resource) {\n          side.resource.upload(renderer, side, glTexture);\n          dirty[i] = side.dirtyId;\n        } else if (dirty[i] < -1) {\n          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);\n          dirty[i] = -1;\n        }\n      }\n    }\n    return true;\n  }\n  static test(source) {\n    return Array.isArray(source) && source.length === _CubeResource.SIDES;\n  }\n};\nlet CubeResource = _CubeResource;\nCubeResource.SIDES = 6;\nexport { CubeResource };","map":{"version":3,"names":["_CubeResource","AbstractMultiResource","constructor","source","options","width","height","autoLoad","linkBaseTexture","length","SIDES","Error","i","items","target","TARGETS","TEXTURE_CUBE_MAP_POSITIVE_X","initFromArray","load","bind","baseTexture","TEXTURE_CUBE_MAP","addBaseTextureAt","index","parentTextureArray","Object","keys","_glTextures","resource","addResourceAt","valid","resize","realWidth","realHeight","upload","renderer","_baseTexture","glTexture","dirty","itemDirtyIds","side","dirtyId","gl","texImage2D","internalFormat","format","type","test","Array","isArray","CubeResource"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\resources\\CubeResource.ts"],"sourcesContent":["import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { ArrayFixed } from '@pixi/utils';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\nimport type { Resource } from './Resource';\n\n/**\n * Constructor options for CubeResource.\n * @memberof PIXI\n */\nexport interface ICubeResourceOptions extends ISize\n{\n    /** Whether to auto-load resources */\n    autoLoad?: boolean;\n\n    /** In case BaseTextures are supplied, whether to copy them or use. */\n    linkBaseTexture?: boolean;\n}\n\n/**\n * Resource for a CubeTexture which contains six resources.\n * @memberof PIXI\n */\nexport class CubeResource extends AbstractMultiResource\n{\n    items: ArrayFixed<BaseTexture, 6>;\n\n    /**\n     * In case BaseTextures are supplied, whether to use same resource or bind baseTexture itself.\n     * @protected\n     */\n    linkBaseTexture: boolean;\n\n    /**\n     * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n     *        to use as the sides of the cube.\n     * @param options - ImageResource options\n     * @param {number} [options.width] - Width of resource\n     * @param {number} [options.height] - Height of resource\n     * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n     * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n     *   whether to copy them or use\n     */\n    constructor(source?: ArrayFixed<string | Resource, 6>, options?: ICubeResourceOptions)\n    {\n        const { width, height, autoLoad, linkBaseTexture } = options || {};\n\n        if (source && source.length !== CubeResource.SIDES)\n        {\n            throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n        }\n\n        super(6, { width, height });\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n        }\n\n        this.linkBaseTexture = linkBaseTexture !== false;\n\n        if (source)\n        {\n            this.initFromArray(source, options);\n        }\n\n        if (autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Add binding.\n     * @param baseTexture - parent base texture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n    }\n\n    addBaseTextureAt(baseTexture: BaseTexture, index: number, linkBaseTexture?: boolean): this\n    {\n        if (linkBaseTexture === undefined)\n        {\n            linkBaseTexture = this.linkBaseTexture;\n        }\n\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        if (!this.linkBaseTexture\n            || baseTexture.parentTextureArray\n            || Object.keys(baseTexture._glTextures).length > 0)\n        {\n            // copy mode\n            if (baseTexture.resource)\n            {\n                this.addResourceAt(baseTexture.resource, index);\n            }\n            else\n            {\n                throw new Error(`CubeResource does not support copying of renderTexture.`);\n            }\n        }\n        else\n        {\n            // link mode, the difficult one!\n            baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n            baseTexture.parentTextureArray = this.baseTexture;\n\n            this.items[index] = baseTexture;\n        }\n\n        if (baseTexture.valid && !this.valid)\n        {\n            this.resize(baseTexture.realWidth, baseTexture.realHeight);\n        }\n\n        this.items[index] = baseTexture;\n\n        return this;\n    }\n\n    /**\n     * Upload the resource\n     * @param renderer\n     * @param _baseTexture\n     * @param glTexture\n     * @returns {boolean} true is success\n     */\n    upload(renderer: Renderer, _baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const dirty = this.itemDirtyIds;\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            const side = this.items[i];\n\n            if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId)\n            {\n                if (side.valid && side.resource)\n                {\n                    side.resource.upload(renderer, side, glTexture);\n                    dirty[i] = side.dirtyId;\n                }\n                else if (dirty[i] < -1)\n                {\n                    // either item is not valid yet, either its a renderTexture\n                    // allocate the memory\n                    renderer.gl.texImage2D(side.target, 0,\n                        glTexture.internalFormat,\n                        _baseTexture.realWidth,\n                        _baseTexture.realHeight,\n                        0,\n                        _baseTexture.format,\n                        glTexture.type,\n                        null);\n                    dirty[i] = -1;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /** Number of texture sides to store for CubeResources. */\n    static SIDES = 6;\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if source is an array of 6 elements\n     */\n    static test(source: unknown): source is ArrayFixed<string | Resource, 6>\n    {\n        return Array.isArray(source) && source.length === CubeResource.SIDES;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}