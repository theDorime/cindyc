{"ast":null,"code":"import './index.mjs';\nimport { uniformParsers } from './uniformParsers.mjs';\nimport { mapSize } from './mapSize.mjs';\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nconst UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n};\nconst GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  const uboElements = uniformData.map(data => ({\n    data,\n    offset: 0,\n    dataLen: 0,\n    dirty: 0\n  }));\n  let size = 0;\n  let chunkSize = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.dataLen = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return {\n    uboElements,\n    size: offset\n  };\n}\nfunction getUBOData(uniforms, uniformData) {\n  const usedUniformDatas = [];\n  for (const i in uniforms) {\n    if (uniformData[i]) {\n      usedUniformDatas.push(uniformData[i]);\n    }\n  }\n  usedUniformDatas.sort((a, b) => a.index - b.index);\n  return usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage) {\n    return {\n      size: 0,\n      syncFunc: uboUpdate\n    };\n  }\n  const usedUniformDatas = getUBOData(group.uniforms, uniformData);\n  const {\n    uboElements,\n    size\n  } = createUBOElements(usedUniformDatas);\n  const funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const uniform = group.uniforms[uboElement.data.name];\n    const name = uboElement.data.name;\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        const size2 = mapSize(uboElement.data.type);\n        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n        const elementSize = size2 / rowSize;\n        const remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n      } else {\n        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n      }\n    }\n  }\n  funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `);\n  return {\n    size,\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", funcFragments.join(\"\\n\"))\n  };\n}\nexport { createUBOElements, generateUniformBufferSync, getUBOData };","map":{"version":3,"names":["uboUpdate","_ud","_uv","_renderer","_syncData","buffer","update","UBO_TO_SINGLE_SETTERS","float","vec2","vec3","vec4","mat2","mat3","mat4","GLSL_TO_STD40_SIZE","int","ivec2","ivec3","ivec4","uint","uvec2","uvec3","uvec4","bool","bvec2","bvec3","bvec4","createUBOElements","uniformData","uboElements","map","data","offset","dataLen","dirty","size","chunkSize","i","length","uboElement","type","Math","max","lineUpValue","ceil","getUBOData","uniforms","usedUniformDatas","push","sort","a","b","index","generateUniformBufferSync","group","autoManage","syncFunc","funcFragments","uniform","name","parsed","j","uniformParsers","uniformParser","codeUbo","test","size2","mapSize","rowSize","elementSize","remainder","template","Function","join"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\shader\\utils\\generateUniformBufferSync.ts"],"sourcesContent":["import { mapSize } from '../utils';\nimport { uniformParsers } from './uniformParsers';\n\nimport type { Dict } from '@pixi/utils';\nimport type { Buffer } from '../../geometry/Buffer';\nimport type { Renderer } from '../../Renderer';\nimport type { IUniformData } from '../Program';\nimport type { UniformGroup } from '../UniformGroup';\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n\nfunction uboUpdate(_ud: any, _uv: any, _renderer: Renderer, _syncData: any, buffer: Buffer): void\n{\n    _renderer.buffer.update(buffer);\n}\n\n// cv = CachedValue\n// v = value\n// ud = uniformData\n// uv = uniformValue\n// l = location\nconst UBO_TO_SINGLE_SETTERS: Dict<string> = {\n    float: `\n        data[offset] = v;\n    `,\n    vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n    vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n    vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n    mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n    mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n    mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n};\n\nconst GLSL_TO_STD40_SIZE: Dict<number> = {\n    float:  4,\n    vec2:   8,\n    vec3:   12,\n    vec4:   16,\n\n    int:      4,\n    ivec2:    8,\n    ivec3:    12,\n    ivec4:    16,\n\n    uint:     4,\n    uvec2:    8,\n    uvec3:    12,\n    uvec4:    16,\n\n    bool:     4,\n    bvec2:    8,\n    bvec3:    12,\n    bvec4:    16,\n\n    mat2:     16 * 2,\n    mat3:     16 * 3,\n    mat4:     16 * 4,\n};\n\ninterface UBOElement\n{\n    data: IUniformData\n    offset: number,\n    dataLen: number,\n    dirty: number\n}\n\n/**\n * logic originally from here: https://github.com/sketchpunk/FunWithWebGL2/blob/master/lesson_022/Shaders.js\n * rewrote it, but this was a great starting point to get a solid understanding of whats going on :)\n * @ignore\n * @param uniformData\n */\nexport function createUBOElements(uniformData: IUniformData[]): {uboElements: UBOElement[], size: number}\n{\n    const uboElements: UBOElement[] = uniformData.map((data: IUniformData) =>\n        ({\n            data,\n            offset: 0,\n            dataLen: 0,\n            dirty: 0\n        }));\n\n    let size = 0;\n    let chunkSize = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, 16) * uboElement.data.size;\n        }\n\n        uboElement.dataLen = size;\n\n        // add some size offset..\n        // must align to the nearest 16 bytes or internally nearest round size\n\n        if (chunkSize % size !== 0 && chunkSize < 16)\n        {\n            // diff required to line up..\n            const lineUpValue = (chunkSize % size) % 16;\n\n            chunkSize += lineUpValue;\n            offset += lineUpValue;\n        }\n\n        if ((chunkSize + size) > 16)\n        {\n            offset = Math.ceil(offset / 16) * 16;\n            uboElement.offset = offset;\n            offset += size;\n            chunkSize = size;\n        }\n        else\n        {\n            uboElement.offset = offset;\n            chunkSize += size;\n            offset += size;\n        }\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\nexport function getUBOData(uniforms: Dict<any>, uniformData: Dict<any>): any[]\n{\n    const usedUniformDatas = [];\n\n    // build..\n    for (const i in uniforms)\n    {\n        if (uniformData[i])\n        {\n            usedUniformDatas.push(uniformData[i]);\n        }\n    }\n\n    // sort them out by index!\n    usedUniformDatas.sort((a, b) => a.index - b.index);\n\n    return usedUniformDatas;\n}\n\nexport function generateUniformBufferSync(\n    group: UniformGroup,\n    uniformData: Dict<any>\n): {size: number, syncFunc: UniformsSyncCallback}\n{\n    if (!group.autoManage)\n    {\n        // if the group is nott automatically managed, we don't need to generate a special function for it...\n        return { size: 0, syncFunc: uboUpdate };\n    }\n\n    const usedUniformDatas = getUBOData(group.uniforms, uniformData);\n\n    const { uboElements, size } = createUBOElements(usedUniformDatas);\n\n    const funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n        const uniform = group.uniforms[uboElement.data.name];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform))\n            {\n                funcFragments.push(\n                    `offset = ${uboElement.offset / 4};`,\n                    uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                const size = mapSize(uboElement.data.type);\n                const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n                const elementSize = size / rowSize;\n                const remainder = (4 - (elementSize % 4)) % 4;\n\n                funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n            }\n            else\n            {\n                const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n\n                funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n            }\n        }\n    }\n\n    funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `);\n\n    return {\n        size,\n        // eslint-disable-next-line no-new-func\n        syncFunc: new Function(\n            'ud',\n            'uv',\n            'renderer',\n            'syncData',\n            'buffer',\n            funcFragments.join('\\n')\n        ) as UniformsSyncCallback\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}