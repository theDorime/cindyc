{"ast":null,"code":"import { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  prefer() {\n    for (var _len = arguments.length, preferOrders = new Array(_len), _key = 0; _key < _len; _key++) {\n      preferOrders[_key] = arguments[_key];\n    }\n    preferOrders.forEach(prefer => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  get parsers() {\n    return this._parsers;\n  }\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  addManifest(manifest) {\n    if (this._manifest) {\n      console.warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach(bundle => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    if (Array.isArray(assets)) {\n      assets.forEach(asset => {\n        if (typeof asset.name === \"string\") {\n          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);\n          assetNames.push(bundleAssetId);\n          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);\n        } else {\n          const bundleIds = asset.name.map(name => this._createBundleAssetId(bundleId, name));\n          bundleIds.forEach(bundleId2 => {\n            assetNames.push(bundleId2);\n          });\n          this.add([...asset.name, ...bundleIds], asset.srcs);\n        }\n      });\n    } else {\n      Object.keys(assets).forEach(key => {\n        assetNames.push(this._createBundleAssetId(bundleId, key));\n        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);\n      });\n    }\n    this._bundles[bundleId] = assetNames;\n  }\n  add(keysIn, assetsIn, data) {\n    const keys = convertToList(keysIn);\n    keys.forEach(key => {\n      if (this.hasKey(key)) {\n        console.warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    });\n    if (!Array.isArray(assetsIn)) {\n      if (typeof assetsIn === \"string\") {\n        assetsIn = createStringVariations(assetsIn);\n      } else {\n        assetsIn = [assetsIn];\n      }\n    }\n    const assetMap = assetsIn.map(asset => {\n      let formattedAsset = asset;\n      if (typeof asset === \"string\") {\n        let parsed = false;\n        for (let i = 0; i < this._parsers.length; i++) {\n          const parser = this._parsers[i];\n          if (parser.test(asset)) {\n            formattedAsset = parser.parse(asset);\n            parsed = true;\n            break;\n          }\n        }\n        if (!parsed) {\n          formattedAsset = {\n            src: asset\n          };\n        }\n      }\n      if (!formattedAsset.format) {\n        formattedAsset.format = formattedAsset.src.split(\".\").pop();\n      }\n      if (!formattedAsset.alias) {\n        formattedAsset.alias = keys;\n      }\n      if (this._basePath || this._rootPath) {\n        formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n      }\n      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n      formattedAsset.data = formattedAsset.data ?? data;\n      return formattedAsset;\n    });\n    keys.forEach(key => {\n      this._assetMap[key] = assetMap;\n    });\n  }\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach(bundleId => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach(key => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          const bestAsset = assets[0];\n          preferredOrder?.priority.forEach(priorityKey => {\n            preferredOrder.params[priorityKey].forEach(value => {\n              const filteredAssets = assets.filter(asset => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0] ?? bestAsset;\n        } else {\n          let src = key;\n          if (this._basePath || this._rootPath) {\n            src = utils.path.toAbsolute(src, this._basePath, this._rootPath);\n          }\n          src = this._appendDefaultSearchParams(src);\n          this._resolverHash[key] = {\n            src\n          };\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find(preference => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams) return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n}\nexport { Resolver };","map":{"version":3,"names":["Resolver","constructor","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","replace","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_parsers","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","Error","prefer","_len","arguments","length","preferOrders","Array","_key","forEach","push","priority","Object","keys","params","basePath","_basePath","rootPath","_rootPath","parsers","reset","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","queryValues","map","key","encodeURIComponent","join","addManifest","manifest","console","warn","bundles","bundle","addBundle","name","assets","assetNames","isArray","asset","bundleAssetId","add","srcs","data","bundleIds","bundleId2","keysIn","assetsIn","convertToList","hasKey","createStringVariations","assetMap","formattedAsset","parsed","i","parser","test","parse","src","format","split","pop","alias","utils","path","toAbsolute","_appendDefaultSearchParams","resolveBundle","singleAsset","isSingleItem","out","results","resolve","resolveUrl","result","preferredOrder","_getPreferredOrder","bestAsset","priorityKey","value","filteredAssets","filter","hasBundle","preferred","find","preference","includes","url","paramConnector"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\assets\\src\\resolver\\Resolver.ts"],"sourcesContent":["import { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { PreferOrder, ResolveAsset, ResolverBundle, ResolverManifest, ResolveURLParser } from './types';\n\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof PIXI\n */\nexport class Resolver\n{\n    private _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolveAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolveAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: ResolverManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: ResolverManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            console.warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n        if (Array.isArray(assets))\n        {\n            assets.forEach((asset) =>\n            {\n                if (typeof asset.name === 'string')\n                {\n                    const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);\n\n                    assetNames.push(bundleAssetId);\n\n                    this.add([asset.name, bundleAssetId], asset.srcs, asset.data);\n                }\n                else\n                {\n                    const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));\n\n                    bundleIds.forEach((bundleId) =>\n                    {\n                        assetNames.push(bundleId);\n                    });\n\n                    this.add([...asset.name, ...bundleIds], asset.srcs);\n                }\n            });\n        }\n        else\n        {\n            Object.keys(assets).forEach((key) =>\n            {\n                assetNames.push(this._createBundleAssetId(bundleId, key));\n                this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);\n            });\n        }\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add('foo', 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add(['foo', 'boo'], 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add(['foo', 'boo'], ['bar.png', 'bar.webp']);\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * );\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param keysIn - The keys to map, can be an array or a single key\n     * @param assetsIn - The assets to associate with the key(s)\n     * @param data - The data that will be attached to the object that resolved object.\n     */\n    public add(keysIn: string | string[], assetsIn: string | ResolveAsset | (string | ResolveAsset)[], data?: unknown): void\n    {\n        const keys: string[] = convertToList<string>(keysIn);\n\n        keys.forEach((key) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                console.warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        });\n\n        if (!Array.isArray(assetsIn))\n        {\n            if (typeof assetsIn === 'string')\n            {\n                assetsIn = createStringVariations(assetsIn);\n            }\n            else\n            {\n                assetsIn = [assetsIn];\n            }\n        }\n\n        const assetMap: ResolveAsset[] = assetsIn.map((asset): ResolveAsset =>\n        {\n            let formattedAsset = asset as ResolveAsset;\n\n            // check if is a string\n            if (typeof asset === 'string')\n            {\n                // first see if it contains any {} tags...\n\n                let parsed = false;\n\n                for (let i = 0; i < this._parsers.length; i++)\n                {\n                    const parser = this._parsers[i];\n\n                    if (parser.test(asset))\n                    {\n                        formattedAsset = parser.parse(asset);\n                        parsed = true;\n                        break;\n                    }\n                }\n\n                if (!parsed)\n                {\n                    formattedAsset = {\n                        src: asset,\n                    };\n                }\n            }\n\n            if (!formattedAsset.format)\n            {\n                formattedAsset.format = formattedAsset.src.split('.').pop();\n            }\n\n            if (!formattedAsset.alias)\n            {\n                formattedAsset.alias = keys;\n            }\n\n            if (this._basePath || this._rootPath)\n            {\n                formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n            }\n\n            formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n\n            formattedAsset.data = formattedAsset.data ?? data;\n\n            return formattedAsset;\n        });\n\n        keys.forEach((key) =>\n        {\n            this._assetMap[key] = assetMap;\n        });\n    }\n\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'background',\n     *                     srcs: 'sunset.png',\n     *                 },\n     *                 {\n     *                     name: 'bar',\n     *                     srcs: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'character',\n     *                     srcs: 'robot.png',\n     *                 },\n     *                 {\n     *                     name: 'enemy',\n     *                     srcs: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: string | string[]):\n    Record<string, ResolveAsset> | Record<string, Record<string, ResolveAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolveAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolveAsset>;\n\n                const assets: Record<string, ResolveAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: string | string[]): string | Record<string, string>\n    {\n        const result = this.resolve(key);\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolveAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolveAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string | string[]): ResolveAsset | Record<string, ResolveAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolveAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    const bestAsset = assets[0];\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey])\n                                {\n                                    return asset[priorityKey] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = (assets[0] ?? bestAsset);\n                }\n                else\n                {\n                    let src = key;\n\n                    if (this._basePath || this._rootPath)\n                    {\n                        src = utils.path.toAbsolute(src, this._basePath, this._rootPath);\n                    }\n\n                    // make sure to append any default parameters\n                    src = this._appendDefaultSearchParams(src);\n\n                    // if the resolver fails we just pass back the key assuming its a url\n                    this._resolverHash[key] = {\n                        src,\n                    };\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolveAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}