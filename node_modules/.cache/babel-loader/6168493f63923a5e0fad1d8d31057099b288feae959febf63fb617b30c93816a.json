{"ast":null,"code":"import { Texture, BaseTexture } from '@pixi/core';\nimport '../utils/index.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */new Map();\n    this._cacheMap = /* @__PURE__ */new Map();\n  }\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  has(key) {\n    return this._cache.has(key);\n  }\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    if (!cacheableAssets) {\n      cacheableAssets = {};\n      keys.forEach(key2 => {\n        cacheableAssets[key2] = value;\n      });\n    }\n    const cacheKeys = Object.keys(cacheableAssets);\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach(key2 => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach(key2 => {\n      if (this._cache.has(key2) && this._cache.get(key2) !== value) {\n        console.warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableAssets[key2]);\n    });\n    if (value instanceof Texture) {\n      const texture = value;\n      keys.forEach(key2 => {\n        if (texture.baseTexture !== Texture.EMPTY.baseTexture) {\n          BaseTexture.addToCache(texture.baseTexture, key2);\n        }\n        Texture.addToCache(texture, key2);\n      });\n    }\n  }\n  remove(key) {\n    this._cacheMap.get(key);\n    if (!this._cacheMap.has(key)) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach(key2 => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach(key2 => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\nexport { Cache };","map":{"version":3,"names":["CacheClass","constructor","_parsers","_cache","Map","_cacheMap","reset","clear","has","key","get","result","console","warn","set","value","keys","convertToList","cacheableAssets","i","parsers","length","parser","test","getCacheableAssets","forEach","key2","cacheKeys","Object","cachedAssets","Texture","texture","baseTexture","EMPTY","BaseTexture","addToCache","remove","cacheMap","delete","Cache"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\assets\\src\\cache\\Cache.ts"],"sourcesContent":["import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                // #if _DEBUG\n                console.warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        this._cacheMap.get(key);\n\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}