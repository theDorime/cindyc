{"ast":null,"code":"import { BaseTexture } from '../BaseTexture.mjs';\nimport { autoDetectResource } from './autoDetectResource.mjs';\nimport { Resource } from './Resource.mjs';\nclass AbstractMultiResource extends Resource {\n  constructor(length, options) {\n    const {\n      width,\n      height\n    } = options || {};\n    super(width, height);\n    this.items = [];\n    this.itemDirtyIds = [];\n    for (let i = 0; i < length; i++) {\n      const partTexture = new BaseTexture();\n      this.items.push(partTexture);\n      this.itemDirtyIds.push(-2);\n    }\n    this.length = length;\n    this._load = null;\n    this.baseTexture = null;\n  }\n  initFromArray(resources, options) {\n    for (let i = 0; i < this.length; i++) {\n      if (!resources[i]) {\n        continue;\n      }\n      if (resources[i].castToBaseTexture) {\n        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n      } else if (resources[i] instanceof Resource) {\n        this.addResourceAt(resources[i], i);\n      } else {\n        this.addResourceAt(autoDetectResource(resources[i], options), i);\n      }\n    }\n  }\n  dispose() {\n    for (let i = 0, len = this.length; i < len; i++) {\n      this.items[i].destroy();\n    }\n    this.items = null;\n    this.itemDirtyIds = null;\n    this._load = null;\n  }\n  addResourceAt(resource, index) {\n    if (!this.items[index]) {\n      throw new Error(`Index ${index} is out of bounds`);\n    }\n    if (resource.valid && !this.valid) {\n      this.resize(resource.width, resource.height);\n    }\n    this.items[index].setResource(resource);\n    return this;\n  }\n  bind(baseTexture) {\n    if (this.baseTexture !== null) {\n      throw new Error(\"Only one base texture per TextureArray is allowed\");\n    }\n    super.bind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = baseTexture;\n      this.items[i].on(\"update\", baseTexture.update, baseTexture);\n    }\n  }\n  unbind(baseTexture) {\n    super.unbind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = null;\n      this.items[i].off(\"update\", baseTexture.update, baseTexture);\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const resources = this.items.map(item => item.resource).filter(item => item);\n    const promises = resources.map(item => item.load());\n    this._load = Promise.all(promises).then(() => {\n      const {\n        realWidth,\n        realHeight\n      } = this.items[0];\n      this.resize(realWidth, realHeight);\n      return Promise.resolve(this);\n    });\n    return this._load;\n  }\n}\nexport { AbstractMultiResource };","map":{"version":3,"names":["AbstractMultiResource","Resource","constructor","length","options","width","height","items","itemDirtyIds","i","partTexture","BaseTexture","push","_load","baseTexture","initFromArray","resources","castToBaseTexture","addBaseTextureAt","addResourceAt","autoDetectResource","dispose","len","destroy","resource","index","Error","valid","resize","setResource","bind","parentTextureArray","on","update","unbind","off","load","map","item","filter","promises","Promise","all","then","realWidth","realHeight","resolve"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\resources\\AbstractMultiResource.ts"],"sourcesContent":["import { BaseTexture } from '../BaseTexture';\nimport { autoDetectResource } from './autoDetectResource';\nimport { Resource } from './Resource';\n\nimport type { ISize } from '@pixi/math';\nimport type { IAutoDetectOptions } from './autoDetectResource';\n\n/**\n * Resource that can manage several resource (items) inside.\n * All resources need to have the same pixel size.\n * Parent class for CubeResource and ArrayResource\n * @memberof PIXI\n */\nexport abstract class AbstractMultiResource extends Resource\n{\n    /** Number of elements in array. */\n    readonly length: number;\n\n    /**\n     * Collection of partial baseTextures that correspond to resources.\n     * @readonly\n     */\n    items: Array<BaseTexture>;\n\n    /**\n     * Dirty IDs for each part.\n     * @readonly\n     */\n    itemDirtyIds: Array<number>;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** Bound baseTexture, there can only be one. */\n    baseTexture: BaseTexture;\n\n    /**\n     * @param length\n     * @param options - Options to for Resource constructor\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(length: number, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        super(width, height);\n\n        this.items = [];\n        this.itemDirtyIds = [];\n\n        for (let i = 0; i < length; i++)\n        {\n            const partTexture = new BaseTexture();\n\n            this.items.push(partTexture);\n            // -2 - first run of texture array upload\n            // -1 - texture item was allocated\n            // >=0 - texture item uploaded , in sync with items[i].dirtyId\n            this.itemDirtyIds.push(-2);\n        }\n\n        this.length = length;\n        this._load = null;\n        this.baseTexture = null;\n    }\n\n    /**\n     * Used from ArrayResource and CubeResource constructors.\n     * @param resources - Can be resources, image elements, canvas, etc. ,\n     *  length should be same as constructor length\n     * @param options - Detect options for resources\n     */\n    protected initFromArray(resources: Array<any>, options?: IAutoDetectOptions): void\n    {\n        for (let i = 0; i < this.length; i++)\n        {\n            if (!resources[i])\n            {\n                continue;\n            }\n            if (resources[i].castToBaseTexture)\n            {\n                this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n            }\n            else if (resources[i] instanceof Resource)\n            {\n                this.addResourceAt(resources[i], i);\n            }\n            else\n            {\n                this.addResourceAt(autoDetectResource(resources[i], options), i);\n            }\n        }\n    }\n\n    /** Destroy this BaseImageResource. */\n    dispose(): void\n    {\n        for (let i = 0, len = this.length; i < len; i++)\n        {\n            this.items[i].destroy();\n        }\n        this.items = null;\n        this.itemDirtyIds = null;\n        this._load = null;\n    }\n\n    /**\n     * Set a baseTexture by ID\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    abstract addBaseTextureAt(baseTexture: BaseTexture, index: number): this;\n\n    /**\n     * Set a resource by ID\n     * @param resource\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addResourceAt(resource: Resource, index: number): this\n    {\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        // Inherit the first resource dimensions\n        if (resource.valid && !this.valid)\n        {\n            this.resize(resource.width, resource.height);\n        }\n\n        this.items[index].setResource(resource);\n\n        return this;\n    }\n\n    /**\n     * Set the parent base texture.\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        if (this.baseTexture !== null)\n        {\n            throw new Error('Only one base texture per TextureArray is allowed');\n        }\n        super.bind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = baseTexture;\n            this.items[i].on('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Unset the parent base texture.\n     * @param baseTexture\n     */\n    unbind(baseTexture: BaseTexture): void\n    {\n        super.unbind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = null;\n            this.items[i].off('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Load all the resources simultaneously\n     * @returns - When load is resolved\n     */\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const resources = this.items.map((item) => item.resource).filter((item) => item);\n\n        // TODO: also implement load part-by-part strategy\n        const promises = resources.map((item) => item.load());\n\n        this._load = Promise.all(promises)\n            .then(() =>\n            {\n                const { realWidth, realHeight } = this.items[0];\n\n                this.resize(realWidth, realHeight);\n\n                return Promise.resolve(this);\n            }\n            );\n\n        return this._load;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}