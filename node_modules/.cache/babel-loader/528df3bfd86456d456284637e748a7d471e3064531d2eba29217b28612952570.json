{"ast":null,"code":"import { SAMPLER_TYPES, TYPES, MIPMAP_MODES, WRAP_MODES, SCALE_MODES } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { removeItems } from '@pixi/utils';\nimport { BaseTexture } from './BaseTexture.mjs';\nimport { GLTexture } from './GLTexture.mjs';\nimport { mapTypeAndFormatToInternalFormat } from './utils/mapTypeAndFormatToInternalFormat.mjs';\nclass TextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.boundTextures = [];\n    this.currentLocation = -1;\n    this.managedTextures = [];\n    this._unknownBoundTextures = false;\n    this.unknownTexture = new BaseTexture();\n    this.hasIntegerTextures = false;\n  }\n  contextChange() {\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.webGLVersion = this.renderer.context.webGLVersion;\n    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (let i = 0; i < maxTextures; i++) {\n      this.boundTextures[i] = null;\n    }\n    this.emptyTextures = {};\n    const emptyTexture2D = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (let i = 0; i < 6; i++) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.bind(null, i);\n    }\n  }\n  bind(texture) {\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const {\n      gl\n    } = this;\n    texture = texture?.castToBaseTexture();\n    if (texture?.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      if (this.boundTextures[location] !== texture) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        gl.bindTexture(texture.target, glTexture.texture);\n      }\n      if (glTexture.dirtyId !== texture.dirtyId) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        this.updateTexture(texture);\n      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {\n        this.updateTextureStyle(texture);\n      }\n      this.boundTextures[location] = texture;\n    } else {\n      if (this.currentLocation !== location) {\n        this.currentLocation = location;\n        gl.activeTexture(gl.TEXTURE0 + location);\n      }\n      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n      this.boundTextures[location] = null;\n    }\n  }\n  reset() {\n    this._unknownBoundTextures = true;\n    this.hasIntegerTextures = false;\n    this.currentLocation = -1;\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.boundTextures[i] = this.unknownTexture;\n    }\n  }\n  unbind(texture) {\n    const {\n      gl,\n      boundTextures\n    } = this;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = false;\n      for (let i = 0; i < boundTextures.length; i++) {\n        if (boundTextures[i] === this.unknownTexture) {\n          this.bind(null, i);\n        }\n      }\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === texture) {\n        if (this.currentLocation !== i) {\n          gl.activeTexture(gl.TEXTURE0 + i);\n          this.currentLocation = i;\n        }\n        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  ensureSamplerType(maxTextures) {\n    const {\n      boundTextures,\n      hasIntegerTextures,\n      CONTEXT_UID\n    } = this;\n    if (!hasIntegerTextures) {\n      return;\n    }\n    for (let i = maxTextures - 1; i >= 0; --i) {\n      const tex = boundTextures[i];\n      if (tex) {\n        const glTexture = tex._glTextures[CONTEXT_UID];\n        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {\n          this.renderer.texture.unbind(tex);\n        }\n      }\n    }\n  }\n  initTexture(texture) {\n    const glTexture = new GLTexture(this.gl.createTexture());\n    glTexture.dirtyId = -1;\n    texture._glTextures[this.CONTEXT_UID] = glTexture;\n    this.managedTextures.push(texture);\n    texture.on(\"dispose\", this.destroyTexture, this);\n    return glTexture;\n  }\n  initTextureType(texture, glTexture) {\n    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n    if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {\n      glTexture.type = this.gl.HALF_FLOAT;\n    } else {\n      glTexture.type = texture.type;\n    }\n  }\n  updateTexture(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    const renderer = this.renderer;\n    this.initTextureType(texture, glTexture);\n    if (texture.resource?.upload(renderer, texture, glTexture)) {\n      if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {\n        this.hasIntegerTextures = true;\n      }\n    } else {\n      const width = texture.realWidth;\n      const height = texture.realHeight;\n      const gl = renderer.gl;\n      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {\n        glTexture.width = width;\n        glTexture.height = height;\n        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);\n      }\n    }\n    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {\n      this.updateTextureStyle(texture);\n    }\n    glTexture.dirtyId = texture.dirtyId;\n  }\n  destroyTexture(texture, skipRemove) {\n    const {\n      gl\n    } = this;\n    texture = texture.castToBaseTexture();\n    if (texture._glTextures[this.CONTEXT_UID]) {\n      this.unbind(texture);\n      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n      texture.off(\"dispose\", this.destroyTexture, this);\n      delete texture._glTextures[this.CONTEXT_UID];\n      if (!skipRemove) {\n        const i = this.managedTextures.indexOf(texture);\n        if (i !== -1) {\n          removeItems(this.managedTextures, i, 1);\n        }\n      }\n    }\n  }\n  updateTextureStyle(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {\n      glTexture.mipmap = false;\n    } else {\n      glTexture.mipmap = texture.mipmap >= 1;\n    }\n    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {\n      glTexture.wrapMode = WRAP_MODES.CLAMP;\n    } else {\n      glTexture.wrapMode = texture.wrapMode;\n    }\n    if (texture.resource?.style(this.renderer, texture, glTexture)) {} else {\n      this.setStyle(texture, glTexture);\n    }\n    glTexture.dirtyStyleId = texture.dirtyStyleId;\n  }\n  setStyle(texture, glTexture) {\n    const gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {\n      gl.generateMipmap(texture.target);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n    if (glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {\n        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"texture\"\n};\nextensions.add(TextureSystem);\nexport { TextureSystem };","map":{"version":3,"names":["TextureSystem","constructor","renderer","boundTextures","currentLocation","managedTextures","_unknownBoundTextures","unknownTexture","BaseTexture","hasIntegerTextures","contextChange","gl","CONTEXT_UID","webGLVersion","context","internalFormats","mapTypeAndFormatToInternalFormat","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","length","i","emptyTextures","emptyTexture2D","GLTexture","createTexture","bindTexture","TEXTURE_2D","texture","texImage2D","RGBA","UNSIGNED_BYTE","Uint8Array","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","bind","location","arguments","undefined","castToBaseTexture","valid","parentTextureArray","touched","textureGC","count","glTexture","_glTextures","initTexture","activeTexture","TEXTURE0","target","dirtyId","updateTexture","dirtyStyleId","updateTextureStyle","reset","unbind","ensureSamplerType","tex","samplerType","SAMPLER_TYPES","FLOAT","push","on","destroyTexture","initTextureType","internalFormat","type","format","TYPES","HALF_FLOAT","resource","upload","width","realWidth","height","realHeight","skipRemove","deleteTexture","off","indexOf","removeItems","mipmap","MIPMAP_MODES","POW2","isPowerOfTwo","wrapMode","WRAP_MODES","CLAMP","style","setStyle","ON_MANUAL","generateMipmap","TEXTURE_WRAP_S","TEXTURE_WRAP_T","scaleMode","SCALE_MODES","LINEAR_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","anisotropicExt","extensions","anisotropicFiltering","anisotropicLevel","level","Math","min","MAX_TEXTURE_MAX_ANISOTROPY_EXT","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","NEAREST","destroy","extension","ExtensionType","RendererSystem","name","add"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\TextureSystem.ts"],"sourcesContent":["import { MIPMAP_MODES, SAMPLER_TYPES, SCALE_MODES, TYPES, WRAP_MODES } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { removeItems } from '@pixi/utils';\nimport { BaseTexture } from './BaseTexture';\nimport { GLTexture } from './GLTexture';\nimport { mapTypeAndFormatToInternalFormat } from './utils/mapTypeAndFormatToInternalFormat';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { Texture } from './Texture';\n\n/**\n * System plugin to the renderer to manage textures.\n * @memberof PIXI\n */\nexport class TextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'texture',\n    };\n\n    /**\n     * Bound textures.\n     * @readonly\n     */\n    public boundTextures: BaseTexture[];\n\n    /**\n     * List of managed textures.\n     * @readonly\n     */\n    public managedTextures: Array<BaseTexture>;\n\n    /** Whether glTexture with int/uint sampler type was uploaded. */\n    protected hasIntegerTextures: boolean;\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected internalFormats: { [type: number]: { [format: number]: number } };\n    protected webGLVersion: number;\n\n    /**\n     * BaseTexture value that shows that we don't know what is bound.\n     * @readonly\n     */\n    protected unknownTexture: BaseTexture;\n\n    /**\n     * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n     * @private\n     */\n    protected _unknownBoundTextures: boolean;\n\n    /**\n     * Current location.\n     * @readonly\n     */\n    currentLocation: number;\n    emptyTextures: {[key: number]: GLTexture};\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this system works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        // TODO set to max textures...\n        this.boundTextures = [];\n        this.currentLocation = -1;\n        this.managedTextures = [];\n\n        this._unknownBoundTextures = false;\n        this.unknownTexture = new BaseTexture();\n\n        this.hasIntegerTextures = false;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    contextChange(): void\n    {\n        const gl = this.gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        this.webGLVersion = this.renderer.context.webGLVersion;\n\n        this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this.boundTextures.length = maxTextures;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            this.boundTextures[i] = null;\n        }\n\n        // TODO move this.. to a nice make empty textures class..\n        this.emptyTextures = {};\n\n        const emptyTexture2D = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n\n        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n\n        for (let i = 0; i < 6; i++)\n        {\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.bind(null, i);\n        }\n    }\n\n    /**\n     * Bind a texture to a specific location\n     *\n     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`\n     * @param texture - Texture to bind\n     * @param [location=0] - Location to bind at\n     */\n    bind(texture: Texture | BaseTexture, location = 0): void\n    {\n        const { gl } = this;\n\n        texture = texture?.castToBaseTexture();\n\n        // cannot bind partial texture\n        // TODO: report a warning\n        if (texture?.valid && !texture.parentTextureArray)\n        {\n            texture.touched = this.renderer.textureGC.count;\n\n            const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n\n            if (this.boundTextures[location] !== texture)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n\n                gl.bindTexture(texture.target, glTexture.texture);\n            }\n\n            if (glTexture.dirtyId !== texture.dirtyId)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n                this.updateTexture(texture);\n            }\n            else if (glTexture.dirtyStyleId !== texture.dirtyStyleId)\n            {\n                this.updateTextureStyle(texture);\n            }\n\n            this.boundTextures[location] = texture;\n        }\n        else\n        {\n            if (this.currentLocation !== location)\n            {\n                this.currentLocation = location;\n                gl.activeTexture(gl.TEXTURE0 + location);\n            }\n\n            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n            this.boundTextures[location] = null;\n        }\n    }\n\n    /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */\n    reset(): void\n    {\n        this._unknownBoundTextures = true;\n        this.hasIntegerTextures = false;\n        this.currentLocation = -1;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.boundTextures[i] = this.unknownTexture;\n        }\n    }\n\n    /**\n     * Unbind a texture.\n     * @param texture - Texture to bind\n     */\n    unbind(texture?: BaseTexture): void\n    {\n        const { gl, boundTextures } = this;\n\n        if (this._unknownBoundTextures)\n        {\n            this._unknownBoundTextures = false;\n            // someone changed webGL state,\n            // we have to be sure that our texture does not appear in multi-texture renderer samplers\n            for (let i = 0; i < boundTextures.length; i++)\n            {\n                if (boundTextures[i] === this.unknownTexture)\n                {\n                    this.bind(null, i);\n                }\n            }\n        }\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === texture)\n            {\n                if (this.currentLocation !== i)\n                {\n                    gl.activeTexture(gl.TEXTURE0 + i);\n                    this.currentLocation = i;\n                }\n\n                gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    /**\n     * Ensures that current boundTextures all have FLOAT sampler type,\n     * see {@link PIXI.SAMPLER_TYPES} for explanation.\n     * @param maxTextures - number of locations to check\n     */\n    ensureSamplerType(maxTextures: number): void\n    {\n        const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n\n        if (!hasIntegerTextures)\n        {\n            return;\n        }\n\n        for (let i = maxTextures - 1; i >= 0; --i)\n        {\n            const tex = boundTextures[i];\n\n            if (tex)\n            {\n                const glTexture = tex._glTextures[CONTEXT_UID];\n\n                if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n                {\n                    this.renderer.texture.unbind(tex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Initialize a texture\n     * @private\n     * @param texture - Texture to initialize\n     */\n    initTexture(texture: BaseTexture): GLTexture\n    {\n        const glTexture = new GLTexture(this.gl.createTexture());\n\n        // guarantee an update..\n        glTexture.dirtyId = -1;\n\n        texture._glTextures[this.CONTEXT_UID] = glTexture;\n\n        this.managedTextures.push(texture);\n        texture.on('dispose', this.destroyTexture, this);\n\n        return glTexture;\n    }\n\n    initTextureType(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n\n        if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT)\n        {\n            // TYPES.HALF_FLOAT is WebGL1 HALF_FLOAT_OES\n            // we have to convert it to WebGL HALF_FLOAT\n            glTexture.type = this.gl.HALF_FLOAT;\n        }\n        else\n        {\n            glTexture.type = texture.type;\n        }\n    }\n\n    /**\n     * Update a texture\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to initialize\n     */\n    updateTexture(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n\n        this.initTextureType(texture, glTexture);\n\n        if (texture.resource?.upload(renderer, texture, glTexture))\n        {\n            // texture is uploaded, dont do anything!\n            if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n            {\n                this.hasIntegerTextures = true;\n            }\n        }\n        else\n        {\n            // default, renderTexture-like logic\n            const width = texture.realWidth;\n            const height = texture.realHeight;\n            const gl = renderer.gl;\n\n            if (glTexture.width !== width\n                || glTexture.height !== height\n                || glTexture.dirtyId < 0)\n            {\n                glTexture.width = width;\n                glTexture.height = height;\n\n                gl.texImage2D(texture.target, 0,\n                    glTexture.internalFormat,\n                    width,\n                    height,\n                    0,\n                    texture.format,\n                    glTexture.type,\n                    null);\n            }\n        }\n\n        // lets only update what changes..\n        if (texture.dirtyStyleId !== glTexture.dirtyStyleId)\n        {\n            this.updateTextureStyle(texture);\n        }\n        glTexture.dirtyId = texture.dirtyId;\n    }\n\n    /**\n     * Deletes the texture from WebGL\n     * @private\n     * @param texture - the texture to destroy\n     * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n     */\n    destroyTexture(texture: BaseTexture | Texture, skipRemove?: boolean): void\n    {\n        const { gl } = this;\n\n        texture = texture.castToBaseTexture();\n\n        if (texture._glTextures[this.CONTEXT_UID])\n        {\n            this.unbind(texture);\n\n            gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n            texture.off('dispose', this.destroyTexture, this);\n\n            delete texture._glTextures[this.CONTEXT_UID];\n\n            if (!skipRemove)\n            {\n                const i = this.managedTextures.indexOf(texture);\n\n                if (i !== -1)\n                {\n                    removeItems(this.managedTextures, i, 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Update texture style such as mipmap flag\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to update\n     */\n    updateTextureStyle(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo)\n        {\n            glTexture.mipmap = false;\n        }\n        else\n        {\n            glTexture.mipmap = texture.mipmap >= 1;\n        }\n\n        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo)\n        {\n            glTexture.wrapMode = WRAP_MODES.CLAMP;\n        }\n        else\n        {\n            glTexture.wrapMode = texture.wrapMode;\n        }\n\n        if (texture.resource?.style(this.renderer, texture, glTexture))\n        {\n            // style is set, dont do anything!\n        }\n        else\n        {\n            this.setStyle(texture, glTexture);\n        }\n\n        glTexture.dirtyStyleId = texture.dirtyStyleId;\n    }\n\n    /**\n     * Set style for texture\n     * @private\n     * @param texture - Texture to update\n     * @param glTexture\n     */\n    setStyle(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        const gl = this.gl;\n\n        if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL)\n        {\n            gl.generateMipmap(texture.target);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n\n        if (glTexture.mipmap)\n        {\n            /* eslint-disable max-len */\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n            /* eslint-disable max-len */\n\n            const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n\n            if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR)\n            {\n                const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n                gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n            }\n        }\n        else\n        {\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(TextureSystem);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}