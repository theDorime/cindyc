{"ast":null,"code":"import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource.mjs';\nclass ArrayResource extends AbstractMultiResource {\n  constructor(source, options) {\n    const {\n      width,\n      height\n    } = options || {};\n    let urls;\n    let length;\n    if (Array.isArray(source)) {\n      urls = source;\n      length = source.length;\n    } else {\n      length = source;\n    }\n    super(length, {\n      width,\n      height\n    });\n    if (urls) {\n      this.initFromArray(urls, options);\n    }\n  }\n  addBaseTextureAt(baseTexture, index) {\n    if (baseTexture.resource) {\n      this.addResourceAt(baseTexture.resource, index);\n    } else {\n      throw new Error(\"ArrayResource does not support RenderTexture\");\n    }\n    return this;\n  }\n  bind(baseTexture) {\n    super.bind(baseTexture);\n    baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;\n  }\n  upload(renderer, texture, glTexture) {\n    const {\n      length,\n      itemDirtyIds,\n      items\n    } = this;\n    const {\n      gl\n    } = renderer;\n    if (glTexture.dirtyId < 0) {\n      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);\n    }\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n      if (itemDirtyIds[i] < item.dirtyId) {\n        itemDirtyIds[i] = item.dirtyId;\n        if (item.valid) {\n          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);\n        }\n      }\n    }\n    return true;\n  }\n}\nexport { ArrayResource };","map":{"version":3,"names":["ArrayResource","AbstractMultiResource","constructor","source","options","width","height","urls","length","Array","isArray","initFromArray","addBaseTextureAt","baseTexture","index","resource","addResourceAt","Error","bind","target","TARGETS","TEXTURE_2D_ARRAY","upload","renderer","texture","glTexture","itemDirtyIds","items","gl","dirtyId","texImage3D","internalFormat","_width","_height","format","type","i","item","valid","texSubImage3D"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\resources\\ArrayResource.ts"],"sourcesContent":["import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\nimport type { BaseImageResource } from './BaseImageResource';\n\n/**\n * A resource that contains a number of sources.\n * @memberof PIXI\n */\nexport class ArrayResource extends AbstractMultiResource\n{\n    /**\n     * @param source - Number of items in array or the collection\n     *        of image URLs to use. Can also be resources, image elements, canvas, etc.\n     * @param options - Options to apply to {@link PIXI.autoDetectResource}\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(source: number | Array<any>, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        let urls;\n        let length: number;\n\n        if (Array.isArray(source))\n        {\n            urls = source;\n            length = source.length;\n        }\n        else\n        {\n            length = source;\n        }\n\n        super(length, { width, height });\n\n        if (urls)\n        {\n            this.initFromArray(urls, options);\n        }\n    }\n\n    /**\n     * Set a baseTexture by ID,\n     * ArrayResource just takes resource from it, nothing more\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addBaseTextureAt(baseTexture: BaseTexture, index: number): this\n    {\n        if (baseTexture.resource)\n        {\n            this.addResourceAt(baseTexture.resource, index);\n        }\n        else\n        {\n            throw new Error('ArrayResource does not support RenderTexture');\n        }\n\n        return this;\n    }\n\n    /**\n     * Add binding\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;\n    }\n\n    /**\n     * Upload the resources to the GPU.\n     * @param renderer\n     * @param texture\n     * @param glTexture\n     * @returns - whether texture was uploaded\n     */\n    upload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const { length, itemDirtyIds, items } = this;\n        const { gl } = renderer;\n\n        if (glTexture.dirtyId < 0)\n        {\n            gl.texImage3D(\n                gl.TEXTURE_2D_ARRAY,\n                0,\n                glTexture.internalFormat,\n                this._width,\n                this._height,\n                length,\n                0,\n                texture.format,\n                glTexture.type,\n                null\n            );\n        }\n\n        for (let i = 0; i < length; i++)\n        {\n            const item = items[i];\n\n            if (itemDirtyIds[i] < item.dirtyId)\n            {\n                itemDirtyIds[i] = item.dirtyId;\n                if (item.valid)\n                {\n                    gl.texSubImage3D(\n                        gl.TEXTURE_2D_ARRAY,\n                        0,\n                        0, // xoffset\n                        0, // yoffset\n                        i, // zoffset\n                        item.resource.width,\n                        item.resource.height,\n                        1,\n                        texture.format,\n                        glTexture.type,\n                        (item.resource as BaseImageResource).source\n                    );\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"],"mappings":";;AAaO,MAAMA,aAAA,SAAsBC,qBACnC;EAQIC,YAAYC,MAAA,EAA6BC,OACzC;IACI,MAAM;MAAEC,KAAA;MAAOC;IAAW,IAAAF,OAAA,IAAW,EAAC;IAElC,IAAAG,IAAA;IACA,IAAAC,MAAA;IAEA,IAAAC,KAAA,CAAMC,OAAQ,CAAAP,MAAM,CACxB;MACWI,IAAA,GAAAJ,MAAA;MACPK,MAAA,GAASL,MAAO,CAAAK,MAAA;IAAA,CAGpB;MACaA,MAAA,GAAAL,MAAA;IAAA;IAGb,MAAMK,MAAQ;MAAEH,KAAO;MAAAC;IAAA,CAAQ;IAE/B,IAAIC,IACJ;MACS,KAAAI,aAAA,CAAcJ,IAAA,EAAMH,OAAO;IAAA;EACpC;EAUJQ,iBAAiBC,WAAA,EAA0BC,KAC3C;IACI,IAAID,WAAA,CAAYE,QAChB;MACS,KAAAC,aAAA,CAAcH,WAAY,CAAAE,QAAA,EAAUD,KAAK;IAAA,CAGlD;MACU,UAAIG,KAAA,CAAM,8CAA8C;IAAA;IAG3D;EAAA;EAOXC,KAAKL,WACL;IACI,MAAMK,IAAA,CAAKL,WAAW;IAEtBA,WAAA,CAAYM,MAAA,GAASC,OAAQ,CAAAC,gBAAA;EAAA;EAUjCC,OAAOC,QAAoB,EAAAC,OAAA,EAAsBC,SACjD;IACU;MAAEjB,MAAQ;MAAAkB,YAAA;MAAcC;IAAU;IACxC,MAAM;MAAEC;IAAO,IAAAL,QAAA;IAEX,IAAAE,SAAA,CAAUI,OAAA,GAAU,CACxB;MACID,EAAA,CAAGE,UAAA,CACCF,EAAG,CAAAP,gBAAA,EACH,CACA,EAAAI,SAAA,CAAUM,cAAA,EACV,IAAK,CAAAC,MAAA,EACL,IAAK,CAAAC,OAAA,EACLzB,MAAA,EACA,CACA,EAAAgB,OAAA,CAAQU,MACR,EAAAT,SAAA,CAAUU,IAAA,EACV,IACJ;IAAA;IAGJ,SAASC,CAAI,MAAGA,CAAI,GAAA5B,MAAA,EAAQ4B,CAC5B;MACI,MAAMC,IAAA,GAAOV,KAAM,CAAAS,CAAA;MAEf,IAAAV,YAAA,CAAaU,CAAK,IAAAC,IAAA,CAAKR,OAC3B;QACIH,YAAA,CAAaU,CAAA,IAAKC,IAAK,CAAAR,OAAA;QACvB,IAAIQ,IAAA,CAAKC,KACT;UACOV,EAAA,CAAAW,aAAA,CACCX,EAAA,CAAGP,gBACH,KACA,GACA,CACA,EAAAe,CAAA,EACAC,IAAA,CAAKtB,QAAS,CAAAV,KAAA,EACdgC,IAAA,CAAKtB,QAAS,CAAAT,MAAA,EACd,GACAkB,OAAQ,CAAAU,MAAA,EACRT,SAAA,CAAUU,IACT,EAAAE,IAAA,CAAKtB,QAAA,CAA+BZ,MACzC;QAAA;MACJ;IACJ;IAGG;EAAA;AAEf"},"metadata":{},"sourceType":"module","externalDependencies":[]}