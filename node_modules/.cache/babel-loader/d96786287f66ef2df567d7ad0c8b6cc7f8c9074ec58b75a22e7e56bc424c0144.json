{"ast":null,"code":"import { Ticker } from '@pixi/ticker';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nconst _VideoResource = class extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    if (!(source instanceof HTMLVideoElement)) {\n      const videoElement = document.createElement(\"video\");\n      videoElement.setAttribute(\"preload\", \"auto\");\n      videoElement.setAttribute(\"webkit-playsinline\", \"\");\n      videoElement.setAttribute(\"playsinline\", \"\");\n      if (typeof source === \"string\") {\n        source = [source];\n      }\n      const firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (let i = 0; i < source.length; ++i) {\n        const sourceElement = document.createElement(\"source\");\n        let {\n          src,\n          mime\n        } = source[i];\n        src = src || source[i];\n        const baseSrc = src.split(\"?\").shift().toLowerCase();\n        const ext = baseSrc.slice(baseSrc.lastIndexOf(\".\") + 1);\n        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;\n        sourceElement.src = src;\n        sourceElement.type = mime;\n        videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    super(source);\n    this.noSubImage = true;\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this._load = null;\n    this._resolve = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onError = this._onError.bind(this);\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  update() {\n    let _deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (!this.destroyed) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      if (!this._updateFPS || this._msToNextUpdate <= 0) {\n        super.update();\n        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n      }\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.source;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart.bind(this));\n    source.addEventListener(\"pause\", this._onPlayStop.bind(this));\n    if (!this._isSourceReady()) {\n      source.addEventListener(\"canplay\", this._onCanPlay);\n      source.addEventListener(\"canplaythrough\", this._onCanPlay);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._onCanPlay();\n    }\n    this._load = new Promise(resolve => {\n      if (this.valid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  _onError(event) {\n    this.source.removeEventListener(\"error\", this._onError, true);\n    this.onError.emit(event);\n  }\n  _isSourcePlaying() {\n    const source = this.source;\n    return !source.paused && !source.ended && this._isSourceReady();\n  }\n  _isSourceReady() {\n    const source = this.source;\n    return source.readyState > 2;\n  }\n  _onPlayStart() {\n    if (!this.valid) {\n      this._onCanPlay();\n    }\n    if (this.autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this);\n      this._isConnectedToTicker = true;\n    }\n  }\n  _onPlayStop() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  _onCanPlay() {\n    const source = this.source;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    const valid = this.valid;\n    this.resize(source.videoWidth, source.videoHeight);\n    if (!valid && this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      source.play();\n    }\n  }\n  dispose() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n    const source = this.source;\n    if (source) {\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.dispose();\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n    }\n  }\n  static test(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);\n  }\n};\nlet VideoResource = _VideoResource;\nVideoResource.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"];\nVideoResource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nexport { VideoResource };","map":{"version":3,"names":["_VideoResource","BaseImageResource","constructor","source","options","HTMLVideoElement","videoElement","document","createElement","setAttribute","firstSrc","src","crossOrigin","crossorigin","i","length","sourceElement","mime","baseSrc","split","shift","toLowerCase","ext","slice","lastIndexOf","MIME_TYPES","type","appendChild","noSubImage","_autoUpdate","_isConnectedToTicker","_updateFPS","updateFPS","_msToNextUpdate","autoPlay","_load","_resolve","_onCanPlay","bind","_onError","autoLoad","load","update","_deltaTime","arguments","undefined","destroyed","elapsedMS","Ticker","shared","playbackRate","Math","floor","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","width","height","complete","addEventListener","_onPlayStart","_onPlayStop","_isSourceReady","Promise","resolve","valid","event","removeEventListener","onError","emit","_isSourcePlaying","paused","ended","autoUpdate","add","remove","resize","videoWidth","videoHeight","play","dispose","pause","value","test","extension","globalThis","TYPES","includes","VideoResource","ogv","mov","m4v"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\resources\\VideoResource.ts"],"sourcesContent":["import { Ticker } from '@pixi/ticker';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { Dict } from '@pixi/utils';\n\nexport interface IVideoResourceOptions\n{\n    autoLoad?: boolean;\n    autoPlay?: boolean;\n    updateFPS?: number;\n    crossorigin?: boolean | string;\n}\n\nexport interface IVideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * Resource type for {@link HTMLVideoElement}.\n * @memberof PIXI\n */\nexport class VideoResource extends BaseImageResource\n{\n    /** Override the source to be the video element. */\n    public source: HTMLVideoElement;\n\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    protected _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    protected _isConnectedToTicker: boolean;\n    protected _updateFPS: number;\n    protected _msToNextUpdate: number;\n\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n\n    /**\n     * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.\n     * @param {object} [options] - Options to use\n     * @param {boolean} [options.autoLoad=true] - Start loading the video immediately\n     * @param {boolean} [options.autoPlay=true] - Start playing video immediately\n     * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n     */\n    constructor(\n        source?: HTMLVideoElement | Array<string | IVideoResourceOptionsElement> | string, options?: IVideoResourceOptions\n    )\n    {\n        options = options || {};\n\n        if (!(source instanceof HTMLVideoElement))\n        {\n            const videoElement = document.createElement('video');\n\n            // workaround for https://github.com/pixijs/pixijs/issues/5996\n            videoElement.setAttribute('preload', 'auto');\n            videoElement.setAttribute('webkit-playsinline', '');\n            videoElement.setAttribute('playsinline', '');\n\n            if (typeof source === 'string')\n            {\n                source = [source];\n            }\n\n            const firstSrc = (source[0] as IVideoResourceOptionsElement).src || source[0] as string;\n\n            BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n\n            // array of objects or strings\n            for (let i = 0; i < source.length; ++i)\n            {\n                const sourceElement = document.createElement('source');\n\n                let { src, mime } = source[i] as IVideoResourceOptionsElement;\n\n                src = src || source[i] as string;\n\n                const baseSrc = src.split('?').shift().toLowerCase();\n                const ext = baseSrc.slice(baseSrc.lastIndexOf('.') + 1);\n\n                mime = mime || VideoResource.MIME_TYPES[ext] || `video/${ext}`;\n\n                sourceElement.src = src;\n                sourceElement.type = mime;\n\n                videoElement.appendChild(sourceElement);\n            }\n\n            // Override the source\n            source = videoElement;\n        }\n\n        super(source);\n\n        this.noSubImage = true;\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n\n        this._load = null;\n        this._resolve = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onError = this._onError.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Trigger updating of the texture.\n     * @param _deltaTime - time delta since last tick\n     */\n    update(_deltaTime = 0): void\n    {\n        if (!this.destroyed)\n        {\n            // account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * (this.source as HTMLVideoElement).playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n            if (!this._updateFPS || this._msToNextUpdate <= 0)\n            {\n                super.update(/* deltaTime*/);\n                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n            }\n        }\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<void>} Handle the validate event\n     */\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.source as HTMLVideoElement;\n\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n\n        if (!this._isSourceReady())\n        {\n            source.addEventListener('canplay', this._onCanPlay);\n            source.addEventListener('canplaythrough', this._onCanPlay);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            this._onCanPlay();\n        }\n\n        this._load = new Promise((resolve): void =>\n        {\n            if (this.valid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        (this.source as HTMLVideoElement).removeEventListener('error', this._onError, true);\n        this.onError.emit(event);\n    }\n\n    /**\n     * Returns true if the underlying source is playing.\n     * @returns - True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.source as HTMLVideoElement;\n\n        return (!source.paused && !source.ended && this._isSourceReady());\n    }\n\n    /**\n     * Returns true if the underlying source is ready for playing.\n     * @returns - True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.source as HTMLVideoElement;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Just in case the video has not received its can play even yet..\n        if (!this.valid)\n        {\n            this._onCanPlay();\n        }\n\n        if (this.autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /** Fired when a pause event is triggered, stops the update loop. */\n    private _onPlayStop(): void\n    {\n        if (this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _onCanPlay(): void\n    {\n        const source = this.source as HTMLVideoElement;\n\n        source.removeEventListener('canplay', this._onCanPlay);\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        const valid = this.valid;\n\n        this.resize(source.videoWidth, source.videoHeight);\n\n        // prevent multiple loaded dispatches..\n        if (!valid && this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n        }\n\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            source.play();\n        }\n    }\n\n    /** Destroys this texture. */\n    dispose(): void\n    {\n        if (this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n\n        const source = this.source as HTMLVideoElement;\n\n        if (source)\n        {\n            source.removeEventListener('error', this._onError, true);\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n        super.dispose();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying())\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video. Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n        }\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @param {string} extension - The extension of source, if set\n     * @returns {boolean} `true` if video source\n     */\n    static test(source: unknown, extension?: string): source is HTMLVideoElement\n    {\n        return (globalThis.HTMLVideoElement && source instanceof HTMLVideoElement)\n            || VideoResource.TYPES.includes(extension);\n    }\n\n    /**\n     * List of common video file extensions supported by VideoResource.\n     * @readonly\n     */\n    static TYPES: Array<string> = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    static MIME_TYPES: Dict<string> = {\n        ogv: 'video/ogg',\n        mov: 'video/quicktime',\n        m4v: 'video/mp4',\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}