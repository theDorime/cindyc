{"ast":null,"code":"import { BoundingBox } from './BoundingBox.mjs';\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0) return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0) return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas) {\n  const {\n    width,\n    height\n  } = canvas;\n  const context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError(\"Failed to get canvas 2D context\");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top)) ++top;\n  if (top === height) return BoundingBox.EMPTY;\n  while (checkRow(data, width, bottom)) --bottom;\n  while (checkColumn(data, width, left, top, bottom)) ++left;\n  while (checkColumn(data, width, right, top, bottom)) --right;\n  ++right;\n  ++bottom;\n  return new BoundingBox(left, top, right, bottom);\n}\nexport { getCanvasBoundingBox };","map":{"version":3,"names":["checkRow","data","width","y","x","index","checkColumn","top","bottom","stride","getCanvasBoundingBox","canvas","height","context","getContext","willReadFrequently","TypeError","imageData","getImageData","left","right","BoundingBox","EMPTY"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\utils\\src\\media\\getCanvasBoundingBox.ts"],"sourcesContent":["import { BoundingBox } from './BoundingBox';\n\nimport type { ICanvas } from '@pixi/settings';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @memberof PIXI.utils\n * @param {PIXI.ICanvas} canvas - The canvas to measure.\n * @returns {PIXI.utils.BoundingBox} The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas): BoundingBox\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return BoundingBox.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new BoundingBox(left, top, right, bottom);\n}\n"],"mappings":";AAIA,SAAkBA,SAAAC,IAAA,EAAyBC,KAAA,EAAeC,CAC1D;EACa,SAAAC,CAAA,GAAI,CAAG,EAAAC,KAAA,GAAQ,CAAI,GAAAF,CAAA,GAAID,KAAO,EAAAE,CAAA,GAAIF,KAAO,IAAEE,CAAG,EAAAC,KAAA,IAAS,CAChE;IACQ,IAAAJ,IAAA,CAAKI,KAAA,GAAQ,CAAO,SAAU;EAAA;EAG/B;AACX;AAEA,SAAAC,YAAqBL,IAAyB,EAAAC,KAAA,EAAeE,CAAW,EAAAG,GAAA,EAAaC,MACrF;EACI,MAAMC,MAAA,GAAS,CAAI,GAAAP,KAAA;EAEnB,SAASC,CAAI,GAAAI,GAAA,EAAKF,KAAS,GAAAE,GAAA,GAAME,MAAW,OAAIL,CAAI,EAAAD,CAAA,IAAKK,MAAQ,IAAEL,CAAG,EAAAE,KAAA,IAASI,MAC/E;IACQ,IAAAR,IAAA,CAAKI,KAAA,GAAQ,CAAO,SAAU;EAAA;EAG/B;AACX;AASO,SAAAK,qBAA8BC,MACrC;EAGU;IAAET,KAAA;IAAOU;EAAW,IAAAD,MAAA;EAEpB,MAAAE,OAAA,GAAUF,MAAO,CAAAG,UAAA,CAAW,IAAM;IACpCC,kBAAoB;EAAA,CACvB;EAED,IAAIF,OAAA,KAAY,IAChB;IACU,UAAIG,SAAA,CAAU,iCAAiC;EAAA;EAGzD,MAAMC,SAAA,GAAYJ,OAAQ,CAAAK,YAAA,CAAa,CAAG,KAAGhB,KAAA,EAAOU,MAAM;EAC1D,MAAMX,IAAA,GAAOgB,SAAU,CAAAhB,IAAA;EAEvB,IAAIkB,IAAO;EACX,IAAIZ,GAAM;EACV,IAAIa,KAAA,GAAQlB,KAAQ;EACpB,IAAIM,MAAA,GAASI,MAAS;EAEtB,OAAOL,GAAM,GAAAK,MAAA,IAAUZ,QAAS,CAAAC,IAAA,EAAMC,KAAA,EAAOK,GAAG,GAAK,EAAAA,GAAA;EACrD,IAAIA,GAAQ,KAAAK,MAAA,EAAQ,OAAOS,WAAY,CAAAC,KAAA;EAChC,OAAAtB,QAAA,CAASC,IAAM,EAAAC,KAAA,EAAOM,MAAM,GAAK,EAAAA,MAAA;EACxC,OAAOF,WAAY,CAAAL,IAAA,EAAMC,KAAO,EAAAiB,IAAA,EAAMZ,GAAA,EAAKC,MAAM,GAAK,EAAAW,IAAA;EACtD,OAAOb,WAAY,CAAAL,IAAA,EAAMC,KAAO,EAAAkB,KAAA,EAAOb,GAAA,EAAKC,MAAM,GAAK,EAAAY,KAAA;EAErD,EAAAA,KAAA;EACA,EAAAZ,MAAA;EAEF,OAAO,IAAIa,WAAA,CAAYF,IAAM,EAAAZ,GAAA,EAAKa,KAAA,EAAOZ,MAAM;AACnD"},"metadata":{},"sourceType":"module","externalDependencies":[]}