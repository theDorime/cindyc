{"ast":null,"code":"import { curves } from '../const.mjs';\nclass BezierUtils {\n  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    const n = 10;\n    let result = 0;\n    let t = 0;\n    let t2 = 0;\n    let t3 = 0;\n    let nt = 0;\n    let nt2 = 0;\n    let nt3 = 0;\n    let x = 0;\n    let y = 0;\n    let dx = 0;\n    let dy = 0;\n    let prevX = fromX;\n    let prevY = fromY;\n    for (let i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  }\n  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    points.length -= 2;\n    const n = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n    points.push(fromX, fromY);\n    for (let i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  }\n}\nexport { BezierUtils };","map":{"version":3,"names":["BezierUtils","curveLength","fromX","fromY","cpX","cpY","cpX2","cpY2","toX","toY","n","result","t","t2","t3","nt","nt2","nt3","x","y","dx","dy","prevX","prevY","i","Math","sqrt","curveTo","points","length","curves","_segmentsCount","dt","dt2","dt3","push","j"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\graphics\\src\\utils\\BezierUtils.ts"],"sourcesContent":["import { curves } from '../const';\n\n/**\n * Utilities for bezier curves\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = curves._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}