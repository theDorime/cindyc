{"ast":null,"code":"import { ENV, BUFFER_TYPE } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nconst byteSizeMap = {\n  5126: 4,\n  5123: 2,\n  5121: 1\n};\nclass GeometrySystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this.canUseUInt32ElementIndex = false;\n    this.managedGeometries = {};\n  }\n  contextChange() {\n    this.disposeAll(true);\n    const gl = this.gl = this.renderer.gl;\n    const context = this.renderer.context;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    if (context.webGLVersion !== 2) {\n      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {\n        nativeVaoExtension = null;\n      }\n      if (nativeVaoExtension) {\n        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n        gl.bindVertexArray = vao => nativeVaoExtension.bindVertexArrayOES(vao);\n        gl.deleteVertexArray = vao => nativeVaoExtension.deleteVertexArrayOES(vao);\n      } else {\n        this.hasVao = false;\n        gl.createVertexArray = () => null;\n        gl.bindVertexArray = () => null;\n        gl.deleteVertexArray = () => null;\n      }\n    }\n    if (context.webGLVersion !== 2) {\n      const instanceExt = gl.getExtension(\"ANGLE_instanced_arrays\");\n      if (instanceExt) {\n        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);\n        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n      } else {\n        this.hasInstance = false;\n      }\n    }\n    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n  }\n  bind(geometry, shader) {\n    shader = shader || this.renderer.shader.shader;\n    const {\n      gl\n    } = this;\n    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let incRefCount = false;\n    if (!vaos) {\n      this.managedGeometries[geometry.id] = geometry;\n      geometry.disposeRunner.add(this);\n      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n      incRefCount = true;\n    }\n    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n    this._activeGeometry = geometry;\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      if (this.hasVao) {\n        gl.bindVertexArray(vao);\n      } else {\n        this.activateVao(geometry, shader.program);\n      }\n    }\n    this.updateBuffers();\n  }\n  reset() {\n    this.unbind();\n  }\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this.renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.update(buffer);\n    }\n  }\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n      }\n    }\n  }\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    const strings = [\"g\", geometry.id];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join(\"-\");\n  }\n  initGeometryVao(geometry, shader) {\n    let incRefCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const program = shader.program;\n    if (!program.glPrograms[CONTEXT_UID]) {\n      this.renderer.shader.generateProgram(shader);\n    }\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program.id] = vao;\n      return vao;\n    }\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    const tempStride = {};\n    const tempStart = {};\n    for (const j in buffers) {\n      tempStride[j] = 0;\n      tempStart[j] = 0;\n    }\n    for (const j in attributes) {\n      if (!attributes[j].size && program.attributeData[j]) {\n        attributes[j].size = program.attributeData[j].size;\n      } else if (!attributes[j].size) {\n        console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);\n      }\n      tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n    }\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const attribSize = attribute.size;\n      if (attribute.stride === void 0) {\n        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {\n          attribute.stride = 0;\n        } else {\n          attribute.stride = tempStride[attribute.buffer];\n        }\n      }\n      if (attribute.start === void 0) {\n        attribute.start = tempStart[attribute.buffer];\n        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n      }\n    }\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n      if (incRefCount) {\n        buffer._glBuffers[CONTEXT_UID].refCount++;\n      }\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program.id] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);\n    return vao;\n  }\n  disposeGeometry(geometry, contextLost) {\n    if (!this.managedGeometries[geometry.id]) {\n      return;\n    }\n    delete this.managedGeometries[geometry.id];\n    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    const gl = this.gl;\n    const buffers = geometry.buffers;\n    const bufferSystem = this.renderer?.buffer;\n    geometry.disposeRunner.remove(this);\n    if (!vaos) {\n      return;\n    }\n    if (bufferSystem) {\n      for (let i = 0; i < buffers.length; i++) {\n        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n        if (buf) {\n          buf.refCount--;\n          if (buf.refCount === 0 && !contextLost) {\n            bufferSystem.dispose(buffers[i], contextLost);\n          }\n        }\n      }\n    }\n    if (!contextLost) {\n      for (const vaoId in vaos) {\n        if (vaoId[0] === \"g\") {\n          const vao = vaos[vaoId];\n          if (this._activeVao === vao) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vao);\n        }\n      }\n    }\n    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedGeometries);\n    for (let i = 0; i < all.length; i++) {\n      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n    }\n  }\n  activateVao(geometry, program) {\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = buffers[attribute.buffer];\n      const glBuffer = buffer._glBuffers[CONTEXT_UID];\n      if (program.attributeData[j]) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = program.attributeData[j].location;\n        gl.enableVertexAttribArray(location);\n        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            gl.vertexAttribDivisor(location, attribute.divisor);\n          } else {\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n          }\n        }\n      }\n    }\n  }\n  draw(type, size, start, instanceCount) {\n    const {\n      gl\n    } = this;\n    const geometry = this._activeGeometry;\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {\n        if (geometry.instanced) {\n          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n        } else {\n          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n        }\n      } else {\n        console.warn(\"unsupported index buffer type: uint32\");\n      }\n    } else if (geometry.instanced) {\n      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n    } else {\n      gl.drawArrays(type, start, size || geometry.getSize());\n    }\n    return this;\n  }\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nGeometrySystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"geometry\"\n};\nextensions.add(GeometrySystem);\nexport { GeometrySystem };","map":{"version":3,"names":["byteSizeMap","GeometrySystem","constructor","renderer","_activeGeometry","_activeVao","hasVao","hasInstance","canUseUInt32ElementIndex","managedGeometries","contextChange","disposeAll","gl","context","CONTEXT_UID","webGLVersion","nativeVaoExtension","extensions","vertexArrayObject","settings","PREFER_ENV","ENV","WEBGL_LEGACY","createVertexArray","createVertexArrayOES","bindVertexArray","vao","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","instanceExt","getExtension","vertexAttribDivisor","a","b","vertexAttribDivisorANGLE","drawElementsInstanced","c","d","e","drawElementsInstancedANGLE","drawArraysInstanced","drawArraysInstancedANGLE","uint32ElementIndex","bind","geometry","shader","vaos","glVertexArrayObjects","incRefCount","id","disposeRunner","add","program","initGeometryVao","activateVao","updateBuffers","reset","unbind","bufferSystem","buffer","i","buffers","length","update","checkCompatibility","geometryAttributes","attributes","shaderAttributes","attributeData","j","Error","getSignature","attribs","strings","push","location","join","arguments","undefined","glPrograms","generateProgram","signature","vaoObjectHash","tempStride","tempStart","size","console","warn","type","attribute","attribSize","stride","start","_glBuffers","refCount","BUFFER_TYPE","ARRAY_BUFFER","disposeGeometry","contextLost","remove","buf","dispose","vaoId","all","Object","keys","indexBuffer","lastBuffer","glBuffer","enableVertexAttribArray","vertexAttribPointer","FLOAT","normalized","instance","divisor","draw","instanceCount","byteSize","data","BYTES_PER_ELEMENT","glType","UNSIGNED_SHORT","UNSIGNED_INT","instanced","drawElements","getSize","drawArrays","destroy","extension","ExtensionType","RendererSystem","name"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\geometry\\GeometrySystem.ts"],"sourcesContent":["import { BUFFER_TYPE, ENV } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\n\nimport type { DRAW_MODES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Dict } from '@pixi/utils';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { Program } from '../shader/Program';\nimport type { Shader } from '../shader/Shader';\nimport type { ISystem } from '../system/ISystem';\nimport type { Geometry } from './Geometry';\nimport type { GLBuffer } from './GLBuffer';\n\nconst byteSizeMap: {[key: number]: number} = { 5126: 4, 5123: 2, 5121: 1 };\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof PIXI\n */\nexport class GeometrySystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'geometry',\n    };\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    /**\n     * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`.\n     * @readonly\n     */\n    public canUseUInt32ElementIndex: boolean;\n\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n    protected _boundBuffer: GLBuffer;\n\n    /** Cache for all geometries by id, used in case renderer gets destroyed or for profiling. */\n    readonly managedGeometries: {[key: number]: Geometry};\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n        this.canUseUInt32ElementIndex = false;\n        this.managedGeometries = {};\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        const gl = this.gl = this.renderer.gl;\n        const context = this.renderer.context;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // webgl2\n        if (context.webGLVersion !== 2)\n        {\n            // webgl 1!\n            let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n\n            if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n            {\n                nativeVaoExtension = null;\n            }\n\n            if (nativeVaoExtension)\n            {\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    nativeVaoExtension.createVertexArrayOES();\n\n                gl.bindVertexArray = (vao): void =>\n                    nativeVaoExtension.bindVertexArrayOES(vao);\n\n                gl.deleteVertexArray = (vao): void =>\n                    nativeVaoExtension.deleteVertexArrayOES(vao);\n            }\n            else\n            {\n                this.hasVao = false;\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    null;\n\n                gl.bindVertexArray = (): void =>\n                    null;\n\n                gl.deleteVertexArray = (): void =>\n                    null;\n            }\n        }\n\n        if (context.webGLVersion !== 2)\n        {\n            const instanceExt = gl.getExtension('ANGLE_instanced_arrays');\n\n            if (instanceExt)\n            {\n                gl.vertexAttribDivisor = (a, b): void =>\n                    instanceExt.vertexAttribDivisorANGLE(a, b);\n\n                gl.drawElementsInstanced = (a, b, c, d, e): void =>\n                    instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n\n                gl.drawArraysInstanced = (a, b, c, d): void =>\n                    instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n            }\n            else\n            {\n                this.hasInstance = false;\n            }\n        }\n\n        this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param shader - Instance of shader to use vao for.\n     */\n    bind(geometry?: Geometry, shader?: Shader): void\n    {\n        shader = shader || this.renderer.shader.shader;\n\n        const { gl } = this;\n\n        // not sure the best way to address this..\n        // currently different shaders require different VAOs for the same geometry\n        // Still mulling over the best way to solve this one..\n        // will likely need to modify the shader attribute locations at run time!\n        let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        let incRefCount = false;\n\n        if (!vaos)\n        {\n            this.managedGeometries[geometry.id] = geometry;\n            geometry.disposeRunner.add(this);\n            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n            incRefCount = true;\n        }\n\n        const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n\n        this._activeGeometry = geometry;\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            if (this.hasVao)\n            {\n                gl.bindVertexArray(vao);\n            }\n            else\n            {\n                this.activateVao(geometry, shader.program);\n            }\n        }\n\n        // TODO - optimise later!\n        // don't need to loop through if nothing changed!\n        // maybe look to add an 'autoupdate' to geometry?\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this.renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.update(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: Program): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: Program): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        const strings = ['g', geometry.id];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param shader - Instance of the shader.\n     * @param incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, shader: Shader, incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const program = shader.program;\n\n        if (!program.glPrograms[CONTEXT_UID])\n        {\n            this.renderer.shader.generateProgram(shader);\n        }\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program.id] = vao;\n\n            return vao;\n        }\n\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n        const tempStride: Dict<number> = {};\n        const tempStart: Dict<number> = {};\n\n        for (const j in buffers)\n        {\n            tempStride[j] = 0;\n            tempStart[j] = 0;\n        }\n\n        for (const j in attributes)\n        {\n            if (!attributes[j].size && program.attributeData[j])\n            {\n                attributes[j].size = program.attributeData[j].size;\n            }\n            else if (!attributes[j].size)\n            {\n                console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);  // eslint-disable-line\n            }\n\n            tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n        }\n\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const attribSize = attribute.size;\n\n            if (attribute.stride === undefined)\n            {\n                if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type])\n                {\n                    attribute.stride = 0;\n                }\n                else\n                {\n                    attribute.stride = tempStride[attribute.buffer];\n                }\n            }\n\n            if (attribute.start === undefined)\n            {\n                attribute.start = tempStart[attribute.buffer];\n\n                tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n            }\n        }\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n\n            if (incRefCount)\n            {\n                buffer._glBuffers[CONTEXT_UID].refCount++;\n            }\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program.id] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n        bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    disposeGeometry(geometry: Geometry, contextLost?: boolean): void\n    {\n        if (!this.managedGeometries[geometry.id])\n        {\n            return;\n        }\n\n        delete this.managedGeometries[geometry.id];\n\n        const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        const gl = this.gl;\n        const buffers = geometry.buffers;\n        const bufferSystem = this.renderer?.buffer;\n\n        geometry.disposeRunner.remove(this);\n\n        if (!vaos)\n        {\n            return;\n        }\n\n        // bufferSystem may have already been destroyed..\n        // if this is the case, there is no need to destroy the geometry buffers...\n        // they already have been!\n        if (bufferSystem)\n        {\n            for (let i = 0; i < buffers.length; i++)\n            {\n                const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n\n                // my be null as context may have changed right before the dispose is called\n                if (buf)\n                {\n                    buf.refCount--;\n                    if (buf.refCount === 0 && !contextLost)\n                    {\n                        bufferSystem.dispose(buffers[i], contextLost);\n                    }\n                }\n            }\n        }\n\n        if (!contextLost)\n        {\n            for (const vaoId in vaos)\n            {\n                // delete only signatures, everything else are copies\n                if (vaoId[0] === 'g')\n                {\n                    const vao = vaos[vaoId];\n\n                    if (this._activeVao === vao)\n                    {\n                        this.unbind();\n                    }\n                    gl.deleteVertexArray(vao);\n                }\n            }\n        }\n\n        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedGeometries);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: Program): void\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = buffers[attribute.buffer];\n            const glBuffer = buffer._glBuffers[CONTEXT_UID];\n\n            if (program.attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = program.attributeData[j].location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                gl.vertexAttribPointer(location,\n                    attribute.size,\n                    attribute.type || gl.FLOAT,\n                    attribute.normalized,\n                    attribute.stride,\n                    attribute.start);\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, attribute.divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param type - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    draw(type: DRAW_MODES, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this;\n        const geometry = this._activeGeometry;\n\n        // TODO.. this should not change so maybe cache the function?\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (byteSize === 2 || (byteSize === 4 && this.canUseUInt32ElementIndex))\n            {\n                if (geometry.instanced)\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n                    /* eslint-enable max-len */\n                }\n                else\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                    /* eslint-enable max-len */\n                }\n            }\n            else\n            {\n                console.warn('unsupported index buffer type: uint32');\n            }\n        }\n        else if (geometry.instanced)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n        }\n        else\n        {\n            gl.drawArrays(type, start, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(GeometrySystem);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}