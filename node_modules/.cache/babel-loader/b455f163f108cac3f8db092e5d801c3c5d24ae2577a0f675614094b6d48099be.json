{"ast":null,"code":"import { BaseTexture, ExtensionType, extensions } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { BasePrepare } from './BasePrepare.mjs';\nfunction uploadBaseTextures(renderer, item) {\n  if (item instanceof BaseTexture) {\n    if (!item._glTextures[renderer.CONTEXT_UID]) {\n      renderer.texture.bind(item);\n    }\n    return true;\n  }\n  return false;\n}\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof Graphics)) {\n    return false;\n  }\n  const {\n    geometry\n  } = item;\n  item.finishPoly();\n  geometry.updateBatches();\n  const {\n    batches\n  } = geometry;\n  for (let i = 0; i < batches.length; i++) {\n    const {\n      texture\n    } = batches[i].style;\n    if (texture) {\n      uploadBaseTextures(renderer, texture.baseTexture);\n    }\n  }\n  if (!geometry.batchable) {\n    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));\n  }\n  return true;\n}\nfunction findGraphics(item, queue) {\n  if (item instanceof Graphics) {\n    queue.push(item);\n    return true;\n  }\n  return false;\n}\nclass Prepare extends BasePrepare {\n  constructor(renderer) {\n    super(renderer);\n    this.uploadHookHelper = this.renderer;\n    this.registerFindHook(findGraphics);\n    this.registerUploadHook(uploadBaseTextures);\n    this.registerUploadHook(uploadGraphics);\n  }\n}\nPrepare.extension = {\n  name: \"prepare\",\n  type: ExtensionType.RendererSystem\n};\nextensions.add(Prepare);\nexport { Prepare };","map":{"version":3,"names":["uploadBaseTextures","renderer","item","BaseTexture","_glTextures","CONTEXT_UID","texture","bind","uploadGraphics","Graphics","geometry","finishPoly","updateBatches","batches","i","length","style","baseTexture","batchable","_resolveDirectShader","findGraphics","queue","push","Prepare","BasePrepare","constructor","uploadHookHelper","registerFindHook","registerUploadHook","extension","name","type","ExtensionType","RendererSystem","extensions","add"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\prepare\\src\\Prepare.ts"],"sourcesContent":["import { BaseTexture, extensions, ExtensionType } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { BasePrepare } from './BasePrepare';\n\nimport type { ExtensionMetadata, IRenderer, ISystem, Renderer } from '@pixi/core';\nimport type { IDisplayObjectExtended } from './BasePrepare';\n\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction uploadBaseTextures(renderer: IRenderer | BasePrepare, item: IDisplayObjectExtended | BaseTexture): boolean\n{\n    if (item instanceof BaseTexture)\n    {\n        // if the texture already has a GL texture, then the texture has been prepared or rendered\n        // before now. If the texture changed, then the changer should be calling texture.update() which\n        // reuploads the texture without need for preparing it again\n        if (!item._glTextures[(renderer as Renderer).CONTEXT_UID])\n        {\n            (renderer as Renderer).texture.bind(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction uploadGraphics(renderer: IRenderer | BasePrepare, item: IDisplayObjectExtended): boolean\n{\n    if (!(item instanceof Graphics))\n    {\n        return false;\n    }\n\n    const { geometry } = item;\n\n    // update dirty graphics to get batches\n    item.finishPoly();\n    geometry.updateBatches();\n\n    const { batches } = geometry;\n\n    // upload all textures found in styles\n    for (let i = 0; i < batches.length; i++)\n    {\n        const { texture } = batches[i].style;\n\n        if (texture)\n        {\n            uploadBaseTextures(renderer, texture.baseTexture);\n        }\n    }\n\n    // if its not batchable - update vao for particular shader\n    if (!geometry.batchable)\n    {\n        (renderer as Renderer).geometry.bind(geometry, (item as any)._resolveDirectShader((renderer as Renderer)));\n    }\n\n    return true;\n}\n\n/**\n * Built-in hook to find graphics.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item: IDisplayObjectExtended, queue: Array<any>): boolean\n{\n    if (item instanceof Graphics)\n    {\n        queue.push(item);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.prepare` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (prepare will be auto-added to renderer)\n * const app = new Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // Create a display object\n * const rect = new Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n * @memberof PIXI\n */\nexport class Prepare extends BasePrepare implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'prepare',\n        type: ExtensionType.RendererSystem,\n    };\n\n    /**\n     * @param {PIXI.Renderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.uploadHookHelper = this.renderer;\n\n        // Add textures and graphics to upload\n        this.registerFindHook(findGraphics);\n        this.registerUploadHook(uploadBaseTextures);\n        this.registerUploadHook(uploadGraphics);\n    }\n}\n\nextensions.add(Prepare);\n"],"mappings":";;;AAcA,SAAAA,mBAA4BC,QAAA,EAAmCC,IAC/D;EACI,IAAIA,IAAA,YAAgBC,WACpB;IAII,IAAI,CAACD,IAAA,CAAKE,WAAa,CAAAH,QAAA,CAAsBI,WAC7C;MACKJ,QAAA,CAAsBK,OAAQ,CAAAC,IAAA,CAAKL,IAAI;IAAA;IAGrC;EAAA;EAGJ;AACX;AASA,SAAAM,eAAwBP,QAAA,EAAmCC,IAC3D;EACQ,MAAAA,IAAA,YAAkBO,QACtB;IACW;EAAA;EAGX,MAAM;IAAEC;EAAa,IAAAR,IAAA;EAGrBA,IAAA,CAAKS,UAAW;EAChBD,QAAA,CAASE,aAAc;EAEvB,MAAM;IAAEC;EAAY,IAAAH,QAAA;EAGpB,SAASI,CAAI,MAAGA,CAAI,GAAAD,OAAA,CAAQE,MAAA,EAAQD,CACpC;IACU;MAAER;IAAY,IAAAO,OAAA,CAAQC,CAAG,EAAAE,KAAA;IAE/B,IAAIV,OACJ;MACuBN,kBAAA,CAAAC,QAAA,EAAUK,OAAA,CAAQW,WAAW;IAAA;EACpD;EAIA,KAACP,QAAA,CAASQ,SACd;IACKjB,QAAA,CAAsBS,QAAS,CAAAH,IAAA,CAAKG,QAAA,EAAWR,IAAa,CAAAiB,oBAAA,CAAsBlB,QAAqB,CAAC;EAAA;EAGtG;AACX;AASA,SAAAmB,aAAsBlB,IAAA,EAA8BmB,KACpD;EACI,IAAInB,IAAA,YAAgBO,QACpB;IACIY,KAAA,CAAMC,IAAA,CAAKpB,IAAI;IAER;EAAA;EAGJ;AACX;AA+BO,MAAMqB,OAAA,SAAgBC,WAC7B;EAUIC,YAAYxB,QACZ;IACI,MAAMA,QAAQ;IAEd,KAAKyB,gBAAA,GAAmB,IAAK,CAAAzB,QAAA;IAG7B,KAAK0B,gBAAA,CAAiBP,YAAY;IAClC,KAAKQ,kBAAA,CAAmB5B,kBAAkB;IAC1C,KAAK4B,kBAAA,CAAmBpB,cAAc;EAAA;AAE9C;AAtBae,OAAA,CAGFM,SAA+B;EAClCC,IAAM;EACNC,IAAA,EAAMC,aAAc,CAAAC;AACxB;AAkBJC,UAAA,CAAWC,GAAA,CAAIZ,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}