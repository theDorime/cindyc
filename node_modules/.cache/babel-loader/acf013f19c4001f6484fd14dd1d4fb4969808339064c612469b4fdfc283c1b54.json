{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/core';\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, extension => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(_ref => {\n    let [key] = _ref;\n    return !!ref[key];\n  }).forEach(_ref2 => {\n    let [key, type] = _ref2;\n    return extensions.add(Object.assign(ref[key], {\n      extension: ref[key].extension ?? type\n    }));\n  });\n}, extension => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter(key => !!ref[key]).forEach(key => extensions.remove(ref[key]));\n});","map":{"version":3,"names":["assetKeyMap","loader","ExtensionType","LoadParser","resolver","ResolveParser","cache","CacheParser","detection","DetectionParser","extensions","handle","Asset","extension","ref","Object","entries","filter","_ref","key","forEach","_ref2","type","add","assign","keys","remove"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\assets\\src\\AssetExtension.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/core';\n\nimport type { CacheParser } from './cache';\nimport type { FormatDetectionParser } from './detections';\nimport type { LoaderParser } from './loader';\nimport type { ResolveURLParser } from './resolver';\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n/**\n * This developer convenience object allows developers to group\n * together the various asset parsers into a single object.\n * @memberof PIXI\n */\ninterface AssetExtension<ASSET = any, META_DATA = any>\n{\n    extension: ExtensionType.Asset,\n    loader?: Partial<LoaderParser<ASSET, META_DATA>>,\n    resolver?: Partial<ResolveURLParser>,\n    cache?: Partial<CacheParser<ASSET>>,\n    detection?: Partial<FormatDetectionParser>,\n}\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n\nexport type { AssetExtension };\n"],"mappings":";AAOA,MAAMA,WAAc;EAChBC,MAAA,EAAQC,aAAc,CAAAC,UAAA;EACtBC,QAAA,EAAUF,aAAc,CAAAG,aAAA;EACxBC,KAAA,EAAOJ,aAAc,CAAAK,WAAA;EACrBC,SAAA,EAAWN,aAAc,CAAAO;AAC7B;AAoBAC,UAAA,CAAWC,MAAO,CAAAT,aAAA,CAAcU,KAAO,EAACC,SACxC;EACI,MAAMC,GAAA,GAAMD,SAAU,CAAAC,GAAA;EAEtBC,MAAA,CAAOC,OAAQ,CAAAhB,WAAW,CACrB,CAAAiB,MAAA,CAAOC,IAAA;IAAA,IAAC,CAACC,GAAS,IAAAD,IAAA;IAAA,QAAC,CAACJ,GAAA,CAAIK,GAAiB;EAAA,GACzCC,OAAA,CAAQC,KAAA;IAAA,IAAC,CAACF,GAAK,EAAAG,IAAA,IAAAD,KAAA;IAAA,OAAUX,UAAW,CAAAa,GAAA,CAAIR,MAAO,CAAAS,MAAA,CAC5CV,GAAA,CAAIK,GAGJ;MAAEN,SAAW,EAAAC,GAAA,CAAIK,GAAkB,EAAAN,SAAA,IAAaS;IAAK,CACzD,CAAC,CAAC;EAAA;AACV,GAAIT,SACJ;EACI,MAAMC,GAAA,GAAMD,SAAU,CAAAC,GAAA;EAEtBC,MAAA,CAAOU,IAAA,CAAKzB,WAAW,EAClBiB,MAAA,CAAQE,GAAA,IAAQ,CAAC,CAACL,GAAA,CAAIK,GAAiB,GACvCC,OAAA,CAASD,GAAA,IAAQT,UAAA,CAAWgB,MAAO,CAAAZ,GAAA,CAAIK,GAAA,CAAiB,CAAC;AAClE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}