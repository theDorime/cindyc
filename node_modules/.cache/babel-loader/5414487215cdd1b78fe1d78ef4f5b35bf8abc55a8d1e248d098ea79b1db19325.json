{"ast":null,"code":"import { TYPES } from '@pixi/constants';\nclass Attribute {\n  constructor(buffer) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let normalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TYPES.FLOAT;\n    let stride = arguments.length > 4 ? arguments[4] : undefined;\n    let start = arguments.length > 5 ? arguments[5] : undefined;\n    let instance = arguments.length > 6 ? arguments[6] : undefined;\n    let divisor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;\n    this.buffer = buffer;\n    this.size = size;\n    this.normalized = normalized;\n    this.type = type;\n    this.stride = stride;\n    this.start = start;\n    this.instance = instance;\n    this.divisor = divisor;\n  }\n  destroy() {\n    this.buffer = null;\n  }\n  static from(buffer, size, normalized, type, stride) {\n    return new Attribute(buffer, size, normalized, type, stride);\n  }\n}\nexport { Attribute };","map":{"version":3,"names":["Attribute","constructor","buffer","size","arguments","length","undefined","normalized","type","TYPES","FLOAT","stride","start","instance","divisor","destroy","from"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\geometry\\Attribute.ts"],"sourcesContent":["import { TYPES } from '@pixi/constants';\n\n/* eslint-disable max-len */\n\n/**\n * Holds the information for a single attribute structure required to render geometry.\n *\n * This does not contain the actual data, but instead has a buffer id that maps to a {@link PIXI.Buffer}\n * This can include anything from positions, uvs, normals, colors etc.\n * @memberof PIXI\n */\nexport class Attribute\n{\n    public buffer: number;\n    public size: number;\n    public normalized: boolean;\n    public type: TYPES;\n    public stride: number;\n    public start: number;\n    public instance: boolean;\n    public divisor: number;\n\n    /**\n     * @param buffer - the id of the buffer that this attribute will look for\n     * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.\n     * @param normalized - should the data be normalized.\n     * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n     * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n     * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n     * @param [instance=false] - Whether the geometry is instanced.\n     * @param [divisor=1] - Divisor to use when doing instanced rendering\n     */\n    constructor(buffer: number, size = 0, normalized = false, type = TYPES.FLOAT, stride?: number, start?: number, instance?: boolean, divisor = 1)\n    {\n        this.buffer = buffer;\n        this.size = size;\n        this.normalized = normalized;\n        this.type = type;\n        this.stride = stride;\n        this.start = start;\n        this.instance = instance;\n        this.divisor = divisor;\n    }\n\n    /** Destroys the Attribute. */\n    destroy(): void\n    {\n        this.buffer = null;\n    }\n\n    /**\n     * Helper function that creates an Attribute based on the information provided\n     * @param buffer - the id of the buffer that this attribute will look for\n     * @param [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n     * @param [normalized=false] - should the data be normalized.\n     * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n     * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n     * @returns - A new {@link PIXI.Attribute} based on the information provided\n     */\n    static from(buffer: number, size?: number, normalized?: boolean, type?: TYPES, stride?: number): Attribute\n    {\n        return new Attribute(buffer, size, normalized, type, stride);\n    }\n}\n"],"mappings":";AAWO,MAAMA,SACb;EAoBIC,WAAYA,CAAAC,MAAA,EACZ;IAAA,IAD4BC,IAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;IAAA,IAAGG,UAAa,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;IAAA,IAAOI,IAAO,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAAK,KAAA,CAAMC,KAAO;IAAA,IAAAC,MAAA,GAAAP,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAiBM,KAAgB,GAAAR,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAAO,QAAA,GAAAT,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAoBQ,OAAA,GAAAV,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAU,CAC7I;IACI,KAAKF,MAAS,GAAAA,MAAA;IACd,KAAKC,IAAO,GAAAA,IAAA;IACZ,KAAKI,UAAa,GAAAA,UAAA;IAClB,KAAKC,IAAO,GAAAA,IAAA;IACZ,KAAKG,MAAS,GAAAA,MAAA;IACd,KAAKC,KAAQ,GAAAA,KAAA;IACb,KAAKC,QAAW,GAAAA,QAAA;IAChB,KAAKC,OAAU,GAAAA,OAAA;EAAA;EAInBC,OACAA,CAAA;IACI,KAAKb,MAAS;EAAA;EAYlB,OAAOc,IAAKA,CAAAd,MAAA,EAAgBC,IAAe,EAAAI,UAAA,EAAsBC,IAAA,EAAcG,MAC/E;IACI,OAAO,IAAIX,SAAU,CAAAE,MAAA,EAAQC,IAAM,EAAAI,UAAA,EAAYC,IAAA,EAAMG,MAAM;EAAA;AAEnE"},"metadata":{},"sourceType":"module","externalDependencies":[]}