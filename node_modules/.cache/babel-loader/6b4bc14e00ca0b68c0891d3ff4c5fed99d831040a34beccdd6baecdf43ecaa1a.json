{"ast":null,"code":"import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nclass ImageBitmapResource extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    let baseSource;\n    let url;\n    if (typeof source === \"string\") {\n      baseSource = ImageBitmapResource.EMPTY;\n      url = source;\n    } else {\n      baseSource = source;\n      url = null;\n    }\n    super(baseSource);\n    this.url = url;\n    this.crossOrigin = options.crossOrigin ?? true;\n    this.alphaMode = typeof options.alphaMode === \"number\" ? options.alphaMode : null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise(async (resolve, reject) => {\n      if (this.url === null) {\n        resolve(this);\n        return;\n      }\n      try {\n        const response = await settings.ADAPTER.fetch(this.url, {\n          mode: this.crossOrigin ? \"cors\" : \"no-cors\"\n        });\n        if (this.destroyed) return;\n        const imageBlob = await response.blob();\n        if (this.destroyed) return;\n        const imageBitmap = await createImageBitmap(imageBlob, {\n          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n        });\n        if (this.destroyed) return;\n        this.source = imageBitmap;\n        this.update();\n        resolve(this);\n      } catch (e) {\n        if (this.destroyed) return;\n        reject(e);\n        this.onError.emit(e);\n      }\n    });\n    return this._load;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (!(this.source instanceof ImageBitmap)) {\n      this.load();\n      return false;\n    }\n    if (typeof this.alphaMode === \"number\") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    return super.upload(renderer, baseTexture, glTexture);\n  }\n  dispose() {\n    if (this.source instanceof ImageBitmap) {\n      this.source.close();\n    }\n    super.dispose();\n    this._load = null;\n  }\n  static test(source) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap !== \"undefined\" && (typeof source === \"string\" || source instanceof ImageBitmap);\n  }\n  static get EMPTY() {\n    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);\n    return ImageBitmapResource._EMPTY;\n  }\n}\nexport { ImageBitmapResource };","map":{"version":3,"names":["ImageBitmapResource","BaseImageResource","constructor","source","options","baseSource","url","EMPTY","crossOrigin","alphaMode","_load","autoLoad","load","Promise","resolve","reject","response","settings","ADAPTER","fetch","mode","destroyed","imageBlob","blob","imageBitmap","createImageBitmap","premultiplyAlpha","ALPHA_MODES","UNPACK","update","e","onError","emit","upload","renderer","baseTexture","glTexture","ImageBitmap","dispose","close","test","globalThis","_EMPTY","createCanvas"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\resources\\ImageBitmapResource.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { ICanvas } from '@pixi/settings';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\nexport interface IImageBitmapResourceOptions\n{\n    /** Start loading process automatically when constructed. */\n    autoLoad?: boolean;\n\n    /** Load image using cross origin. */\n    crossOrigin?: boolean;\n\n    /** Alpha mode used when creating the ImageBitmap. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * Resource type for ImageBitmap.\n * @memberof PIXI\n */\nexport class ImageBitmapResource extends BaseImageResource\n{\n    /** URL of the image source. */\n    url: string | null;\n\n    /**\n     * Load image using cross origin.\n     * @default false\n     */\n    crossOrigin: boolean;\n\n    /**\n     * Controls texture alphaMode field\n     * Copies from options\n     * Default is `null`, copies option from baseTexture\n     * @readonly\n     */\n    alphaMode: ALPHA_MODES | null;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /**\n     * @param source - ImageBitmap or URL to use\n     * @param options\n     * @param {boolean} [options.autoLoad=true] - Start loading process automatically when constructed.\n     * @param {boolean} [options.crossOrigin=true] - Load image using cross origin.\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=null] - Alpha mode used when creating the ImageBitmap.\n     */\n    constructor(source: ImageBitmap | string, options?: IImageBitmapResourceOptions)\n    {\n        options = options || {};\n\n        let baseSource;\n        let url;\n\n        if (typeof source === 'string')\n        {\n            baseSource = ImageBitmapResource.EMPTY;\n            url = source;\n        }\n        else\n        {\n            baseSource = source;\n            url = null;\n        }\n        // Using super() in if() can cause transpilation problems in some cases, so take it out of if().\n        // See https://github.com/pixijs/pixijs/pull/9093 for details.\n        super(baseSource);\n        this.url = url;\n\n        this.crossOrigin = options.crossOrigin ?? true;\n        this.alphaMode = typeof options.alphaMode === 'number' ? options.alphaMode : null;\n\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = new Promise(async (resolve, reject) =>\n        {\n            if (this.url === null)\n            {\n                resolve(this);\n\n                return;\n            }\n\n            try\n            {\n                const response = await settings.ADAPTER.fetch(this.url, {\n                    mode: this.crossOrigin ? 'cors' : 'no-cors'\n                });\n\n                if (this.destroyed) return;\n\n                const imageBlob = await response.blob();\n\n                if (this.destroyed) return;\n\n                const imageBitmap = await createImageBitmap(imageBlob, {\n                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK\n                        ? 'premultiply' : 'none',\n                });\n\n                if (this.destroyed) return;\n\n                this.source = imageBitmap;\n                this.update();\n\n                resolve(this);\n            }\n            catch (e)\n            {\n                if (this.destroyed) return;\n\n                reject(e);\n                this.onError.emit(e);\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Upload the image bitmap resource to GPU.\n     * @param renderer - Renderer to upload to\n     * @param baseTexture - BaseTexture for this resource\n     * @param glTexture - GLTexture to use\n     * @returns {boolean} true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        if (!(this.source instanceof ImageBitmap))\n        {\n            this.load();\n\n            return false;\n        }\n\n        if (typeof this.alphaMode === 'number')\n        {\n            baseTexture.alphaMode = this.alphaMode;\n        }\n\n        return super.upload(renderer, baseTexture, glTexture);\n    }\n\n    /** Destroys this resource. */\n    override dispose(): void\n    {\n        if (this.source instanceof ImageBitmap)\n        {\n            this.source.close();\n        }\n\n        super.dispose();\n\n        this._load = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap\n     */\n    static override test(source: unknown): source is string | ImageBitmap\n    {\n        return !!globalThis.createImageBitmap && typeof ImageBitmap !== 'undefined'\n            && (typeof source === 'string' || source instanceof ImageBitmap);\n    }\n\n    /**\n     * Cached empty placeholder canvas.\n     * @see EMPTY\n     */\n    private static _EMPTY: ICanvas;\n\n    /**\n     * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.\n     * Only for internal usage.\n     * @returns The cached placeholder canvas.\n     */\n    private static get EMPTY(): ICanvas\n    {\n        ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);\n\n        return ImageBitmapResource._EMPTY;\n    }\n}\n"],"mappings":";;;AAyBO,MAAMA,mBAAA,SAA4BC,iBACzC;EA+BIC,YAAYC,MAAA,EAA8BC,OAC1C;IACIA,OAAA,GAAUA,OAAA,IAAW,EAAC;IAElB,IAAAC,UAAA;IACA,IAAAC,GAAA;IAEA,WAAOH,MAAA,KAAW,QACtB;MACIE,UAAA,GAAaL,mBAAoB,CAAAO,KAAA;MAC3BD,GAAA,GAAAH,MAAA;IAAA,CAGV;MACiBE,UAAA,GAAAF,MAAA;MACPG,GAAA;IAAA;IAIV,MAAMD,UAAU;IAChB,KAAKC,GAAM,GAAAA,GAAA;IAEN,KAAAE,WAAA,GAAcJ,OAAA,CAAQI,WAAe;IAC1C,KAAKC,SAAA,GAAY,OAAOL,OAAA,CAAQK,SAAc,gBAAWL,OAAA,CAAQK,SAAY;IAE7E,KAAKC,KAAQ;IAET,IAAAN,OAAA,CAAQO,QAAA,KAAa,KACzB;MACI,KAAKC,IAAK;IAAA;EACd;EAGJA,IACAA,CAAA;IACI,IAAI,KAAKF,KACT;MACI,OAAO,IAAK,CAAAA,KAAA;IAAA;IAGhB,KAAKA,KAAQ,OAAIG,OAAQ,QAAOC,OAAA,EAASC,MACzC;MACQ,SAAKT,GAAA,KAAQ,IACjB;QACIQ,OAAA,CAAQ,IAAI;QAEZ;MAAA;MAIJ;QACI,MAAME,QAAA,GAAW,MAAMC,QAAA,CAASC,OAAQ,CAAAC,KAAA,CAAM,KAAKb,GAAK;UACpDc,IAAA,EAAM,IAAK,CAAAZ,WAAA,GAAc,MAAS;QAAA,CACrC;QAED,IAAI,IAAK,CAAAa,SAAA,EAAW;QAEd,MAAAC,SAAA,GAAY,MAAMN,QAAA,CAASO,IAAK;QAEtC,IAAI,IAAK,CAAAF,SAAA,EAAW;QAEd,MAAAG,WAAA,GAAc,MAAMC,iBAAA,CAAkBH,SAAW;UACnDI,gBAAA,EAAkB,KAAKjB,SAAc,aAAQ,KAAKA,SAAc,KAAAkB,WAAA,CAAYC,MAAA,GACtE,aAAgB;QAAA,CACzB;QAED,IAAI,IAAK,CAAAP,SAAA,EAAW;QAEpB,KAAKlB,MAAS,GAAAqB,WAAA;QACd,KAAKK,MAAO;QAEZf,OAAA,CAAQ,IAAI;MAAA,SAETgB,CAAP;QAEI,IAAI,IAAK,CAAAT,SAAA,EAAW;QAEpBN,MAAA,CAAOe,CAAC;QACH,KAAAC,OAAA,CAAQC,IAAA,CAAKF,CAAC;MAAA;IACvB,CACH;IAED,OAAO,IAAK,CAAApB,KAAA;EAAA;EAUhBuB,MAASA,CAAOC,QAAoB,EAAAC,WAAA,EAA0BC,SAC9D;IACQ,MAAO,KAAAjC,MAAA,YAAkBkC,WAC7B;MACI,KAAKzB,IAAK;MAEH;IAAA;IAGP,WAAO,IAAK,CAAAH,SAAA,KAAc,QAC9B;MACI0B,WAAA,CAAY1B,SAAA,GAAY,IAAK,CAAAA,SAAA;IAAA;IAGjC,OAAO,KAAM,CAAAwB,MAAA,CAAOC,QAAU,EAAAC,WAAA,EAAaC,SAAS;EAAA;EAIxDE,OACAA,CAAA;IACQ,SAAKnC,MAAA,YAAkBkC,WAC3B;MACI,KAAKlC,MAAA,CAAOoC,KAAM;IAAA;IAGtB,MAAMD,OAAQ;IAEd,KAAK5B,KAAQ;EAAA;EAQjB,OAAgB8B,KAAKrC,MACrB;IACW,QAAC,CAACsC,UAAA,CAAWhB,iBAAqB,WAAOY,WAAA,KAAgB,WACxD,YAAOlC,MAAW,iBAAYA,MAAkB,YAAAkC,WAAA;EAAA;EAc5D,WAAmB9B,KACnBA,CAAA;IACIP,mBAAA,CAAoB0C,MAAA,GAAS1C,mBAAoB,CAAA0C,MAAA,IAAUzB,QAAA,CAASC,OAAQ,CAAAyB,YAAA,CAAa,GAAG,CAAC;IAE7F,OAAO3C,mBAAoB,CAAA0C,MAAA;EAAA;AAEnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}