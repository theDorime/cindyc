{"ast":null,"code":"import { ObjectRenderer, Matrix, TYPES, Shader, State, utils, Color, ExtensionType, extensions } from '@pixi/core';\nimport { ParticleBuffer } from './ParticleBuffer.mjs';\nimport fragment from './particles.mjs';\nimport vertex from './particles2.mjs';\nclass ParticleRenderer extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    this.shader = null;\n    this.properties = null;\n    this.tempMatrix = new Matrix();\n    this.properties = [{\n      attributeName: \"aVertexPosition\",\n      size: 2,\n      uploadFunction: this.uploadVertices,\n      offset: 0\n    }, {\n      attributeName: \"aPositionCoord\",\n      size: 2,\n      uploadFunction: this.uploadPosition,\n      offset: 0\n    }, {\n      attributeName: \"aRotation\",\n      size: 1,\n      uploadFunction: this.uploadRotation,\n      offset: 0\n    }, {\n      attributeName: \"aTextureCoord\",\n      size: 2,\n      uploadFunction: this.uploadUvs,\n      offset: 0\n    }, {\n      attributeName: \"aColor\",\n      size: 1,\n      type: TYPES.UNSIGNED_BYTE,\n      uploadFunction: this.uploadTint,\n      offset: 0\n    }];\n    this.shader = Shader.from(vertex, fragment, {});\n    this.state = State.for2d();\n  }\n  render(container) {\n    const children = container.children;\n    const maxSize = container._maxSize;\n    const batchSize = container._batchSize;\n    const renderer = this.renderer;\n    let totalChildren = children.length;\n    if (totalChildren === 0) {\n      return;\n    } else if (totalChildren > maxSize && !container.autoResize) {\n      totalChildren = maxSize;\n    }\n    let buffers = container._buffers;\n    if (!buffers) {\n      buffers = container._buffers = this.generateBuffers(container);\n    }\n    const baseTexture = children[0]._texture.baseTexture;\n    const premultiplied = baseTexture.alphaMode > 0;\n    this.state.blendMode = utils.correctBlendMode(container.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    const gl = renderer.gl;\n    const m = container.worldTransform.copyTo(this.tempMatrix);\n    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n    this.shader.uniforms.translationMatrix = m.toArray(true);\n    this.shader.uniforms.uColor = Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);\n    this.shader.uniforms.uSampler = baseTexture;\n    this.renderer.shader.bind(this.shader);\n    let updateStatic = false;\n    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n      let amount = totalChildren - i;\n      if (amount > batchSize) {\n        amount = batchSize;\n      }\n      if (j >= buffers.length) {\n        buffers.push(this._generateOneMoreBuffer(container));\n      }\n      const buffer = buffers[j];\n      buffer.uploadDynamic(children, i, amount);\n      const bid = container._bufferUpdateIDs[j] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid;\n      if (updateStatic) {\n        buffer._updateID = container._updateID;\n        buffer.uploadStatic(children, i, amount);\n      }\n      renderer.geometry.bind(buffer.geometry);\n      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n    }\n  }\n  generateBuffers(container) {\n    const buffers = [];\n    const size = container._maxSize;\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    for (let i = 0; i < size; i += batchSize) {\n      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n    }\n    return buffers;\n  }\n  _generateOneMoreBuffer(container) {\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n  }\n  uploadVertices(children, startIndex, amount, array, stride, offset) {\n    let w0 = 0;\n    let w1 = 0;\n    let h0 = 0;\n    let h1 = 0;\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const texture = sprite._texture;\n      const sx = sprite.scale.x;\n      const sy = sprite.scale.y;\n      const trim = texture.trim;\n      const orig = texture.orig;\n      if (trim) {\n        w1 = trim.x - sprite.anchor.x * orig.width;\n        w0 = w1 + trim.width;\n        h1 = trim.y - sprite.anchor.y * orig.height;\n        h0 = h1 + trim.height;\n      } else {\n        w0 = orig.width * (1 - sprite.anchor.x);\n        w1 = orig.width * -sprite.anchor.x;\n        h0 = orig.height * (1 - sprite.anchor.y);\n        h1 = orig.height * -sprite.anchor.y;\n      }\n      array[offset] = w1 * sx;\n      array[offset + 1] = h1 * sy;\n      array[offset + stride] = w0 * sx;\n      array[offset + stride + 1] = h1 * sy;\n      array[offset + stride * 2] = w0 * sx;\n      array[offset + stride * 2 + 1] = h0 * sy;\n      array[offset + stride * 3] = w1 * sx;\n      array[offset + stride * 3 + 1] = h0 * sy;\n      offset += stride * 4;\n    }\n  }\n  uploadPosition(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spritePosition = children[startIndex + i].position;\n      array[offset] = spritePosition.x;\n      array[offset + 1] = spritePosition.y;\n      array[offset + stride] = spritePosition.x;\n      array[offset + stride + 1] = spritePosition.y;\n      array[offset + stride * 2] = spritePosition.x;\n      array[offset + stride * 2 + 1] = spritePosition.y;\n      array[offset + stride * 3] = spritePosition.x;\n      array[offset + stride * 3 + 1] = spritePosition.y;\n      offset += stride * 4;\n    }\n  }\n  uploadRotation(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spriteRotation = children[startIndex + i].rotation;\n      array[offset] = spriteRotation;\n      array[offset + stride] = spriteRotation;\n      array[offset + stride * 2] = spriteRotation;\n      array[offset + stride * 3] = spriteRotation;\n      offset += stride * 4;\n    }\n  }\n  uploadUvs(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const textureUvs = children[startIndex + i]._texture._uvs;\n      if (textureUvs) {\n        array[offset] = textureUvs.x0;\n        array[offset + 1] = textureUvs.y0;\n        array[offset + stride] = textureUvs.x1;\n        array[offset + stride + 1] = textureUvs.y1;\n        array[offset + stride * 2] = textureUvs.x2;\n        array[offset + stride * 2 + 1] = textureUvs.y2;\n        array[offset + stride * 3] = textureUvs.x3;\n        array[offset + stride * 3 + 1] = textureUvs.y3;\n        offset += stride * 4;\n      } else {\n        array[offset] = 0;\n        array[offset + 1] = 0;\n        array[offset + stride] = 0;\n        array[offset + stride + 1] = 0;\n        array[offset + stride * 2] = 0;\n        array[offset + stride * 2 + 1] = 0;\n        array[offset + stride * 3] = 0;\n        array[offset + stride * 3 + 1] = 0;\n        offset += stride * 4;\n      }\n    }\n  }\n  uploadTint(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const result = Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);\n      array[offset] = result;\n      array[offset + stride] = result;\n      array[offset + stride * 2] = result;\n      array[offset + stride * 3] = result;\n      offset += stride * 4;\n    }\n  }\n  destroy() {\n    super.destroy();\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n    this.tempMatrix = null;\n  }\n}\nParticleRenderer.extension = {\n  name: \"particle\",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(ParticleRenderer);\nexport { ParticleRenderer };","map":{"version":3,"names":["ParticleRenderer","ObjectRenderer","constructor","renderer","shader","properties","tempMatrix","Matrix","attributeName","size","uploadFunction","uploadVertices","offset","uploadPosition","uploadRotation","uploadUvs","type","TYPES","UNSIGNED_BYTE","uploadTint","Shader","from","vertex","fragment","state","State","for2d","render","container","children","maxSize","_maxSize","batchSize","_batchSize","totalChildren","length","autoResize","buffers","_buffers","generateBuffers","baseTexture","_texture","premultiplied","alphaMode","blendMode","utils","correctBlendMode","set","gl","m","worldTransform","copyTo","prepend","globalUniforms","uniforms","projectionMatrix","translationMatrix","toArray","uColor","Color","shared","setValue","tintRgb","premultiply","worldAlpha","uSampler","bind","updateStatic","i","j","amount","push","_generateOneMoreBuffer","buffer","uploadDynamic","bid","_bufferUpdateIDs","_updateID","uploadStatic","geometry","drawElements","TRIANGLES","UNSIGNED_SHORT","dynamicPropertyFlags","_properties","ParticleBuffer","startIndex","array","stride","w0","w1","h0","h1","sprite","texture","sx","scale","x","sy","y","trim","orig","anchor","width","height","spritePosition","position","spriteRotation","rotation","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","result","_tintRGB","toPremultiplied","alpha","destroy","extension","name","ExtensionType","RendererPlugin","extensions","add"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\particle-container\\src\\ParticleRenderer.ts"],"sourcesContent":["import { Color, extensions, ExtensionType, Matrix, ObjectRenderer, Shader, State, TYPES, utils } from '@pixi/core';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { Sprite } from '@pixi/sprite';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface IParticleRendererProperty\n{\n    attributeName: string;\n    size: number;\n    type?: TYPES;\n    uploadFunction: (...params: any[]) => any;\n    offset: number;\n}\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof PIXI\n */\nexport class ParticleRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'particle',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public shader: Shader;\n    public tempMatrix: Matrix;\n    public properties: IParticleRendererProperty[];\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        this.shader = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new Matrix();\n\n        this.properties = [\n            // verticesData\n            {\n                attributeName: 'aVertexPosition',\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attributeName: 'aPositionCoord',\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attributeName: 'aRotation',\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attributeName: 'aTextureCoord',\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // tintData\n            {\n                attributeName: 'aColor',\n                size: 1,\n                type: TYPES.UNSIGNED_BYTE,\n                uploadFunction: this.uploadTint,\n                offset: 0,\n            },\n        ];\n\n        this.shader = Shader.from(vertex, fragment, {});\n        this.state = State.for2d();\n    }\n\n    /**\n     * Renders the particle container object.\n     * @param container - The container to render using this ParticleRenderer.\n     */\n    public render(container: ParticleContainer): void\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize && !container.autoResize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._buffers;\n\n        if (!buffers)\n        {\n            buffers = container._buffers = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n        const premultiplied = baseTexture.alphaMode > 0;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.state.blendMode = utils.correctBlendMode(container.blendMode, premultiplied);\n        renderer.state.set(this.state);\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copyTo(this.tempMatrix);\n\n        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n\n        this.shader.uniforms.translationMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = Color.shared\n            .setValue(container.tintRgb)\n            .premultiply(container.worldAlpha, premultiplied)\n            .toArray(this.shader.uniforms.uColor);\n\n        this.shader.uniforms.uSampler = baseTexture;\n\n        this.renderer.shader.bind(this.shader);\n\n        let updateStatic = false;\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            if (j >= buffers.length)\n            {\n                buffers.push(this._generateOneMoreBuffer(container));\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            const bid = container._bufferUpdateIDs[j] || 0;\n\n            updateStatic = updateStatic || (buffer._updateID < bid);\n            // we only upload the static content when we have to!\n            if (updateStatic)\n            {\n                buffer._updateID = container._updateID;\n                buffer.uploadStatic(children, i, amount);\n            }\n\n            // bind the buffer\n            renderer.geometry.bind(buffer.geometry);\n            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The buffers\n     */\n    private generateBuffers(container: ParticleContainer): ParticleBuffer[]\n    {\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Creates one more particle buffer, because container has autoResize feature.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The generated buffer\n     */\n    private _generateOneMoreBuffer(container: ParticleContainer): ParticleBuffer\n    {\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n    }\n\n    /**\n     * Uploads the vertices.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their vertices uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadVertices(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the position.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their positions uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadPosition(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the rotation.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadRotation(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the UVs.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadUvs(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     * Uploads the tint.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadTint(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const result = Color.shared\n                .setValue(sprite._tintRGB)\n                .toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);\n\n            array[offset] = result;\n            array[offset + stride] = result;\n            array[offset + (stride * 2)] = result;\n            array[offset + (stride * 3)] = result;\n\n            offset += stride * 4;\n        }\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        if (this.shader)\n        {\n            this.shader.destroy();\n            this.shader = null;\n        }\n\n        this.tempMatrix = null;\n    }\n}\n\nextensions.add(ParticleRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}