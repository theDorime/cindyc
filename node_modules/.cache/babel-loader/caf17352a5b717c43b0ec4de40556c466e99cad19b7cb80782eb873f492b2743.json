{"ast":null,"code":"class BackgroundLoader {\n  constructor(loader) {\n    let verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  add(assetUrls) {\n    assetUrls.forEach(a => {\n      this._assetList.push(a);\n    });\n    if (this.verbose) console.log(\"[BackgroundLoader] assets: \", this._assetList);\n    if (this._isActive && !this._isLoading) {\n      this._next();\n    }\n  }\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      this._next();\n    }\n  }\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value) return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      this._next();\n    }\n  }\n}\nexport { BackgroundLoader };","map":{"version":3,"names":["BackgroundLoader","constructor","loader","verbose","arguments","length","undefined","_loader","_assetList","_isLoading","_maxConcurrent","add","assetUrls","forEach","a","push","console","log","_isActive","_next","toLoad","toLoadAmount","Math","min","i","pop","load","active","value"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\assets\\src\\BackgroundLoader.ts"],"sourcesContent":["import type { LoadAsset } from './loader';\nimport type { Loader } from './loader/Loader';\n\n/**\n * Quietly Loads assets in the background.\n * @memberof PIXI\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: LoadAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /** Should the loader log to the console. */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds an array of assets to load.\n     * @param assetUrls - assets to load\n     */\n    public add(assetUrls: LoadAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        // eslint-disable-next-line no-console\n        if (this.verbose)console.log('[BackgroundLoader] assets: ', this._assetList);\n\n        if (this._isActive && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            this._next();\n        }\n    }\n\n    /**\n     * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n     * @returns whether the class is active\n     */\n    get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            this._next();\n        }\n    }\n}\n"],"mappings":"AAOO,MAAMA,gBACb;EAqBIC,YAAYC,MAAgB,EAC5B;IAAA,IAD4BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAU,KACtC;IACI,KAAKG,OAAU,GAAAL,MAAA;IACf,KAAKM,UAAA,GAAa,EAAC;IACnB,KAAKC,UAAa;IAClB,KAAKC,cAAiB;IACtB,KAAKP,OAAU,GAAAA,OAAA;EAAA;EAOZQ,IAAIC,SACX;IACcA,SAAA,CAAAC,OAAA,CAASC,CACnB;MACS,KAAAN,UAAA,CAAWO,IAAA,CAAKD,CAAC;IAAA,CACzB;IAGD,IAAI,IAAK,CAAAX,OAAA,EAAgBa,OAAA,CAAAC,GAAA,CAAI,6BAA+B,OAAKT,UAAU;IAE3E,IAAI,IAAK,CAAAU,SAAA,IAAa,CAAC,KAAKT,UAC5B;MACI,KAAKU,KAAM;IAAA;EACf;EAQJ,MAAcA,KACdA,CAAA;IACI,IAAI,IAAK,CAAAX,UAAA,CAAWH,MAAU,SAAKa,SACnC;MACI,KAAKT,UAAa;MAElB,MAAMW,MAAA,GAAS,EAAC;MAEhB,MAAMC,YAAA,GAAeC,IAAK,CAAAC,GAAA,CAAI,KAAKf,UAAW,CAAAH,MAAA,EAAQ,KAAKK,cAAc;MAEzE,SAASc,CAAI,MAAGA,CAAI,GAAAH,YAAA,EAAcG,CAClC;QACIJ,MAAA,CAAOL,IAAK,MAAKP,UAAW,CAAAiB,GAAA,EAAK;MAAA;MAG/B,WAAKlB,OAAQ,CAAAmB,IAAA,CAAKN,MAAM;MAE9B,KAAKX,UAAa;MAElB,KAAKU,KAAM;IAAA;EACf;EAOJ,IAAIQ,MACJA,CAAA;IACI,OAAO,IAAK,CAAAT,SAAA;EAAA;EAGhB,IAAIS,OAAOC,KACX;IACI,IAAI,KAAKV,SAAc,KAAAU,KAAA,EAAO;IAE9B,KAAKV,SAAY,GAAAU,KAAA;IAEb,IAAAA,KAAA,IAAS,CAAC,KAAKnB,UACnB;MACI,KAAKU,KAAM;IAAA;EACf;AAER"},"metadata":{},"sourceType":"module","externalDependencies":[]}