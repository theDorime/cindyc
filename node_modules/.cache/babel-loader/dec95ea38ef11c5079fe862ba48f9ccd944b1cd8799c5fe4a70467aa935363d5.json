{"ast":null,"code":"import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nclass ImageResource extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    if (typeof source === \"string\") {\n      const imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n      imageElement.src = source;\n      source = imageElement;\n    }\n    super(source);\n    if (!source.complete && !!this._width && !!this._height) {\n      this._width = 0;\n      this._height = 0;\n    }\n    this.url = source.src;\n    this._process = null;\n    this.preserveBitmap = false;\n    this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n    this.alphaMode = typeof options.alphaMode === \"number\" ? options.alphaMode : null;\n    this.bitmap = null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load(createBitmap) {\n    if (this._load) {\n      return this._load;\n    }\n    if (createBitmap !== void 0) {\n      this.createBitmap = createBitmap;\n    }\n    this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        if (this.destroyed) {\n          return;\n        }\n        source.onload = null;\n        source.onerror = null;\n        this.resize(source.width, source.height);\n        this._load = null;\n        if (this.createBitmap) {\n          resolve(this.process());\n        } else {\n          resolve(this);\n        }\n      };\n      if (source.complete && source.src) {\n        completed();\n      } else {\n        source.onload = completed;\n        source.onerror = event => {\n          reject(event);\n          this.onError.emit(event);\n        };\n      }\n    });\n    return this._load;\n  }\n  process() {\n    const source = this.source;\n    if (this._process !== null) {\n      return this._process;\n    }\n    if (this.bitmap !== null || !globalThis.createImageBitmap) {\n      return Promise.resolve(this);\n    }\n    const createImageBitmap = globalThis.createImageBitmap;\n    const cors = !source.crossOrigin || source.crossOrigin === \"anonymous\";\n    this._process = fetch(source.src, {\n      mode: cors ? \"cors\" : \"no-cors\"\n    }).then(r => r.blob()).then(blob => createImageBitmap(blob, 0, 0, source.width, source.height, {\n      premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n    })).then(bitmap => {\n      if (this.destroyed) {\n        return Promise.reject();\n      }\n      this.bitmap = bitmap;\n      this.update();\n      this._process = null;\n      return Promise.resolve(this);\n    });\n    return this._process;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode === \"number\") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    if (!this.createBitmap) {\n      return super.upload(renderer, baseTexture, glTexture);\n    }\n    if (!this.bitmap) {\n      this.process();\n      if (!this.bitmap) {\n        return false;\n      }\n    }\n    super.upload(renderer, baseTexture, glTexture, this.bitmap);\n    if (!this.preserveBitmap) {\n      let flag = true;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        if (this.bitmap.close) {\n          this.bitmap.close();\n        }\n        this.bitmap = null;\n      }\n    }\n    return true;\n  }\n  dispose() {\n    this.source.onload = null;\n    this.source.onerror = null;\n    super.dispose();\n    if (this.bitmap) {\n      this.bitmap.close();\n      this.bitmap = null;\n    }\n    this._process = null;\n    this._load = null;\n  }\n  static test(source) {\n    return typeof HTMLImageElement !== \"undefined\" && (typeof source === \"string\" || source instanceof HTMLImageElement);\n  }\n}\nexport { ImageResource };","map":{"version":3,"names":["ImageResource","BaseImageResource","constructor","source","options","imageElement","Image","crossOrigin","crossorigin","src","complete","_width","_height","url","_process","preserveBitmap","createBitmap","settings","CREATE_IMAGE_BITMAP","globalThis","createImageBitmap","alphaMode","bitmap","_load","autoLoad","load","Promise","resolve","reject","completed","destroyed","onload","onerror","resize","width","height","process","event","onError","emit","cors","fetch","mode","then","r","blob","premultiplyAlpha","ALPHA_MODES","UNPACK","update","upload","renderer","baseTexture","glTexture","flag","glTextures","_glTextures","key","otherTex","dirtyId","close","dispose","test","HTMLImageElement"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\resources\\ImageResource.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\nexport interface IImageResourceOptions\n{\n    /** Start loading process automatically when constructed. */\n    autoLoad?: boolean;\n\n    /** Whether its required to create a bitmap before upload. */\n    createBitmap?: boolean;\n\n    /** Load image using cross origin. */\n    crossorigin?: boolean | string;\n\n    /** Premultiply image alpha in bitmap. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * Resource type for HTMLImageElement.\n * @memberof PIXI\n */\nexport class ImageResource extends BaseImageResource\n{\n    /** URL of the image source */\n    url: string;\n\n    /**\n     * If the image should be disposed after upload\n     * @default false\n     */\n    preserveBitmap: boolean;\n\n    /**\n     * If capable, convert the image using createImageBitmap API.\n     * @default PIXI.settings.CREATE_IMAGE_BITMAP\n     */\n    createBitmap: boolean;\n\n    /**\n     * Controls texture alphaMode field\n     * Copies from options\n     * Default is `null`, copies option from baseTexture\n     * @readonly\n     */\n    alphaMode: ALPHA_MODES;\n\n    /**\n     * The ImageBitmap element created for a {@link HTMLImageElement}.\n     * @default null\n     */\n    bitmap: ImageBitmap;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** When process is completed */\n    private _process: Promise<this>;\n\n    /**\n     * @param source - image source or URL\n     * @param options\n     * @param {boolean} [options.autoLoad=true] - start loading process\n     * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n     *        a bitmap before upload\n     * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n     */\n    constructor(source: HTMLImageElement | string, options?: IImageResourceOptions)\n    {\n        options = options || {};\n\n        if (typeof source === 'string')\n        {\n            const imageElement = new Image();\n\n            BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n\n            imageElement.src = source;\n            source = imageElement;\n        }\n\n        super(source);\n\n        // FireFox 68, and possibly other versions, seems like setting the HTMLImageElement#width and #height\n        // to non-zero values before its loading completes if images are in a cache.\n        // Because of this, need to set the `_width` and the `_height` to zero to avoid uploading incomplete images.\n        // Please refer to the issue #5968 (https://github.com/pixijs/pixijs/issues/5968).\n        if (!source.complete && !!this._width && !!this._height)\n        {\n            this._width = 0;\n            this._height = 0;\n        }\n\n        this.url = source.src;\n\n        this._process = null;\n\n        this.preserveBitmap = false;\n        this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n        this.alphaMode = typeof options.alphaMode === 'number' ? options.alphaMode : null;\n        this.bitmap = null;\n\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Returns a promise when image will be loaded and processed.\n     * @param createBitmap - whether process image into bitmap\n     */\n    load(createBitmap?: boolean): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        if (createBitmap !== undefined)\n        {\n            this.createBitmap = createBitmap;\n        }\n\n        this._load = new Promise((resolve, reject): void =>\n        {\n            const source = this.source as HTMLImageElement;\n\n            this.url = source.src;\n\n            const completed = (): void =>\n            {\n                if (this.destroyed)\n                {\n                    return;\n                }\n                source.onload = null;\n                source.onerror = null;\n\n                this.resize(source.width, source.height);\n                this._load = null;\n\n                if (this.createBitmap)\n                {\n                    resolve(this.process());\n                }\n                else\n                {\n                    resolve(this);\n                }\n            };\n\n            if (source.complete && source.src)\n            {\n                completed();\n            }\n            else\n            {\n                source.onload = completed;\n                source.onerror = (event): void =>\n                {\n                    // Avoids Promise freezing when resource broken\n                    reject(event);\n                    this.onError.emit(event);\n                };\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Called when we need to convert image into BitmapImage.\n     * Can be called multiple times, real promise is cached inside.\n     * @returns - Cached promise to fill that bitmap\n     */\n    process(): Promise<this>\n    {\n        const source = this.source as HTMLImageElement;\n\n        if (this._process !== null)\n        {\n            return this._process;\n        }\n        if (this.bitmap !== null || !globalThis.createImageBitmap)\n        {\n            return Promise.resolve(this);\n        }\n\n        const createImageBitmap = globalThis.createImageBitmap as any;\n        const cors = !source.crossOrigin || source.crossOrigin === 'anonymous';\n\n        this._process = fetch(source.src,\n            {\n                mode: cors ? 'cors' : 'no-cors'\n            })\n            .then((r) => r.blob())\n            .then((blob) => createImageBitmap(blob,\n                0, 0, source.width, source.height,\n                {\n                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK\n                        ? 'premultiply' : 'none',\n                }))\n            .then((bitmap: ImageBitmap) =>\n            {\n                if (this.destroyed)\n                {\n                    return Promise.reject();\n                }\n                this.bitmap = bitmap;\n                this.update();\n                this._process = null;\n\n                return Promise.resolve(this);\n            });\n\n        return this._process;\n    }\n\n    /**\n     * Upload the image resource to GPU.\n     * @param renderer - Renderer to upload to\n     * @param baseTexture - BaseTexture for this resource\n     * @param glTexture - GLTexture to use\n     * @returns {boolean} true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        if (typeof this.alphaMode === 'number')\n        {\n            // bitmap stores unpack premultiply flag, we dont have to notify texImage2D about it\n\n            baseTexture.alphaMode = this.alphaMode;\n        }\n\n        if (!this.createBitmap)\n        {\n            return super.upload(renderer, baseTexture, glTexture);\n        }\n        if (!this.bitmap)\n        {\n            // yeah, ignore the output\n            this.process();\n            if (!this.bitmap)\n            {\n                return false;\n            }\n        }\n\n        super.upload(renderer, baseTexture, glTexture, this.bitmap);\n\n        if (!this.preserveBitmap)\n        {\n            // checks if there are other renderers that possibly need this bitmap\n\n            let flag = true;\n\n            const glTextures = baseTexture._glTextures;\n\n            for (const key in glTextures)\n            {\n                const otherTex = glTextures[key];\n\n                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId)\n                {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag)\n            {\n                if (this.bitmap.close)\n                {\n                    this.bitmap.close();\n                }\n\n                this.bitmap = null;\n            }\n        }\n\n        return true;\n    }\n\n    /** Destroys this resource. */\n    override dispose(): void\n    {\n        (this.source as HTMLImageElement).onload = null;\n        (this.source as HTMLImageElement).onerror = null;\n\n        super.dispose();\n\n        if (this.bitmap)\n        {\n            this.bitmap.close();\n            this.bitmap = null;\n        }\n        this._process = null;\n        this._load = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n     */\n    static override test(source: unknown): source is string | HTMLImageElement\n    {\n        return typeof HTMLImageElement !== 'undefined' && (typeof source === 'string' || source instanceof HTMLImageElement);\n    }\n}\n"],"mappings":";;;AA2BO,MAAMA,aAAA,SAAsBC,iBACnC;EAgDIC,YAAYC,MAAA,EAAmCC,OAC/C;IACIA,OAAA,GAAUA,OAAA,IAAW,EAAC;IAElB,WAAOD,MAAA,KAAW,QACtB;MACU,MAAAE,YAAA,GAAe,IAAIC,KAAM;MAE/BL,iBAAA,CAAkBM,WAAY,CAAAF,YAAA,EAAcF,MAAQ,EAAAC,OAAA,CAAQI,WAAW;MAEvEH,YAAA,CAAaI,GAAM,GAAAN,MAAA;MACVA,MAAA,GAAAE,YAAA;IAAA;IAGb,MAAMF,MAAM;IAMR,KAACA,MAAO,CAAAO,QAAA,IAAY,CAAC,CAAC,KAAKC,MAAU,KAAC,CAAC,KAAKC,OAChD;MACI,KAAKD,MAAS;MACd,KAAKC,OAAU;IAAA;IAGnB,KAAKC,GAAA,GAAMV,MAAO,CAAAM,GAAA;IAElB,KAAKK,QAAW;IAEhB,KAAKC,cAAiB;IACtB,KAAKC,YAAA,GAAgB,CAAQZ,OAAA,CAAAY,YAAA,IAAgBC,QAAA,CAASC,mBAAwB,MAAC,CAACC,UAAW,CAAAC,iBAAA;IAC3F,KAAKC,SAAA,GAAY,OAAOjB,OAAA,CAAQiB,SAAc,gBAAWjB,OAAA,CAAQiB,SAAY;IAC7E,KAAKC,MAAS;IAEd,KAAKC,KAAQ;IAET,IAAAnB,OAAA,CAAQoB,QAAA,KAAa,KACzB;MACI,KAAKC,IAAK;IAAA;EACd;EAOJA,KAAKT,YACL;IACI,IAAI,KAAKO,KACT;MACI,OAAO,IAAK,CAAAA,KAAA;IAAA;IAGhB,IAAIP,YAAA,KAAiB,KACrB;MACI,KAAKA,YAAe,GAAAA,YAAA;IAAA;IAGxB,KAAKO,KAAQ,OAAIG,OAAQ,EAACC,OAAA,EAASC,MACnC;MACI,MAAMzB,MAAA,GAAS,IAAK,CAAAA,MAAA;MAEpB,KAAKU,GAAA,GAAMV,MAAO,CAAAM,GAAA;MAElB,MAAMoB,SAAA,GAAYA,CAAA,KAClB;QACI,IAAI,KAAKC,SACT;UACI;QAAA;QAEJ3B,MAAA,CAAO4B,MAAS;QAChB5B,MAAA,CAAO6B,OAAU;QAEjB,KAAKC,MAAO,CAAA9B,MAAA,CAAO+B,KAAO,EAAA/B,MAAA,CAAOgC,MAAM;QACvC,KAAKZ,KAAQ;QAEb,IAAI,KAAKP,YACT;UACYW,OAAA,MAAKS,OAAA,EAAS;QAAA,CAG1B;UACIT,OAAA,CAAQ,IAAI;QAAA;MAChB,CACJ;MAEI,IAAAxB,MAAA,CAAOO,QAAY,IAAAP,MAAA,CAAOM,GAC9B;QACcoB,SAAA;MAAA,CAGd;QACI1B,MAAA,CAAO4B,MAAS,GAAAF,SAAA;QACT1B,MAAA,CAAA6B,OAAA,GAAWK,KAClB;UAEIT,MAAA,CAAOS,KAAK;UACP,KAAAC,OAAA,CAAQC,IAAA,CAAKF,KAAK;QAAA,CAC3B;MAAA;IACJ,CACH;IAED,OAAO,IAAK,CAAAd,KAAA;EAAA;EAQhBa,OACAA,CAAA;IACI,MAAMjC,MAAA,GAAS,IAAK,CAAAA,MAAA;IAEhB,SAAKW,QAAA,KAAa,IACtB;MACI,OAAO,IAAK,CAAAA,QAAA;IAAA;IAEhB,IAAI,IAAK,CAAAQ,MAAA,KAAW,IAAQ,KAACH,UAAA,CAAWC,iBACxC;MACW,OAAAM,OAAA,CAAQC,OAAA,CAAQ,IAAI;IAAA;IAG/B,MAAMP,iBAAA,GAAoBD,UAAW,CAAAC,iBAAA;IACrC,MAAMoB,IAAO,IAACrC,MAAO,CAAAI,WAAA,IAAeJ,MAAA,CAAOI,WAAgB;IAEtD,KAAAO,QAAA,GAAW2B,KAAM,CAAAtC,MAAA,CAAOM,GACzB;MACIiC,IAAA,EAAMF,IAAA,GAAO,MAAS;IAAA,CACzB,CACA,CAAAG,IAAA,CAAMC,CAAM,IAAAA,CAAA,CAAEC,IAAA,EAAM,EACpBF,IAAA,CAAME,IAAA,IAASzB,iBAAA,CAAkByB,IAC9B,KAAG,GAAG1C,MAAO,CAAA+B,KAAA,EAAO/B,MAAA,CAAOgC,MAC3B;MACIW,gBAAA,EAAkB,KAAKzB,SAAc,aAAQ,KAAKA,SAAc,KAAA0B,WAAA,CAAYC,MAAA,GACtE,aAAgB;IAAA,CACzB,CAAC,CACL,CAAAL,IAAA,CAAMrB,MACP;MACI,IAAI,KAAKQ,SACT;QACI,OAAOJ,OAAA,CAAQE,MAAO;MAAA;MAE1B,KAAKN,MAAS,GAAAA,MAAA;MACd,KAAK2B,MAAO;MACZ,KAAKnC,QAAW;MAET,OAAAY,OAAA,CAAQC,OAAA,CAAQ,IAAI;IAAA,CAC9B;IAEL,OAAO,IAAK,CAAAb,QAAA;EAAA;EAUhBoC,MAASA,CAAOC,QAAoB,EAAAC,WAAA,EAA0BC,SAC9D;IACQ,WAAO,IAAK,CAAAhC,SAAA,KAAc,QAC9B;MAGI+B,WAAA,CAAY/B,SAAA,GAAY,IAAK,CAAAA,SAAA;IAAA;IAG7B,KAAC,KAAKL,YACV;MACI,OAAO,KAAM,CAAAkC,MAAA,CAAOC,QAAU,EAAAC,WAAA,EAAaC,SAAS;IAAA;IAEpD,KAAC,KAAK/B,MACV;MAEI,KAAKc,OAAQ;MACT,KAAC,KAAKd,MACV;QACW;MAAA;IACX;IAGJ,MAAM4B,MAAO,CAAAC,QAAA,EAAUC,WAAa,EAAAC,SAAA,EAAW,KAAK/B,MAAM;IAEtD,KAAC,KAAKP,cACV;MAGI,IAAIuC,IAAO;MAEX,MAAMC,UAAA,GAAaH,WAAY,CAAAI,WAAA;MAE/B,WAAWC,GAAA,IAAOF,UAClB;QACI,MAAMG,QAAA,GAAWH,UAAW,CAAAE,GAAA;QAE5B,IAAIC,QAAa,KAAAL,SAAA,IAAaK,QAAS,CAAAC,OAAA,KAAYP,WAAA,CAAYO,OAC/D;UACWL,IAAA;UACP;QAAA;MACJ;MAGJ,IAAIA,IACJ;QACQ,SAAKhC,MAAA,CAAOsC,KAChB;UACI,KAAKtC,MAAA,CAAOsC,KAAM;QAAA;QAGtB,KAAKtC,MAAS;MAAA;IAClB;IAGG;EAAA;EAIXuC,OACAA,CAAA;IACK,KAAK1D,MAAA,CAA4B4B,MAAS;IAC1C,KAAK5B,MAAA,CAA4B6B,OAAU;IAE5C,MAAM6B,OAAQ;IAEd,IAAI,KAAKvC,MACT;MACI,KAAKA,MAAA,CAAOsC,KAAM;MAClB,KAAKtC,MAAS;IAAA;IAElB,KAAKR,QAAW;IAChB,KAAKS,KAAQ;EAAA;EAQjB,OAAgBuC,KAAK3D,MACrB;IACI,OAAO,OAAO4D,gBAAqB,qBAAuB,OAAA5D,MAAA,KAAW,YAAYA,MAAkB,YAAA4D,gBAAA;EAAA;AAE3G"},"metadata":{},"sourceType":"module","externalDependencies":[]}