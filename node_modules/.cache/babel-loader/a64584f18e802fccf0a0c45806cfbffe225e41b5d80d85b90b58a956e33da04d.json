{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/extensions';\nimport { GLBuffer } from './GLBuffer.mjs';\nclass BufferSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.managedBuffers = {};\n    this.boundBufferBases = {};\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  contextChange() {\n    this.disposeAll(true);\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  bind(buffer) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n  }\n  unbind(type) {\n    const {\n      gl\n    } = this;\n    gl.bindBuffer(type, null);\n  }\n  bindBufferBase(buffer, index) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    if (this.boundBufferBases[index] !== buffer) {\n      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      this.boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  bindBufferRange(buffer, index, offset) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    offset = offset || 0;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  update(buffer) {\n    const {\n      gl,\n      CONTEXT_UID\n    } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(buffer.type, 0, buffer.data);\n    } else {\n      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = buffer.data.byteLength;\n      gl.bufferData(buffer.type, buffer.data, drawType);\n    }\n  }\n  dispose(buffer, contextLost) {\n    if (!this.managedBuffers[buffer.id]) {\n      return;\n    }\n    delete this.managedBuffers[buffer.id];\n    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n    const gl = this.gl;\n    buffer.disposeRunner.remove(this);\n    if (!glBuffer) {\n      return;\n    }\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    delete buffer._glBuffers[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedBuffers);\n    for (let i = 0; i < all.length; i++) {\n      this.dispose(this.managedBuffers[all[i]], contextLost);\n    }\n  }\n  createGLBuffer(buffer) {\n    const {\n      CONTEXT_UID,\n      gl\n    } = this;\n    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n    this.managedBuffers[buffer.id] = buffer;\n    buffer.disposeRunner.add(this);\n    return buffer._glBuffers[CONTEXT_UID];\n  }\n}\nBufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"buffer\"\n};\nextensions.add(BufferSystem);\nexport { BufferSystem };","map":{"version":3,"names":["BufferSystem","constructor","renderer","managedBuffers","boundBufferBases","destroy","contextChange","disposeAll","gl","CONTEXT_UID","bind","buffer","glBuffer","_glBuffers","createGLBuffer","bindBuffer","type","unbind","bindBufferBase","index","UNIFORM_BUFFER","bindBufferRange","offset","update","_updateID","updateID","byteLength","data","bufferSubData","drawType","static","STATIC_DRAW","DYNAMIC_DRAW","bufferData","dispose","contextLost","id","disposeRunner","remove","deleteBuffer","all","Object","keys","i","length","GLBuffer","createBuffer","add","extension","ExtensionType","RendererSystem","name","extensions"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\geometry\\BufferSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { GLBuffer } from './GLBuffer';\n\nimport type { BUFFER_TYPE } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { Buffer } from './Buffer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the PIXI.Buffer class.\n * @class\n * @memberof PIXI\n */\nexport class BufferSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'buffer',\n    };\n\n    CONTEXT_UID: number;\n    gl: IRenderingContext;\n\n    /** Cache for all buffers by id, used in case renderer gets destroyed or for profiling */\n    readonly managedBuffers: {[key: number]: Buffer};\n\n    /** Cache keeping track of the base bound buffer bases */\n    readonly boundBufferBases: {[key: number]: Buffer};\n\n    private renderer: Renderer;\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.managedBuffers = {};\n        this.boundBufferBases = {};\n    }\n\n    /**\n     * @ignore\n     */\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        this.gl = this.renderer.gl;\n\n        // TODO fill out...\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    bind(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n    }\n\n    unbind(type: BUFFER_TYPE): void\n    {\n        const { gl } = this;\n\n        gl.bindBuffer(type, null);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    bindBufferBase(buffer: Buffer, index: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        if (this.boundBufferBases[index] !== buffer)\n        {\n            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n            this.boundBufferBases[index] = buffer;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     */\n    bindBufferRange(buffer: Buffer, index?: number, offset?: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        offset = offset || 0;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {PIXI.Buffer} buffer - the buffer to update\n     */\n    update(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n\n        if (glBuffer.byteLength >= buffer.data.byteLength)\n        {\n            // offset is always zero for now!\n            gl.bufferSubData(buffer.type, 0, buffer.data);\n        }\n        else\n        {\n            const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n            glBuffer.byteLength = buffer.data.byteLength;\n            gl.bufferData(buffer.type, buffer.data, drawType);\n        }\n    }\n\n    /**\n     * Disposes buffer\n     * @param {PIXI.Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    dispose(buffer: Buffer, contextLost?: boolean): void\n    {\n        if (!this.managedBuffers[buffer.id])\n        {\n            return;\n        }\n\n        delete this.managedBuffers[buffer.id];\n\n        const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n        const gl = this.gl;\n\n        buffer.disposeRunner.remove(this);\n\n        if (!glBuffer)\n        {\n            return;\n        }\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        delete buffer._glBuffers[this.CONTEXT_UID];\n    }\n\n    /**\n     * dispose all WebGL resources of all managed buffers\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedBuffers);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.dispose(this.managedBuffers[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GLBuffer\n    {\n        const { CONTEXT_UID, gl } = this;\n\n        buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n\n        this.managedBuffers[buffer.id] = buffer;\n\n        buffer.disposeRunner.add(this);\n\n        return buffer._glBuffers[CONTEXT_UID];\n    }\n}\n\nextensions.add(BufferSystem);\n"],"mappings":";;AA2BO,MAAMA,YACb;EAqBIC,YAAYC,QACZ;IACI,KAAKA,QAAW,GAAAA,QAAA;IAChB,KAAKC,cAAA,GAAiB,EAAC;IACvB,KAAKC,gBAAA,GAAmB,EAAC;EAAA;EAM7BC,OACAA,CAAA;IACI,KAAKH,QAAW;EAAA;EAIpBI,aACAA,CAAA;IACI,KAAKC,UAAA,CAAW,IAAI;IAEf,KAAAC,EAAA,GAAK,KAAKN,QAAS,CAAAM,EAAA;IAGnB,KAAAC,WAAA,GAAc,KAAKP,QAAS,CAAAO,WAAA;EAAA;EAOrCC,KAAKC,MACL;IACU;MAAEH,EAAA;MAAIC;IAAgB;IAE5B,MAAMG,QAAA,GAAWD,MAAO,CAAAE,UAAA,CAAWJ,WAAgB,UAAKK,cAAA,CAAeH,MAAM;IAE7EH,EAAA,CAAGO,UAAW,CAAAJ,MAAA,CAAOK,IAAM,EAAAJ,QAAA,CAASD,MAAM;EAAA;EAG9CM,OAAOD,IACP;IACI,MAAM;MAAER;IAAO;IAEZA,EAAA,CAAAO,UAAA,CAAWC,IAAA,EAAM,IAAI;EAAA;EAU5BE,eAAeP,MAAA,EAAgBQ,KAC/B;IACU;MAAEX,EAAA;MAAIC;IAAgB;IAExB,SAAKL,gBAAiB,CAAAe,KAAA,MAAWR,MACrC;MACI,MAAMC,QAAA,GAAWD,MAAO,CAAAE,UAAA,CAAWJ,WAAgB,UAAKK,cAAA,CAAeH,MAAM;MAE7E,KAAKP,gBAAA,CAAiBe,KAAS,IAAAR,MAAA;MAE/BH,EAAA,CAAGU,cAAe,CAAAV,EAAA,CAAGY,cAAgB,EAAAD,KAAA,EAAOP,QAAA,CAASD,MAAM;IAAA;EAC/D;EAUJU,gBAAgBV,MAAgB,EAAAQ,KAAA,EAAgBG,MAChD;IACU;MAAEd,EAAA;MAAIC;IAAgB;IAE5Ba,MAAA,GAASA,MAAU;IAEnB,MAAMV,QAAA,GAAWD,MAAO,CAAAE,UAAA,CAAWJ,WAAgB,UAAKK,cAAA,CAAeH,MAAM;IAE1EH,EAAA,CAAAa,eAAA,CAAgBb,EAAA,CAAGY,cAAgB,EAAAD,KAAA,IAAS,GAAGP,QAAS,CAAAD,MAAA,EAAQW,MAAS,QAAK,GAAG;EAAA;EAOxFC,OAAOZ,MACP;IACU;MAAEH,EAAA;MAAIC;IAAgB;IAE5B,MAAMG,QAAA,GAAWD,MAAO,CAAAE,UAAA,CAAWJ,WAAgB,UAAKK,cAAA,CAAeH,MAAM;IAEzE,IAAAA,MAAA,CAAOa,SAAc,KAAAZ,QAAA,CAASa,QAClC;MACI;IAAA;IAGJb,QAAA,CAASa,QAAA,GAAWd,MAAO,CAAAa,SAAA;IAE3BhB,EAAA,CAAGO,UAAW,CAAAJ,MAAA,CAAOK,IAAM,EAAAJ,QAAA,CAASD,MAAM;IAE1C,IAAIC,QAAS,CAAAc,UAAA,IAAcf,MAAO,CAAAgB,IAAA,CAAKD,UACvC;MAEIlB,EAAA,CAAGoB,aAAc,CAAAjB,MAAA,CAAOK,IAAM,KAAGL,MAAA,CAAOgB,IAAI;IAAA,CAGhD;MACI,MAAME,QAAW,GAAAlB,MAAA,CAAOmB,MAAS,GAAAtB,EAAA,CAAGuB,WAAA,GAAcvB,EAAG,CAAAwB,YAAA;MAE5CpB,QAAA,CAAAc,UAAA,GAAaf,MAAA,CAAOgB,IAAK,CAAAD,UAAA;MAClClB,EAAA,CAAGyB,UAAW,CAAAtB,MAAA,CAAOK,IAAM,EAAAL,MAAA,CAAOgB,IAAA,EAAME,QAAQ;IAAA;EACpD;EAQJK,QAAQvB,MAAA,EAAgBwB,WACxB;IACI,IAAI,CAAC,KAAKhC,cAAe,CAAAQ,MAAA,CAAOyB,EAChC;MACI;IAAA;IAGG,YAAKjC,cAAA,CAAeQ,MAAO,CAAAyB,EAAA;IAE5B,MAAAxB,QAAA,GAAWD,MAAO,CAAAE,UAAA,CAAW,IAAK,CAAAJ,WAAA;IACxC,MAAMD,EAAA,GAAK,IAAK,CAAAA,EAAA;IAETG,MAAA,CAAA0B,aAAA,CAAcC,MAAA,CAAO,IAAI;IAEhC,IAAI,CAAC1B,QACL;MACI;IAAA;IAGJ,IAAI,CAACuB,WACL;MACO3B,EAAA,CAAA+B,YAAA,CAAa3B,QAAA,CAASD,MAAM;IAAA;IAG5B,OAAAA,MAAA,CAAOE,UAAA,CAAW,IAAK,CAAAJ,WAAA;EAAA;EAOlCF,WAAW4B,WACX;IACI,MAAMK,GAAkB,GAAAC,MAAA,CAAOC,IAAK,MAAKvC,cAAc;IAEvD,SAASwC,CAAI,MAAGA,CAAI,GAAAH,GAAA,CAAII,MAAA,EAAQD,CAChC;MACI,KAAKT,OAAQ,MAAK/B,cAAe,CAAAqC,GAAA,CAAIG,CAAA,IAAKR,WAAW;IAAA;EACzD;EAQMrB,eAAeH,MACzB;IACU;MAAEF,WAAA;MAAaD;IAAO;IAE5BG,MAAA,CAAOE,UAAA,CAAWJ,WAAe,QAAIoC,QAAS,CAAArC,EAAA,CAAGsC,YAAA,EAAc;IAE1D,KAAA3C,cAAA,CAAeQ,MAAA,CAAOyB,EAAM,IAAAzB,MAAA;IAE1BA,MAAA,CAAA0B,aAAA,CAAcU,GAAA,CAAI,IAAI;IAE7B,OAAOpC,MAAA,CAAOE,UAAW,CAAAJ,WAAA;EAAA;AAEjC;AA3MaT,YAAA,CAGFgD,SAA+B;EAClChC,IAAA,EAAMiC,aAAc,CAAAC,cAAA;EACpBC,IAAM;AACV;AAuMJC,UAAA,CAAWL,GAAA,CAAI/C,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}