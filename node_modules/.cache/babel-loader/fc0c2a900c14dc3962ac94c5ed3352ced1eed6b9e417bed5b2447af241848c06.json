{"ast":null,"code":"import { Color, ObservablePoint, settings, Point, Texture, utils, BLEND_MODES, Program } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshGeometry, MeshMaterial, Mesh } from '@pixi/mesh';\nimport { BitmapFont } from './BitmapFont.mjs';\nimport msdfFrag from './shader/msdf.mjs';\nimport msdfVert from './shader/msdf2.mjs';\nimport './utils/index.mjs';\nimport { splitTextToCharacters } from './utils/splitTextToCharacters.mjs';\nimport { extractCharCode } from './utils/extractCharCode.mjs';\nconst pageMeshDataDefaultPageMeshData = [];\nconst pageMeshDataMSDFPageMeshData = [];\nconst charRenderDataPool = [];\nconst _BitmapText = class extends Container {\n  constructor(text) {\n    let style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    const {\n      align,\n      tint,\n      maxWidth,\n      letterSpacing,\n      fontName,\n      fontSize\n    } = Object.assign({}, _BitmapText.styleDefaults, style);\n    if (!BitmapFont.available[fontName]) {\n      throw new Error(`Missing BitmapFont \"${fontName}\"`);\n    }\n    this._activePagesMeshData = [];\n    this._textWidth = 0;\n    this._textHeight = 0;\n    this._align = align;\n    this._tintColor = new Color(tint);\n    this._font = void 0;\n    this._fontName = fontName;\n    this._fontSize = fontSize;\n    this.text = text;\n    this._maxWidth = maxWidth;\n    this._maxLineHeight = 0;\n    this._letterSpacing = letterSpacing;\n    this._anchor = new ObservablePoint(() => {\n      this.dirty = true;\n    }, this, 0, 0);\n    this._roundPixels = settings.ROUND_PIXELS;\n    this.dirty = true;\n    this._resolution = settings.RESOLUTION;\n    this._autoResolution = true;\n    this._textureCache = {};\n  }\n  updateText() {\n    const data = BitmapFont.available[this._fontName];\n    const fontSize = this.fontSize;\n    const scale = fontSize / data.size;\n    const pos = new Point();\n    const chars = [];\n    const lineWidths = [];\n    const lineSpaces = [];\n    const text = this._text.replace(/(?:\\r\\n|\\r)/g, \"\\n\") || \" \";\n    const charsInput = splitTextToCharacters(text);\n    const maxWidth = this._maxWidth * data.size / fontSize;\n    const pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    let prevCharCode = null;\n    let lastLineWidth = 0;\n    let maxLineWidth = 0;\n    let line = 0;\n    let lastBreakPos = -1;\n    let lastBreakWidth = 0;\n    let spacesRemoved = 0;\n    let maxLineHeight = 0;\n    let spaceCount = 0;\n    for (let i = 0; i < charsInput.length; i++) {\n      const char = charsInput[i];\n      const charCode = extractCharCode(char);\n      if (/(?:\\s)/.test(char)) {\n        lastBreakPos = i;\n        lastBreakWidth = lastLineWidth;\n        spaceCount++;\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        lineWidths.push(lastLineWidth);\n        lineSpaces.push(-1);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        ++line;\n        ++spacesRemoved;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n        continue;\n      }\n      const charData = data.chars[charCode];\n      if (!charData) {\n        continue;\n      }\n      if (prevCharCode && charData.kerning[prevCharCode]) {\n        pos.x += charData.kerning[prevCharCode];\n      }\n      const charRenderData = charRenderDataPool.pop() || {\n        texture: Texture.EMPTY,\n        line: 0,\n        charCode: 0,\n        prevSpaces: 0,\n        position: new Point()\n      };\n      charRenderData.texture = charData.texture;\n      charRenderData.line = line;\n      charRenderData.charCode = charCode;\n      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);\n      charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n      charRenderData.prevSpaces = spaceCount;\n      chars.push(charRenderData);\n      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n      pos.x += charData.xAdvance + this._letterSpacing;\n      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n      prevCharCode = charCode;\n      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n        ++spacesRemoved;\n        utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n        i = lastBreakPos;\n        lastBreakPos = -1;\n        lineWidths.push(lastBreakWidth);\n        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n        line++;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n      }\n    }\n    const lastChar = charsInput[charsInput.length - 1];\n    if (lastChar !== \"\\r\" && lastChar !== \"\\n\") {\n      if (/(?:\\s)/.test(lastChar)) {\n        lastLineWidth = lastBreakWidth;\n      }\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n      lineSpaces.push(-1);\n    }\n    const lineAlignOffsets = [];\n    for (let i = 0; i <= line; i++) {\n      let alignOffset = 0;\n      if (this._align === \"right\") {\n        alignOffset = maxLineWidth - lineWidths[i];\n      } else if (this._align === \"center\") {\n        alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n      } else if (this._align === \"justify\") {\n        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n      }\n      lineAlignOffsets.push(alignOffset);\n    }\n    const lenChars = chars.length;\n    const pagesMeshData = {};\n    const newPagesMeshData = [];\n    const activePagesMeshData = this._activePagesMeshData;\n    pageMeshDataPool.push(...activePagesMeshData);\n    for (let i = 0; i < lenChars; i++) {\n      const texture = chars[i].texture;\n      const baseTextureUid = texture.baseTexture.uid;\n      if (!pagesMeshData[baseTextureUid]) {\n        let pageMeshData = pageMeshDataPool.pop();\n        if (!pageMeshData) {\n          const geometry = new MeshGeometry();\n          let material;\n          let meshBlendMode;\n          if (data.distanceFieldType === \"none\") {\n            material = new MeshMaterial(Texture.EMPTY);\n            meshBlendMode = BLEND_MODES.NORMAL;\n          } else {\n            material = new MeshMaterial(Texture.EMPTY, {\n              program: Program.from(msdfVert, msdfFrag),\n              uniforms: {\n                uFWidth: 0\n              }\n            });\n            meshBlendMode = BLEND_MODES.NORMAL_NPM;\n          }\n          const mesh = new Mesh(geometry, material);\n          mesh.blendMode = meshBlendMode;\n          pageMeshData = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        pageMeshData.index = 0;\n        pageMeshData.indexCount = 0;\n        pageMeshData.vertexCount = 0;\n        pageMeshData.uvsCount = 0;\n        pageMeshData.total = 0;\n        const {\n          _textureCache\n        } = this;\n        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n        pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n        pageMeshData.mesh.tint = this._tintColor.value;\n        newPagesMeshData.push(pageMeshData);\n        pagesMeshData[baseTextureUid] = pageMeshData;\n      }\n      pagesMeshData[baseTextureUid].total++;\n    }\n    for (let i = 0; i < activePagesMeshData.length; i++) {\n      if (!newPagesMeshData.includes(activePagesMeshData[i])) {\n        this.removeChild(activePagesMeshData[i].mesh);\n      }\n    }\n    for (let i = 0; i < newPagesMeshData.length; i++) {\n      if (newPagesMeshData[i].mesh.parent !== this) {\n        this.addChild(newPagesMeshData[i].mesh);\n      }\n    }\n    this._activePagesMeshData = newPagesMeshData;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      const total = pageMeshData.total;\n      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {\n        pageMeshData.vertices = new Float32Array(4 * 2 * total);\n        pageMeshData.uvs = new Float32Array(4 * 2 * total);\n        pageMeshData.indices = new Uint16Array(6 * total);\n      } else {\n        const total2 = pageMeshData.total;\n        const vertices = pageMeshData.vertices;\n        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {\n          vertices[i2] = 0;\n        }\n      }\n      pageMeshData.mesh.size = 6 * total;\n    }\n    for (let i = 0; i < lenChars; i++) {\n      const char = chars[i];\n      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === \"justify\" ? char.prevSpaces : 1);\n      if (this._roundPixels) {\n        offset = Math.round(offset);\n      }\n      const xPos = offset * scale;\n      const yPos = char.position.y * scale;\n      const texture = char.texture;\n      const pageMesh = pagesMeshData[texture.baseTexture.uid];\n      const textureFrame = texture.frame;\n      const textureUvs = texture._uvs;\n      const index = pageMesh.index++;\n      pageMesh.indices[index * 6 + 0] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 1] = 1 + index * 4;\n      pageMesh.indices[index * 6 + 2] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 3] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 4] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 5] = 3 + index * 4;\n      pageMesh.vertices[index * 8 + 0] = xPos;\n      pageMesh.vertices[index * 8 + 1] = yPos;\n      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 3] = yPos;\n      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;\n      pageMesh.vertices[index * 8 + 6] = xPos;\n      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;\n      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;\n      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;\n      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;\n      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;\n      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;\n      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;\n      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;\n      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n    }\n    this._textWidth = maxLineWidth * scale;\n    this._textHeight = (pos.y + data.lineHeight) * scale;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n        let vertexCount = 0;\n        const anchorOffsetX = this._textWidth * this.anchor.x;\n        const anchorOffsetY = this._textHeight * this.anchor.y;\n        for (let i2 = 0; i2 < pageMeshData.total; i2++) {\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n        }\n      }\n      this._maxLineHeight = maxLineHeight * scale;\n      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer(\"aVertexPosition\");\n      const textureBuffer = pageMeshData.mesh.geometry.getBuffer(\"aTextureCoord\");\n      const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n      vertexBuffer.data = pageMeshData.vertices;\n      textureBuffer.data = pageMeshData.uvs;\n      indexBuffer.data = pageMeshData.indices;\n      vertexBuffer.update();\n      textureBuffer.update();\n      indexBuffer.update();\n    }\n    for (let i = 0; i < chars.length; i++) {\n      charRenderDataPool.push(chars[i]);\n    }\n    this._font = data;\n    this.dirty = false;\n  }\n  updateTransform() {\n    this.validate();\n    this.containerUpdateTransform();\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    const {\n      distanceFieldRange,\n      distanceFieldType,\n      size\n    } = BitmapFont.available[this._fontName];\n    if (distanceFieldType !== \"none\") {\n      const {\n        a,\n        b,\n        c,\n        d\n      } = this.worldTransform;\n      const dx = Math.sqrt(a * a + b * b);\n      const dy = Math.sqrt(c * c + d * d);\n      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n      const fontScale = this.fontSize / size;\n      const resolution = renderer._view.resolution;\n      for (const mesh of this._activePagesMeshData) {\n        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n      }\n    }\n    super._render(renderer);\n  }\n  getLocalBounds() {\n    this.validate();\n    return super.getLocalBounds();\n  }\n  validate() {\n    const font = BitmapFont.available[this._fontName];\n    if (!font) {\n      throw new Error(`Missing BitmapFont \"${this._fontName}\"`);\n    }\n    if (this._font !== font) {\n      this.dirty = true;\n    }\n    if (this.dirty) {\n      this.updateText();\n    }\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    if (this.tint === value) return;\n    this._tintColor.setValue(value);\n    for (let i = 0; i < this._activePagesMeshData.length; i++) {\n      this._activePagesMeshData[i].mesh.tint = value;\n    }\n  }\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    if (this._align !== value) {\n      this._align = value;\n      this.dirty = true;\n    }\n  }\n  get fontName() {\n    return this._fontName;\n  }\n  set fontName(value) {\n    if (!BitmapFont.available[value]) {\n      throw new Error(`Missing BitmapFont \"${value}\"`);\n    }\n    if (this._fontName !== value) {\n      this._fontName = value;\n      this.dirty = true;\n    }\n  }\n  get fontSize() {\n    return this._fontSize ?? BitmapFont.available[this._fontName].size;\n  }\n  set fontSize(value) {\n    if (this._fontSize !== value) {\n      this._fontSize = value;\n      this.dirty = true;\n    }\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    if (typeof value === \"number\") {\n      this._anchor.set(value);\n    } else {\n      this._anchor.copyFrom(value);\n    }\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === null || text === void 0 ? \"\" : text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  set maxWidth(value) {\n    if (this._maxWidth === value) {\n      return;\n    }\n    this._maxWidth = value;\n    this.dirty = true;\n  }\n  get maxLineHeight() {\n    this.validate();\n    return this._maxLineHeight;\n  }\n  get textWidth() {\n    this.validate();\n    return this._textWidth;\n  }\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    if (this._letterSpacing !== value) {\n      this._letterSpacing = value;\n      this.dirty = true;\n    }\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  set roundPixels(value) {\n    if (value !== this._roundPixels) {\n      this._roundPixels = value;\n      this.dirty = true;\n    }\n  }\n  get textHeight() {\n    this.validate();\n    return this._textHeight;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n  destroy(options) {\n    const {\n      _textureCache\n    } = this;\n    const data = BitmapFont.available[this._fontName];\n    const pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    pageMeshDataPool.push(...this._activePagesMeshData);\n    for (const pageMeshData of this._activePagesMeshData) {\n      this.removeChild(pageMeshData.mesh);\n    }\n    this._activePagesMeshData = [];\n    pageMeshDataPool.filter(page => _textureCache[page.mesh.texture.baseTexture.uid]).forEach(page => {\n      page.mesh.texture = Texture.EMPTY;\n    });\n    for (const id in _textureCache) {\n      const texture = _textureCache[id];\n      texture.destroy();\n      delete _textureCache[id];\n    }\n    this._font = null;\n    this._tintColor = null;\n    this._textureCache = null;\n    super.destroy(options);\n  }\n};\nlet BitmapText = _BitmapText;\nBitmapText.styleDefaults = {\n  align: \"left\",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\nexport { BitmapText };","map":{"version":3,"names":["pageMeshDataDefaultPageMeshData","pageMeshDataMSDFPageMeshData","charRenderDataPool","_BitmapText","Container","constructor","text","style","arguments","length","undefined","align","tint","maxWidth","letterSpacing","fontName","fontSize","Object","assign","styleDefaults","BitmapFont","available","Error","_activePagesMeshData","_textWidth","_textHeight","_align","_tintColor","Color","_font","_fontName","_fontSize","_maxWidth","_maxLineHeight","_letterSpacing","_anchor","ObservablePoint","dirty","_roundPixels","settings","ROUND_PIXELS","_resolution","RESOLUTION","_autoResolution","_textureCache","updateText","data","scale","size","pos","Point","chars","lineWidths","lineSpaces","_text","replace","charsInput","splitTextToCharacters","pageMeshDataPool","distanceFieldType","prevCharCode","lastLineWidth","maxLineWidth","line","lastBreakPos","lastBreakWidth","spacesRemoved","maxLineHeight","spaceCount","i","char","charCode","extractCharCode","test","push","Math","max","x","y","lineHeight","charData","kerning","charRenderData","pop","texture","Texture","EMPTY","prevSpaces","position","round","xOffset","yOffset","xAdvance","orig","width","height","utils","removeItems","lastChar","lineAlignOffsets","alignOffset","lenChars","pagesMeshData","newPagesMeshData","activePagesMeshData","baseTextureUid","baseTexture","uid","pageMeshData","geometry","MeshGeometry","material","meshBlendMode","MeshMaterial","BLEND_MODES","NORMAL","program","Program","from","msdfVert","msdfFrag","uniforms","uFWidth","NORMAL_NPM","mesh","Mesh","blendMode","index","indexCount","vertexCount","uvsCount","total","vertices","uvs","indices","value","includes","removeChild","parent","addChild","BATCHABLE_SIZE","Float32Array","Uint16Array","total2","i2","offset","xPos","yPos","pageMesh","textureFrame","frame","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","anchor","anchorOffsetX","anchorOffsetY","vertexBuffer","getBuffer","textureBuffer","indexBuffer","getIndex","update","updateTransform","validate","containerUpdateTransform","_render","renderer","resolution","distanceFieldRange","a","b","c","d","worldTransform","dx","sqrt","dy","worldScale","abs","fontScale","_view","shader","getLocalBounds","font","setValue","set","copyFrom","String","textWidth","roundPixels","textHeight","destroy","options","filter","page","forEach","id","BitmapText"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\text-bitmap\\src\\BitmapText.ts"],"sourcesContent":["import { BLEND_MODES, Color, ObservablePoint, Point, Program, settings, Texture, utils } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { BitmapFont } from './BitmapFont';\nimport msdfFrag from './shader/msdf.frag';\nimport msdfVert from './shader/msdf.vert';\nimport { extractCharCode, splitTextToCharacters } from './utils';\n\nimport type { ColorSource, Rectangle, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { TextStyleAlign } from '@pixi/text';\nimport type { IBitmapTextStyle } from './BitmapTextStyle';\n\ninterface PageMeshData\n{\n    index: number;\n    indexCount: number;\n    vertexCount: number;\n    uvsCount: number;\n    total: number;\n    mesh: Mesh;\n    vertices?: Float32Array;\n    uvs?: Float32Array;\n    indices?: Uint16Array;\n}\ninterface CharRenderData\n{\n    texture: Texture;\n    line: number;\n    charCode: number;\n    position: Point;\n    prevSpaces: number;\n}\n\n// If we ever need more than two pools, please make a Dict or something better.\nconst pageMeshDataDefaultPageMeshData: PageMeshData[] = [];\nconst pageMeshDataMSDFPageMeshData: PageMeshData[] = [];\nconst charRenderDataPool: CharRenderData[] = [];\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font.\n *\n * The primary advantage of this class over Text is that all of your textures are pre-generated and loading,\n * meaning that rendering is fast, and changing text has no performance implications.\n *\n * Supporting character sets other than latin, such as CJK languages, may be impractical due to the number of characters.\n *\n * To split a line you can use '\\n', '\\r' or '\\r\\n' in your string.\n *\n * PixiJS can auto-generate fonts on-the-fly using BitmapFont or use fnt files provided by:\n * http://www.angelcode.com/products/bmfont/ for Windows or\n * http://www.bmglyph.com/ for Mac.\n *\n * You can also use SDF, MSDF and MTSDF BitmapFonts for vector-like scaling appearance provided by:\n * https://github.com/soimy/msdf-bmfont-xml for SDF and MSDF fnt files or\n * https://github.com/Chlumsky/msdf-atlas-gen for SDF, MSDF and MTSDF json files\n *\n * A BitmapText can only be created when the font is loaded.\n * @example\n * import { BitmapText } from 'pixi.js';\n *\n * // in this case the font is in a file called 'desyrel.fnt'\n * const bitmapText = new BitmapText('text using a fancy font!', {\n *     fontName: 'Desyrel',\n *     fontSize: 35,\n *     align: 'right',\n * });\n * @memberof PIXI\n */\nexport class BitmapText extends Container\n{\n    public static styleDefaults: Partial<IBitmapTextStyle> = {\n        align: 'left',\n        tint: 0xFFFFFF,\n        maxWidth: 0,\n        letterSpacing: 0,\n    };\n\n    /** Set to `true` if the BitmapText needs to be redrawn. */\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the width of the overall text.\n     * @private\n     */\n    protected _textWidth: number;\n\n    /**\n     * Private tracker for the height of the overall text.\n     * @private\n     */\n    protected _textHeight: number;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     * @private\n     */\n    protected _maxWidth: number;\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align. (Internally used)\n     * @private\n     */\n    protected _maxLineHeight: number;\n\n    /**\n     * Letter spacing. This is useful for setting the space between characters.\n     * @private\n     */\n    protected _letterSpacing: number;\n\n    /**\n     * Text anchor.\n     * @readonly\n     * @private\n     */\n    protected _anchor: ObservablePoint;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font?: BitmapFont;\n\n    /**\n     * Private tracker for the current font name.\n     * @private\n     */\n    protected _fontName: string;\n\n    /**\n     * Private tracker for the current font size.\n     * @private\n     */\n    protected _fontSize?: number;\n\n    /**\n     * Private tracker for the current text align.\n     * @type {string}\n     * @private\n     */\n    protected _align: TextStyleAlign;\n\n    /** Collection of page mesh data. */\n    protected _activePagesMeshData: PageMeshData[];\n\n    /**\n     * Private tracker for the current tint.\n     * @private\n     */\n    protected _tintColor: Color;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering.\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    protected _roundPixels: boolean;\n\n    /** Cached char texture is destroyed when BitmapText is destroyed. */\n    private _textureCache: Record<number, Texture>;\n\n    /**\n     * @param text - A string that you would like the text to display.\n     * @param style - The style parameters.\n     * @param {string} style.fontName - The installed BitmapFont name.\n     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n     *.     this will default to the BitmapFont size.\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),\n     *      does not affect single line text.\n     * @param {PIXI.ColorSource} [style.tint=0xFFFFFF] - The tint color.\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n     */\n    constructor(text: string, style: Partial<IBitmapTextStyle> = {})\n    {\n        super();\n\n        // Apply the defaults\n        const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(\n            {}, BitmapText.styleDefaults, style);\n\n        if (!BitmapFont.available[fontName])\n        {\n            throw new Error(`Missing BitmapFont \"${fontName}\"`);\n        }\n\n        this._activePagesMeshData = [];\n        this._textWidth = 0;\n        this._textHeight = 0;\n        this._align = align;\n        this._tintColor = new Color(tint);\n        this._font = undefined;\n        this._fontName = fontName;\n        this._fontSize = fontSize;\n        this.text = text;\n        this._maxWidth = maxWidth;\n        this._maxLineHeight = 0;\n        this._letterSpacing = letterSpacing;\n        this._anchor = new ObservablePoint((): void => { this.dirty = true; }, this, 0, 0);\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.dirty = true;\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._textureCache = {};\n    }\n\n    /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */\n    public updateText(): void\n    {\n        const data = BitmapFont.available[this._fontName];\n        const fontSize = this.fontSize;\n        const scale = fontSize / data.size;\n        const pos = new Point();\n        const chars: CharRenderData[] = [];\n        const lineWidths = [];\n        const lineSpaces = [];\n        const text = this._text.replace(/(?:\\r\\n|\\r)/g, '\\n') || ' ';\n        const charsInput = splitTextToCharacters(text);\n        const maxWidth = this._maxWidth * data.size / fontSize;\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n        let spaceCount = 0;\n\n        for (let i = 0; i < charsInput.length; i++)\n        {\n            const char = charsInput[i];\n            const charCode = extractCharCode(char);\n\n            if ((/(?:\\s)/).test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n                spaceCount++;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                lineSpaces.push(-1);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            const charRenderData: CharRenderData = charRenderDataPool.pop() || {\n                texture: Texture.EMPTY,\n                line: 0,\n                charCode: 0,\n                prevSpaces: 0,\n                position: new Point(),\n            };\n\n            charRenderData.texture = charData.texture;\n            charRenderData.line = line;\n            charRenderData.charCode = charCode;\n            charRenderData.position.x = Math.round(pos.x + charData.xOffset + (this._letterSpacing / 2));\n            charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n            charRenderData.prevSpaces = spaceCount;\n\n            chars.push(charRenderData);\n\n            lastLineWidth = charRenderData.position.x\n                + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n            pos.x += charData.xAdvance + this._letterSpacing;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n            }\n        }\n\n        const lastChar = charsInput[charsInput.length - 1];\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if ((/(?:\\s)/).test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            lineSpaces.push(-1);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n            else if (this._align === 'justify')\n            {\n                alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n\n        const pagesMeshData: Record<number, PageMeshData> = {};\n\n        const newPagesMeshData: PageMeshData[] = [];\n\n        const activePagesMeshData = this._activePagesMeshData;\n\n        pageMeshDataPool.push(...activePagesMeshData);\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const texture = chars[i].texture;\n            const baseTextureUid = texture.baseTexture.uid;\n\n            if (!pagesMeshData[baseTextureUid])\n            {\n                let pageMeshData = pageMeshDataPool.pop();\n\n                if (!pageMeshData)\n                {\n                    const geometry = new MeshGeometry();\n                    let material: MeshMaterial;\n                    let meshBlendMode: BLEND_MODES;\n\n                    if (data.distanceFieldType === 'none')\n                    {\n                        material = new MeshMaterial(Texture.EMPTY);\n                        meshBlendMode = BLEND_MODES.NORMAL;\n                    }\n                    else\n                    {\n                        material = new MeshMaterial(Texture.EMPTY,\n                            { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n                        meshBlendMode = BLEND_MODES.NORMAL_NPM;\n                    }\n\n                    const mesh = new Mesh(geometry, material);\n\n                    mesh.blendMode = meshBlendMode;\n\n                    pageMeshData = {\n                        index: 0,\n                        indexCount: 0,\n                        vertexCount: 0,\n                        uvsCount: 0,\n                        total: 0,\n                        mesh,\n                        vertices: null,\n                        uvs: null,\n                        indices: null,\n                    };\n                }\n\n                // reset data..\n                pageMeshData.index = 0;\n                pageMeshData.indexCount = 0;\n                pageMeshData.vertexCount = 0;\n                pageMeshData.uvsCount = 0;\n                pageMeshData.total = 0;\n\n                // TODO need to get page texture here somehow..\n                const { _textureCache } = this;\n\n                _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n                pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n\n                pageMeshData.mesh.tint = this._tintColor.value;\n\n                newPagesMeshData.push(pageMeshData);\n\n                pagesMeshData[baseTextureUid] = pageMeshData;\n            }\n\n            pagesMeshData[baseTextureUid].total++;\n        }\n\n        // lets find any previously active pageMeshDatas that are no longer required for\n        // the updated text (if any), removed and return them to the pool.\n        for (let i = 0; i < activePagesMeshData.length; i++)\n        {\n            if (!newPagesMeshData.includes(activePagesMeshData[i]))\n            {\n                this.removeChild(activePagesMeshData[i].mesh);\n            }\n        }\n\n        // next lets add any new meshes, that have not yet been added to this BitmapText\n        // we only add if its not already a child of this BitmapObject\n        for (let i = 0; i < newPagesMeshData.length; i++)\n        {\n            if (newPagesMeshData[i].mesh.parent !== this)\n            {\n                this.addChild(newPagesMeshData[i].mesh);\n            }\n        }\n\n        // active page mesh datas are set to be the new pages added.\n        this._activePagesMeshData = newPagesMeshData;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n            const total = pageMeshData.total;\n\n            // lets only allocate new buffers if we can fit the new text in the current ones..\n            // unless that is, we will be batching. Currently batching dose not respect the size property of mesh\n            if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n            {\n                pageMeshData.vertices = new Float32Array(4 * 2 * total);\n                pageMeshData.uvs = new Float32Array(4 * 2 * total);\n                pageMeshData.indices = new Uint16Array(6 * total);\n            }\n            else\n            {\n                const total = pageMeshData.total;\n                const vertices = pageMeshData.vertices;\n\n                // Clear the garbage at the end of the vertices buffer. This will prevent the bounds miscalculation.\n                for (let i = total * 4 * 2; i < vertices.length; i++)\n                {\n                    vertices[i] = 0;\n                }\n            }\n\n            // as a buffer maybe bigger than the current word, we set the size of the meshMaterial\n            // to match the number of letters needed\n            pageMeshData.mesh.size = 6 * total;\n        }\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const char = chars[i];\n            let offset = char.position.x + (lineAlignOffsets[char.line] * (this._align === 'justify' ? char.prevSpaces : 1));\n\n            if (this._roundPixels)\n            {\n                offset = Math.round(offset);\n            }\n\n            const xPos = offset * scale;\n            const yPos = char.position.y * scale;\n            const texture = char.texture;\n\n            const pageMesh = pagesMeshData[texture.baseTexture.uid];\n\n            const textureFrame = texture.frame;\n            const textureUvs = texture._uvs;\n\n            const index = pageMesh.index++;\n\n            pageMesh.indices[(index * 6) + 0] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 1] = 1 + (index * 4);\n            pageMesh.indices[(index * 6) + 2] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 3] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 4] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 5] = 3 + (index * 4);\n\n            pageMesh.vertices[(index * 8) + 0] = xPos;\n            pageMesh.vertices[(index * 8) + 1] = yPos;\n\n            pageMesh.vertices[(index * 8) + 2] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 3] = yPos;\n\n            pageMesh.vertices[(index * 8) + 4] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 5] = yPos + (textureFrame.height * scale);\n\n            pageMesh.vertices[(index * 8) + 6] = xPos;\n            pageMesh.vertices[(index * 8) + 7] = yPos + (textureFrame.height * scale);\n\n            pageMesh.uvs[(index * 8) + 0] = textureUvs.x0;\n            pageMesh.uvs[(index * 8) + 1] = textureUvs.y0;\n\n            pageMesh.uvs[(index * 8) + 2] = textureUvs.x1;\n            pageMesh.uvs[(index * 8) + 3] = textureUvs.y1;\n\n            pageMesh.uvs[(index * 8) + 4] = textureUvs.x2;\n            pageMesh.uvs[(index * 8) + 5] = textureUvs.y2;\n\n            pageMesh.uvs[(index * 8) + 6] = textureUvs.x3;\n            pageMesh.uvs[(index * 8) + 7] = textureUvs.y3;\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n\n            // apply anchor\n            if (this.anchor.x !== 0 || this.anchor.y !== 0)\n            {\n                let vertexCount = 0;\n\n                const anchorOffsetX = this._textWidth * this.anchor.x;\n                const anchorOffsetY = this._textHeight * this.anchor.y;\n\n                for (let i = 0; i < pageMeshData.total; i++)\n                {\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                }\n            }\n\n            this._maxLineHeight = maxLineHeight * scale;\n\n            const vertexBuffer = pageMeshData.mesh.geometry.getBuffer('aVertexPosition');\n            const textureBuffer = pageMeshData.mesh.geometry.getBuffer('aTextureCoord');\n            const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n\n            vertexBuffer.data = pageMeshData.vertices;\n            textureBuffer.data = pageMeshData.uvs;\n            indexBuffer.data = pageMeshData.indices;\n\n            vertexBuffer.update();\n            textureBuffer.update();\n            indexBuffer.update();\n        }\n\n        for (let i = 0; i < chars.length; i++)\n        {\n            charRenderDataPool.push(chars[i]);\n        }\n\n        this._font = data;\n        this.dirty = false;\n    }\n\n    updateTransform(): void\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        // Update the uniform\n        const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n\n        if (distanceFieldType !== 'none')\n        {\n            // Inject the shader code with the correct value\n            const { a, b, c, d } = this.worldTransform;\n\n            const dx = Math.sqrt((a * a) + (b * b));\n            const dy = Math.sqrt((c * c) + (d * d));\n            const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n            const fontScale = this.fontSize / size;\n\n            const resolution = renderer._view.resolution;\n\n            for (const mesh of this._activePagesMeshData)\n            {\n                mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n            }\n        }\n\n        super._render(renderer);\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     * @returns - The rectangular bounding area\n     */\n    public getLocalBounds(): Rectangle\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     * @private\n     */\n    protected validate(): void\n    {\n        const font = BitmapFont.available[this._fontName];\n\n        if (!font)\n        {\n            throw new Error(`Missing BitmapFont \"${this._fontName}\"`);\n        }\n        if (this._font !== font)\n        {\n            this.dirty = true;\n        }\n\n        if (this.dirty)\n        {\n            this.updateText();\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    public get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    public set tint(value: ColorSource)\n    {\n        if (this.tint === value) return;\n\n        this._tintColor.setValue(value);\n\n        for (let i = 0; i < this._activePagesMeshData.length; i++)\n        {\n            this._activePagesMeshData[i].mesh.tint = value;\n        }\n    }\n\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    public get align(): TextStyleAlign\n    {\n        return this._align;\n    }\n\n    public set align(value: TextStyleAlign)\n    {\n        if (this._align !== value)\n        {\n            this._align = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The name of the BitmapFont. */\n    public get fontName(): string\n    {\n        return this._fontName;\n    }\n\n    public set fontName(value: string)\n    {\n        if (!BitmapFont.available[value])\n        {\n            throw new Error(`Missing BitmapFont \"${value}\"`);\n        }\n\n        if (this._fontName !== value)\n        {\n            this._fontName = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The size of the font to display. */\n    public get fontSize(): number\n    {\n        return this._fontSize ?? BitmapFont.available[this._fontName].size;\n    }\n\n    public set fontSize(value: number | undefined)\n    {\n        if (this._fontSize !== value)\n        {\n            this._fontSize = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    public get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    public set anchor(value: ObservablePoint)\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copyFrom(value);\n        }\n    }\n\n    /** The text of the BitmapText object. */\n    public get text(): string\n    {\n        return this._text;\n    }\n\n    public set text(text: string)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    public get maxWidth(): number\n    {\n        return this._maxWidth;\n    }\n\n    public set maxWidth(value: number)\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    public get maxLineHeight(): number\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textWidth(): number\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /** Additional space between characters. */\n    public get letterSpacing(): number\n    {\n        return this._letterSpacing;\n    }\n\n    public set letterSpacing(value: number)\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    public get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    public set roundPixels(value: boolean)\n    {\n        if (value !== this._roundPixels)\n        {\n            this._roundPixels = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textHeight(): number\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n\n    destroy(options?: boolean | IDestroyOptions): void\n    {\n        const { _textureCache } = this;\n        const data = BitmapFont.available[this._fontName];\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        pageMeshDataPool.push(...this._activePagesMeshData);\n        for (const pageMeshData of this._activePagesMeshData)\n        {\n            this.removeChild(pageMeshData.mesh);\n        }\n        this._activePagesMeshData = [];\n\n        // Release references to any cached textures in page pool\n        pageMeshDataPool\n            .filter((page) => _textureCache[page.mesh.texture.baseTexture.uid])\n            .forEach((page) =>\n            {\n                page.mesh.texture = Texture.EMPTY;\n            });\n\n        for (const id in _textureCache)\n        {\n            const texture = _textureCache[id];\n\n            texture.destroy();\n            delete _textureCache[id];\n        }\n\n        this._font = null;\n        this._tintColor = null;\n        this._textureCache = null;\n\n        super.destroy(options);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}