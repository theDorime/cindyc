{"ast":null,"code":"import { Rectangle, utils, RenderTexture, ExtensionType, extensions } from '@pixi/core';\nconst TEMP_RECT = new Rectangle();\nconst BYTES_PER_PIXEL = 4;\nconst _Extract = class {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  async image(target, format, quality) {\n    const image = new Image();\n    image.src = await this.base64(target, format, quality);\n    return image;\n  }\n  async base64(target, format, quality) {\n    const canvas = this.canvas(target);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob(blob => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, format, quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(format, quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({\n        type: format,\n        quality\n      });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  canvas(target, frame) {\n    const {\n      pixels,\n      width,\n      height,\n      flipY\n    } = this._rawPixels(target, frame);\n    if (flipY) {\n      _Extract._flipY(pixels, width, height);\n    }\n    _Extract._unpremultiplyAlpha(pixels);\n    const canvasBuffer = new utils.CanvasRenderTarget(width, height, 1);\n    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);\n    canvasBuffer.context.putImageData(imageData, 0, 0);\n    return canvasBuffer.canvas;\n  }\n  pixels(target, frame) {\n    const {\n      pixels,\n      width,\n      height,\n      flipY\n    } = this._rawPixels(target, frame);\n    if (flipY) {\n      _Extract._flipY(pixels, width, height);\n    }\n    _Extract._unpremultiplyAlpha(pixels);\n    return pixels;\n  }\n  _rawPixels(target, frame) {\n    const renderer = this.renderer;\n    if (!renderer) {\n      throw new Error(\"The Extract has already been destroyed\");\n    }\n    let resolution;\n    let flipY = false;\n    let renderTexture;\n    let generated = false;\n    if (target) {\n      if (target instanceof RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = renderer.generateTexture(target, {\n          resolution: renderer.resolution,\n          multisample: renderer.multisample\n        });\n        generated = true;\n      }\n    }\n    if (renderTexture) {\n      resolution = renderTexture.baseTexture.resolution;\n      frame = frame ?? renderTexture.frame;\n      flipY = false;\n      if (!generated) {\n        renderer.renderTexture.bind(renderTexture);\n        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];\n        if (fbo.blitFramebuffer) {\n          renderer.framebuffer.bind(fbo.blitFramebuffer);\n        }\n      }\n    } else {\n      resolution = renderer.resolution;\n      if (!frame) {\n        frame = TEMP_RECT;\n        frame.width = renderer.width / resolution;\n        frame.height = renderer.height / resolution;\n      }\n      flipY = true;\n      renderer.renderTexture.bind();\n    }\n    const width = Math.round(frame.width * resolution);\n    const height = Math.round(frame.height * resolution);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const gl = renderer.gl;\n    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    if (generated) {\n      renderTexture?.destroy(true);\n    }\n    return {\n      pixels,\n      width,\n      height,\n      flipY\n    };\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  static _flipY(pixels, width, height) {\n    const w = width << 2;\n    const h = height >> 1;\n    const temp = new Uint8Array(w);\n    for (let y = 0; y < h; y++) {\n      const t = y * w;\n      const b = (height - y - 1) * w;\n      temp.set(pixels.subarray(t, t + w));\n      pixels.copyWithin(t, b, b + w);\n      pixels.set(temp, b);\n    }\n  }\n  static _unpremultiplyAlpha(pixels) {\n    if (pixels instanceof Uint8ClampedArray) {\n      pixels = new Uint8Array(pixels.buffer);\n    }\n    const n = pixels.length;\n    for (let i = 0; i < n; i += 4) {\n      const alpha = pixels[i + 3];\n      if (alpha !== 0) {\n        const a = 255.001 / alpha;\n        pixels[i] = pixels[i] * a + 0.5;\n        pixels[i + 1] = pixels[i + 1] * a + 0.5;\n        pixels[i + 2] = pixels[i + 2] * a + 0.5;\n      }\n    }\n  }\n};\nlet Extract = _Extract;\nExtract.extension = {\n  name: \"extract\",\n  type: ExtensionType.RendererSystem\n};\nextensions.add(Extract);\nexport { Extract };","map":{"version":3,"names":["TEMP_RECT","Rectangle","BYTES_PER_PIXEL","_Extract","constructor","renderer","image","target","format","quality","Image","src","base64","canvas","toBlob","Promise","resolve","reject","blob","Error","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","type","frame","pixels","width","height","flipY","_rawPixels","_flipY","_unpremultiplyAlpha","canvasBuffer","utils","CanvasRenderTarget","imageData","ImageData","Uint8ClampedArray","buffer","context","putImageData","resolution","renderTexture","generated","RenderTexture","generateTexture","multisample","baseTexture","bind","fbo","framebuffer","glFramebuffers","CONTEXT_UID","blitFramebuffer","Math","round","Uint8Array","gl","readPixels","x","y","RGBA","UNSIGNED_BYTE","destroy","w","h","temp","t","b","set","subarray","copyWithin","n","length","i","alpha","a","Extract","extension","name","ExtensionType","RendererSystem","extensions","add"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\extract\\src\\Extract.ts"],"sourcesContent":["import { extensions, ExtensionType, Rectangle, RenderTexture, utils } from '@pixi/core';\n\nimport type { ExtensionMetadata, ICanvas, ISystem, Renderer } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\n\nconst TEMP_RECT = new Rectangle();\nconst BYTES_PER_PIXEL = 4;\n\nexport interface IExtract\n{\n    image(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<HTMLImageElement>;\n    base64(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<string>;\n    canvas(target?: DisplayObject | RenderTexture, frame?: Rectangle): ICanvas;\n    pixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): Uint8Array | Uint8ClampedArray;\n}\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .beginFill(0xFF0000)\n *     .drawCircle(0, 0, 50);\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof PIXI\n */\n\nexport class Extract implements ISystem, IExtract\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'extract',\n        type: ExtensionType.RendererSystem,\n    };\n\n    private renderer: Renderer | null;\n\n    /**\n     * @param renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - HTML Image of the target\n     */\n    public async image(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(target, format, quality);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     *  `Extract.getCanvas` and then running toDataURL on that.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - A base64 encoded string of the texture.\n     */\n    public async base64(target?: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<string>\n    {\n        const canvas = this.canvas(target);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, format, quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(format, quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: format, quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(target?: DisplayObject | RenderTexture, frame?: Rectangle): ICanvas\n    {\n        const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n\n        // Flipping pixels\n        if (flipY)\n        {\n            Extract._flipY(pixels, width, height);\n        }\n\n        Extract._unpremultiplyAlpha(pixels);\n\n        const canvasBuffer = new utils.CanvasRenderTarget(width, height, 1);\n\n        // Add the pixels to the canvas\n        const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);\n\n        canvasBuffer.context.putImageData(imageData, 0, 0);\n\n        // Send the canvas back\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): Uint8Array\n    {\n        const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n\n        if (flipY)\n        {\n            Extract._flipY(pixels, width, height);\n        }\n\n        Extract._unpremultiplyAlpha(pixels);\n\n        return pixels;\n    }\n\n    private _rawPixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): {\n        pixels: Uint8Array, width: number, height: number, flipY: boolean,\n    }\n    {\n        const renderer = this.renderer;\n\n        if (!renderer)\n        {\n            throw new Error('The Extract has already been destroyed');\n        }\n\n        let resolution;\n        let flipY = false;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = renderer.generateTexture(target, {\n                    resolution: renderer.resolution,\n                    multisample: renderer.multisample\n                });\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            resolution = renderTexture.baseTexture.resolution;\n            frame = frame ?? renderTexture.frame;\n            flipY = false;\n\n            if (!generated)\n            {\n                renderer.renderTexture.bind(renderTexture);\n\n                const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];\n\n                if (fbo.blitFramebuffer)\n                {\n                    renderer.framebuffer.bind(fbo.blitFramebuffer);\n                }\n            }\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!frame)\n            {\n                frame = TEMP_RECT;\n                frame.width = renderer.width / resolution;\n                frame.height = renderer.height / resolution;\n            }\n\n            flipY = true;\n            renderer.renderTexture.bind();\n        }\n\n        const width = Math.round(frame.width * resolution);\n        const height = Math.round(frame.height * resolution);\n\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        // Read pixels to the array\n        const gl = renderer.gl;\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        if (generated)\n        {\n            renderTexture?.destroy(true);\n        }\n\n        return { pixels, width, height, flipY };\n    }\n\n    /** Destroys the extract. */\n    public destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    private static _flipY(pixels: Uint8Array | Uint8ClampedArray, width: number, height: number): void\n    {\n        const w = width << 2;\n        const h = height >> 1;\n        const temp = new Uint8Array(w);\n\n        for (let y = 0; y < h; y++)\n        {\n            const t = y * w;\n            const b = (height - y - 1) * w;\n\n            temp.set(pixels.subarray(t, t + w));\n            pixels.copyWithin(t, b, b + w);\n            pixels.set(temp, b);\n        }\n    }\n\n    private static _unpremultiplyAlpha(pixels: Uint8Array | Uint8ClampedArray): void\n    {\n        if (pixels instanceof Uint8ClampedArray)\n        {\n            pixels = new Uint8Array(pixels.buffer);\n        }\n\n        const n = pixels.length;\n\n        for (let i = 0; i < n; i += 4)\n        {\n            const alpha = pixels[i + 3];\n\n            if (alpha !== 0)\n            {\n                const a = 255.001 / alpha;\n\n                pixels[i] = (pixels[i] * a) + 0.5;\n                pixels[i + 1] = (pixels[i + 1] * a) + 0.5;\n                pixels[i + 2] = (pixels[i + 2] * a) + 0.5;\n            }\n        }\n    }\n}\n\nextensions.add(Extract);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}