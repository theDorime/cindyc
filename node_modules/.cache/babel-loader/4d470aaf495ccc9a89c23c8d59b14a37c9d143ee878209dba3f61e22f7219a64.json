{"ast":null,"code":"import { settings } from '@pixi/settings';\nimport { uid } from '@pixi/utils';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nconst _SVGResource = class extends BaseImageResource {\n  constructor(sourceBase64, options) {\n    options = options || {};\n    super(settings.ADAPTER.createCanvas());\n    this._width = 0;\n    this._height = 0;\n    this.svg = sourceBase64;\n    this.scale = options.scale || 1;\n    this._overrideWidth = options.width;\n    this._overrideHeight = options.height;\n    this._resolve = null;\n    this._crossorigin = options.crossorigin;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise(resolve => {\n      this._resolve = () => {\n        this.resize(this.source.width, this.source.height);\n        resolve(this);\n      };\n      if (_SVGResource.SVG_XML.test(this.svg.trim())) {\n        if (!btoa) {\n          throw new Error(\"Your browser doesn't support base64 conversions.\");\n        }\n        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n      }\n      this._loadSvg();\n    });\n    return this._load;\n  }\n  _loadSvg() {\n    const tempImage = new Image();\n    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n    tempImage.src = this.svg;\n    tempImage.onerror = event => {\n      if (!this._resolve) {\n        return;\n      }\n      tempImage.onerror = null;\n      this.onError.emit(event);\n    };\n    tempImage.onload = () => {\n      if (!this._resolve) {\n        return;\n      }\n      const svgWidth = tempImage.width;\n      const svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight) {\n        throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n      }\n      let width = svgWidth * this.scale;\n      let height = svgHeight * this.scale;\n      if (this._overrideWidth || this._overrideHeight) {\n        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n      }\n      width = Math.round(width);\n      height = Math.round(height);\n      const canvas = this.source;\n      canvas.width = width;\n      canvas.height = height;\n      canvas._pixiId = `canvas_${uid()}`;\n      canvas.getContext(\"2d\").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n      this._resolve();\n      this._resolve = null;\n    };\n  }\n  static getSize(svgString) {\n    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);\n    const size = {};\n    if (sizeMatch) {\n      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n    }\n    return size;\n  }\n  dispose() {\n    super.dispose();\n    this._resolve = null;\n    this._crossorigin = null;\n  }\n  static test(source, extension) {\n    return extension === \"svg\" || typeof source === \"string\" && source.startsWith(\"data:image/svg+xml\") || typeof source === \"string\" && _SVGResource.SVG_XML.test(source);\n  }\n};\nlet SVGResource = _SVGResource;\nSVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\nSVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i;\nexport { SVGResource };","map":{"version":3,"names":["_SVGResource","BaseImageResource","constructor","sourceBase64","options","settings","ADAPTER","createCanvas","_width","_height","svg","scale","_overrideWidth","width","_overrideHeight","height","_resolve","_crossorigin","crossorigin","_load","autoLoad","load","Promise","resolve","resize","source","SVG_XML","test","trim","btoa","Error","unescape","encodeURIComponent","_loadSvg","tempImage","Image","crossOrigin","src","onerror","event","onError","emit","onload","svgWidth","svgHeight","Math","round","canvas","_pixiId","uid","getContext","drawImage","getSize","svgString","sizeMatch","SVG_SIZE","exec","size","parseFloat","dispose","extension","startsWith","SVGResource"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\textures\\resources\\SVGResource.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\nimport { uid } from '@pixi/utils';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { ICanvas } from '@pixi/settings';\n\nexport interface ISVGResourceOptions\n{\n    source?: string;\n    scale?: number;\n    width?: number;\n    height?: number;\n    autoLoad?: boolean;\n    crossorigin?: boolean | string;\n}\n/**\n * Resource type for SVG elements and graphics.\n * @memberof PIXI\n */\nexport class SVGResource extends BaseImageResource\n{\n    /** Base64 encoded SVG element or URL for SVG file. */\n    public readonly svg: string;\n\n    /** The source scale to apply when rasterizing on load. */\n    public readonly scale: number;\n\n    /** A width override for rasterization on load. */\n    public readonly _overrideWidth: number;\n\n    /** A height override for rasterization on load. */\n    public readonly _overrideHeight: number;\n\n    /** Call when completely loaded. */\n    private _resolve: () => void;\n\n    /** Promise when loading */\n    private _load: Promise<this>;\n\n    /** Cross origin value to use */\n    private _crossorigin?: boolean | string;\n\n    /**\n     * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.\n     * @param {object} [options] - Options to use\n     * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...\n     * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.\n     * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.\n     * @param {boolean} [options.autoLoad=true] - Start loading right away.\n     */\n    constructor(sourceBase64: string, options?: ISVGResourceOptions)\n    {\n        options = options || {};\n\n        super(settings.ADAPTER.createCanvas());\n        this._width = 0;\n        this._height = 0;\n\n        this.svg = sourceBase64;\n        this.scale = options.scale || 1;\n        this._overrideWidth = options.width;\n        this._overrideHeight = options.height;\n\n        this._resolve = null;\n        this._crossorigin = options.crossorigin;\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = new Promise((resolve): void =>\n        {\n            // Save this until after load is finished\n            this._resolve = (): void =>\n            {\n                this.resize(this.source.width, this.source.height);\n                resolve(this);\n            };\n\n            // Convert SVG inline string to data-uri\n            if (SVGResource.SVG_XML.test(this.svg.trim()))\n            {\n                if (!btoa)\n                {\n                    throw new Error('Your browser doesn\\'t support base64 conversions.');\n                }\n                (this as any).svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n            }\n\n            this._loadSvg();\n        });\n\n        return this._load;\n    }\n\n    /** Loads an SVG image from `imageUrl` or `data URL`. */\n    private _loadSvg(): void\n    {\n        const tempImage = new Image();\n\n        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n        tempImage.src = this.svg;\n\n        tempImage.onerror = (event): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            tempImage.onerror = null;\n            this.onError.emit(event);\n        };\n\n        tempImage.onload = (): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            const svgWidth = tempImage.width;\n            const svgHeight = tempImage.height;\n\n            if (!svgWidth || !svgHeight)\n            {\n                throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');\n            }\n\n            // Set render size\n            let width = svgWidth * this.scale;\n            let height = svgHeight * this.scale;\n\n            if (this._overrideWidth || this._overrideHeight)\n            {\n                width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n                height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n            }\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // Create a canvas element\n            const canvas = this.source as ICanvas;\n\n            canvas.width = width;\n            canvas.height = height;\n            (canvas as any)._pixiId = `canvas_${uid()}`;\n\n            // Draw the Svg to the canvas\n            canvas\n                .getContext('2d')\n                .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n\n            this._resolve();\n            this._resolve = null;\n        };\n    }\n\n    /**\n     * Get size from an svg string using a regular expression.\n     * @param svgString - a serialized svg element\n     * @returns - image extension\n     */\n    static getSize(svgString?: string): ISize\n    {\n        const sizeMatch = SVGResource.SVG_SIZE.exec(svgString);\n        const size: any = {};\n\n        if (sizeMatch)\n        {\n            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n        }\n\n        return size;\n    }\n\n    /** Destroys this texture. */\n    dispose(): void\n    {\n        super.dispose();\n        this._resolve = null;\n        this._crossorigin = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @param {string} extension - The extension of source, if set\n     * @returns {boolean} - If the source is a SVG source or data file\n     */\n    static test(source: unknown, extension?: string): boolean\n    {\n        // url file extension is SVG\n        return extension === 'svg'\n            // source is SVG data-uri\n            || (typeof source === 'string' && source.startsWith('data:image/svg+xml'))\n            // source is SVG inline\n            || (typeof source === 'string' && SVGResource.SVG_XML.test(source));\n    }\n\n    /**\n     * Regular expression for SVG XML document.\n     * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n     * @readonly\n     */\n    static SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\n\n    /**\n     * Regular expression for SVG size.\n     * @example &lt;svg width=\"100\" height=\"100\"&gt;&lt;/svg&gt;\n     * @readonly\n     */\n    static SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i; // eslint-disable-line max-len\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}