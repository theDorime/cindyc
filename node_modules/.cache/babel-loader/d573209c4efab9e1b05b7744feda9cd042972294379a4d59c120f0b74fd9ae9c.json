{"ast":null,"code":"import { SHAPES } from '@pixi/core';\nconst buildCircle = {\n  build(graphicsData) {\n    const points = graphicsData.points;\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (graphicsData.type === SHAPES.CIRC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      const ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      const roundedRect = graphicsData.shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    {\n      const x0 = dx + rx;\n      const y0 = dy;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        const y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x0 = dx + Math.cos(a) * rx;\n      const y0 = dy + Math.sin(a) * ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n    {\n      const x0 = dx;\n      const y0 = dy + ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    let vertPos = verts.length / 2;\n    const center = vertPos;\n    let x;\n    let y;\n    if (graphicsData.type !== SHAPES.RREC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      const roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    const matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (let i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\nexport { buildCircle };","map":{"version":3,"names":["buildCircle","build","graphicsData","points","x","y","dx","dy","rx","ry","type","SHAPES","CIRC","circle","shape","radius","ELIP","ellipse","width","height","roundedRect","halfWidth","halfHeight","Math","max","min","length","n","ceil","sqrt","m","j1","j2","j3","j4","x0","y0","x1","x2","y1","y2","i","a","PI","cos","sin","triangulate","graphicsGeometry","verts","indices","vertPos","center","RREC","matrix","push","c","tx","b","d","ty"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\graphics\\src\\utils\\buildCircle.ts"],"sourcesContent":["// for type only\nimport { SHAPES } from '@pixi/core';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}