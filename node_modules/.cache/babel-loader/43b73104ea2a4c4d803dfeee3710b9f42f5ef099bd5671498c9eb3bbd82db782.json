{"ast":null,"code":"import { Matrix, ObjectRenderer, QuadUv, State, Shader, WRAP_MODES, Color, utils, ExtensionType, extensions } from '@pixi/core';\nimport gl2FragmentSrc from './sprite-tiling.mjs';\nimport gl2VertexSrc from './sprite-tiling2.mjs';\nimport gl1FragmentSrc from './sprite-tiling-fallback.mjs';\nimport gl1VertexSrc from './sprite-tiling-fallback2.mjs';\nimport fragmentSimpleSrc from './sprite-tiling-simple.mjs';\nconst tempMat = new Matrix();\nclass TilingSpriteRenderer extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    renderer.runners.contextChange.add(this);\n    this.quad = new QuadUv();\n    this.state = State.for2d();\n  }\n  contextChange() {\n    const renderer = this.renderer;\n    const uniforms = {\n      globals: renderer.globalUniforms\n    };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  }\n  render(ts) {\n    const renderer = this.renderer;\n    const quad = this.quad;\n    let vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs;\n    vertices[0] = vertices[6] = -anchorX;\n    vertices[1] = vertices[3] = -anchorY;\n    vertices[2] = vertices[4] = 1 - anchorX;\n    vertices[5] = vertices[7] = 1 - anchorY;\n    quad.invalidate();\n    const tex = ts._texture;\n    const baseTex = tex.baseTexture;\n    const premultiplied = baseTex.alphaMode > 0;\n    const lt = ts.tileTransform.localTransform;\n    const uv = ts.uvMatrix;\n    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === WRAP_MODES.CLAMP) {\n          baseTex.wrapMode = WRAP_MODES.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n      }\n    }\n    const shader = isSimple ? this.simpleShader : this.shader;\n    const w = tex.width;\n    const h = tex.height;\n    const W = ts._width;\n    const H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n    tempMat.invert();\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = tex;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(quad);\n    this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }\n}\nTilingSpriteRenderer.extension = {\n  name: \"tilingSprite\",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(TilingSpriteRenderer);\nexport { TilingSpriteRenderer };","map":{"version":3,"names":["tempMat","Matrix","TilingSpriteRenderer","ObjectRenderer","constructor","renderer","runners","contextChange","add","quad","QuadUv","state","State","for2d","uniforms","globals","globalUniforms","simpleShader","Shader","from","gl1VertexSrc","fragmentSimpleSrc","shader","context","webGLVersion","gl2VertexSrc","gl2FragmentSrc","gl1FragmentSrc","render","ts","vertices","_width","anchor","x","_height","y","anchorX","uvRespectAnchor","anchorY","uvs","invalidate","tex","_texture","baseTex","baseTexture","premultiplied","alphaMode","lt","tileTransform","localTransform","uv","uvMatrix","isSimple","isPowerOfTwo","frame","width","height","_glTextures","CONTEXT_UID","wrapMode","WRAP_MODES","CLAMP","REPEAT","w","h","W","H","set","a","b","c","d","tx","ty","invert","prepend","mapCoord","uMapCoord","toArray","uClampFrame","uClampOffset","uTransform","uColor","Color","shared","setValue","tint","premultiply","worldAlpha","translationMatrix","transform","worldTransform","uSampler","bind","geometry","blendMode","utils","correctBlendMode","draw","gl","TRIANGLES","extension","name","type","ExtensionType","RendererPlugin","extensions"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\sprite-tiling\\src\\TilingSpriteRenderer.ts"],"sourcesContent":["import {\n    Color,\n    extensions,\n    ExtensionType,\n    Matrix,\n    ObjectRenderer,\n    QuadUv,\n    Shader,\n    State,\n    utils,\n    WRAP_MODES\n} from '@pixi/core';\nimport gl2FragmentSrc from './sprite-tiling.frag';\nimport gl2VertexSrc from './sprite-tiling.vert';\nimport gl1FragmentSrc from './sprite-tiling-fallback.frag';\nimport gl1VertexSrc from './sprite-tiling-fallback.vert';\nimport fragmentSimpleSrc from './sprite-tiling-simple.frag';\n\nimport type { ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { TilingSprite } from './TilingSprite';\n\nconst tempMat = new Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport class TilingSpriteRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'tilingSprite',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    public shader: Shader;\n    public simpleShader: Shader;\n    public quad: QuadUv;\n    public readonly state: State;\n\n    /**\n     * constructor for renderer\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // WebGL version is not available during initialization!\n        renderer.runners.contextChange.add(this);\n\n        this.quad = new QuadUv();\n\n        /**\n         * The WebGL state in which this renderer will work.\n         * @member {PIXI.State}\n         * @readonly\n         */\n        this.state = State.for2d();\n    }\n\n    /** Creates shaders when context is initialized. */\n    contextChange(): void\n    {\n        const renderer = this.renderer;\n        const uniforms = { globals: renderer.globalUniforms };\n\n        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n        this.shader = renderer.context.webGLVersion > 1\n            ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms)\n            : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n    }\n\n    /**\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */\n    public render(ts: TilingSprite): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n        const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n\n        vertices = quad.uvs;\n\n        vertices[0] = vertices[6] = -anchorX;\n        vertices[1] = vertices[3] = -anchorY;\n\n        vertices[2] = vertices[4] = 1.0 - anchorX;\n        vertices[5] = vertices[7] = 1.0 - anchorY;\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const premultiplied = baseTex.alphaMode > 0;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = Color.shared\n            .setValue(ts.tint)\n            .premultiply(ts.worldAlpha, premultiplied)\n            .toArray(shader.uniforms.uColor);\n\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);\n\n        this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n\nextensions.add(TilingSpriteRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}