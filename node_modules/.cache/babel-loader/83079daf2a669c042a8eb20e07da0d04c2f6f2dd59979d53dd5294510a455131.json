{"ast":null,"code":"import { Runner } from '@pixi/runner';\nimport { Program } from './Program.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\nclass Shader {\n  constructor(program, uniforms) {\n    this.uniformBindCount = 0;\n    this.program = program;\n    if (uniforms) {\n      if (uniforms instanceof UniformGroup) {\n        this.uniformGroup = uniforms;\n      } else {\n        this.uniformGroup = new UniformGroup(uniforms);\n      }\n    } else {\n      this.uniformGroup = new UniformGroup({});\n    }\n    this.disposeRunner = new Runner(\"disposeShader\");\n  }\n  checkUniformExists(name, group) {\n    if (group.uniforms[name]) {\n      return true;\n    }\n    for (const i in group.uniforms) {\n      const uniform = group.uniforms[i];\n      if (uniform.group) {\n        if (this.checkUniformExists(name, uniform)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  destroy() {\n    this.uniformGroup = null;\n    this.disposeRunner.emit(this);\n    this.disposeRunner.destroy();\n  }\n  get uniforms() {\n    return this.uniformGroup.uniforms;\n  }\n  static from(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(vertexSrc, fragmentSrc);\n    return new Shader(program, uniforms);\n  }\n}\nexport { Shader };","map":{"version":3,"names":["Shader","constructor","program","uniforms","uniformBindCount","UniformGroup","uniformGroup","disposeRunner","Runner","checkUniformExists","name","group","i","uniform","destroy","emit","from","vertexSrc","fragmentSrc","Program"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\shader\\Shader.ts"],"sourcesContent":["import { Runner } from '@pixi/runner';\nimport { Program } from './Program';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { Dict } from '@pixi/utils';\n\n/**\n * A helper class for shaders.\n * @memberof PIXI\n */\nexport class Shader\n{\n    /** Program that the shader uses. */\n    public program: Program;\n    public uniformGroup: UniformGroup;\n\n    /**\n     * Used internally to bind uniform buffer objects.\n     * @ignore\n     */\n    uniformBindCount = 0;\n\n    disposeRunner: Runner;\n\n    /**\n     * @param program - The program the shader will use.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(program: Program, uniforms?: Dict<any>)\n    {\n        this.program = program;\n\n        // lets see whats been passed in\n        // uniforms should be converted to a uniform group\n        if (uniforms)\n        {\n            if (uniforms instanceof UniformGroup)\n            {\n                this.uniformGroup = uniforms;\n            }\n            else\n            {\n                this.uniformGroup = new UniformGroup(uniforms);\n            }\n        }\n        else\n        {\n            this.uniformGroup = new UniformGroup({});\n        }\n\n        this.disposeRunner = new Runner('disposeShader');\n    }\n\n    // TODO move to shader system..\n    checkUniformExists(name: string, group: UniformGroup): boolean\n    {\n        if (group.uniforms[name])\n        {\n            return true;\n        }\n\n        for (const i in group.uniforms)\n        {\n            const uniform = group.uniforms[i];\n\n            if (uniform.group)\n            {\n                if (this.checkUniformExists(name, uniform))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    destroy(): void\n    {\n        // usage count on programs?\n        // remove if not used!\n        this.uniformGroup = null;\n\n        this.disposeRunner.emit(this);\n        this.disposeRunner.destroy();\n    }\n\n    /**\n     * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n     * @readonly\n     */\n    get uniforms(): Dict<any>\n    {\n        return this.uniformGroup.uniforms;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     * @returns A shiny new PixiJS shader!\n     */\n    static from(vertexSrc?: string, fragmentSrc?: string, uniforms?: Dict<any>): Shader\n    {\n        const program = Program.from(vertexSrc, fragmentSrc);\n\n        return new Shader(program, uniforms);\n    }\n}\n"],"mappings":";;;AAUO,MAAMA,MACb;EAiBIC,YAAYC,OAAA,EAAkBC,QAC9B;IATmB,KAAAC,gBAAA;IAUf,KAAKF,OAAU,GAAAA,OAAA;IAIf,IAAIC,QACJ;MACI,IAAIA,QAAA,YAAoBE,YACxB;QACI,KAAKC,YAAe,GAAAH,QAAA;MAAA,CAGxB;QACS,KAAAG,YAAA,GAAe,IAAID,YAAA,CAAaF,QAAQ;MAAA;IACjD,CAGJ;MACI,KAAKG,YAAe,OAAID,YAAa,GAAE;IAAA;IAGtC,KAAAE,aAAA,GAAgB,IAAIC,MAAA,CAAO,eAAe;EAAA;EAInDC,mBAAmBC,IAAA,EAAcC,KACjC;IACQ,IAAAA,KAAA,CAAMR,QAAA,CAASO,IACnB;MACW;IAAA;IAGA,WAAAE,CAAA,IAAKD,KAAA,CAAMR,QACtB;MACU,MAAAU,OAAA,GAAUF,KAAA,CAAMR,QAAS,CAAAS,CAAA;MAE/B,IAAIC,OAAA,CAAQF,KACZ;QACI,IAAI,IAAK,CAAAF,kBAAA,CAAmBC,IAAM,EAAAG,OAAO,CACzC;UACW;QAAA;MACX;IACJ;IAGG;EAAA;EAGXC,OACAA,CAAA;IAGI,KAAKR,YAAe;IAEf,KAAAC,aAAA,CAAcQ,IAAA,CAAK,IAAI;IAC5B,KAAKR,aAAA,CAAcO,OAAQ;EAAA;EAO/B,IAAIX,QACJA,CAAA;IACI,OAAO,KAAKG,YAAa,CAAAH,QAAA;EAAA;EAU7B,OAAOa,KAAKC,SAAoB,EAAAC,WAAA,EAAsBf,QACtD;IACI,MAAMD,OAAU,GAAAiB,OAAA,CAAQH,IAAK,CAAAC,SAAA,EAAWC,WAAW;IAE5C,WAAIlB,MAAO,CAAAE,OAAA,EAASC,QAAQ;EAAA;AAE3C"},"metadata":{},"sourceType":"module","externalDependencies":[]}