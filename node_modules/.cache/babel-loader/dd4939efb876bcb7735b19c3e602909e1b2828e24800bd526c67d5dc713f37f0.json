{"ast":null,"code":"import { BufferResource, ViewableBuffer } from '@pixi/core';\nclass BlobResource extends BufferResource {\n  constructor(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      width: 1,\n      height: 1,\n      autoLoad: true\n    };\n    let origin;\n    let data;\n    if (typeof source === \"string\") {\n      origin = source;\n      data = new Uint8Array();\n    } else {\n      origin = null;\n      data = source;\n    }\n    super(data, options);\n    this.origin = origin;\n    this.buffer = data ? new ViewableBuffer(data) : null;\n    this._load = null;\n    this.loaded = false;\n    if (this.origin !== null && options.autoLoad !== false) {\n      this.load();\n    }\n    if (this.origin === null && this.buffer) {\n      this._load = Promise.resolve(this);\n      this.loaded = true;\n      this.onBlobLoaded(this.buffer.rawBinaryData);\n    }\n  }\n  onBlobLoaded(_data) {}\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = fetch(this.origin).then(response => response.blob()).then(blob => blob.arrayBuffer()).then(arrayBuffer => {\n      this.data = new Uint32Array(arrayBuffer);\n      this.buffer = new ViewableBuffer(arrayBuffer);\n      this.loaded = true;\n      this.onBlobLoaded(arrayBuffer);\n      this.update();\n      return this;\n    });\n    return this._load;\n  }\n}\nexport { BlobResource };","map":{"version":3,"names":["BlobResource","BufferResource","constructor","source","options","arguments","length","undefined","width","height","autoLoad","origin","data","Uint8Array","buffer","ViewableBuffer","_load","loaded","load","Promise","resolve","onBlobLoaded","rawBinaryData","_data","fetch","then","response","blob","arrayBuffer","Uint32Array","update"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\compressed-textures\\src\\resources\\BlobResource.ts"],"sourcesContent":["import { BufferResource, ViewableBuffer } from '@pixi/core';\n\ninterface IBlobOptions\n{\n    autoLoad?: boolean;\n    width: number;\n    height: number;\n}\n\n/**\n * Resource that fetches texture data over the network and stores it in a buffer.\n * @class\n * @extends PIXI.Resource\n * @memberof PIXI\n */\nexport abstract class BlobResource extends BufferResource\n{\n    protected origin: string | null;\n    protected buffer: ViewableBuffer | null;\n    protected loaded: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /**\n     * @param source - the buffer/URL of the texture file\n     * @param {PIXI.IBlobOptions} options\n     * @param {boolean}[options.autoLoad] - whether to fetch the data immediately;\n     *  you can fetch it later via {@link PIXI.BlobResource#load}\n     * @param {boolean}[options.width] - the width in pixels.\n     * @param {boolean}[options.height] - the height in pixels.\n     */\n    constructor(source: string | Uint8Array | Uint32Array | Float32Array | null,\n        options: IBlobOptions = { width: 1, height: 1, autoLoad: true })\n    {\n        let origin: string | null;\n        let data: Uint8Array | Uint32Array | Float32Array;\n\n        if (typeof source === 'string')\n        {\n            origin = source;\n            data = new Uint8Array();\n        }\n        else\n        {\n            origin = null;\n            data = source;\n        }\n\n        super(data, options);\n\n        /**\n         * The URL of the texture file\n         * @type {string|null}\n         */\n        this.origin = origin;\n\n        /**\n         * The viewable buffer on the data\n         * @type {ViewableBuffer|null}\n         */\n        // HINT: BlobResource allows \"null\" sources, assuming the child class provides an alternative\n        this.buffer = data ? new ViewableBuffer(data) : null;\n\n        this._load = null;\n        this.loaded = false;\n\n        // Allow autoLoad = \"undefined\" still load the resource by default\n        if (this.origin !== null && options.autoLoad !== false)\n        {\n            this.load();\n        }\n        if (this.origin === null && this.buffer)\n        {\n            this._load = Promise.resolve(this);\n            this.loaded = true;\n            this.onBlobLoaded(this.buffer.rawBinaryData);\n        }\n    }\n\n    protected onBlobLoaded(_data: ArrayBuffer): void\n    {\n        // TODO: Override this method\n    }\n\n    /** Loads the blob */\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = fetch(this.origin)\n            .then((response) => response.blob())\n            .then((blob) => blob.arrayBuffer())\n            .then((arrayBuffer) =>\n            {\n                this.data = new Uint32Array(arrayBuffer);\n                this.buffer = new ViewableBuffer(arrayBuffer);\n                this.loaded = true;\n\n                this.onBlobLoaded(arrayBuffer);\n                this.update();\n\n                return this;\n            });\n\n        return this._load;\n    }\n}\n"],"mappings":";AAeO,MAAeA,YAAA,SAAqBC,cAC3C;EAmBIC,YAAYC,MACR,EACJ;IAAA,IADIC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAwB;MAAEG,KAAA,EAAO;MAAGC,MAAQ;MAAGC,QAAU;IAAA,CAC7D;IACQ,IAAAC,MAAA;IACA,IAAAC,IAAA;IAEA,WAAOT,MAAA,KAAW,QACtB;MACaQ,MAAA,GAAAR,MAAA;MACTS,IAAA,GAAO,IAAIC,UAAW;IAAA,CAG1B;MACaF,MAAA;MACFC,IAAA,GAAAT,MAAA;IAAA;IAGX,MAAMS,IAAA,EAAMR,OAAO;IAMnB,KAAKO,MAAS,GAAAA,MAAA;IAOd,KAAKG,MAAS,GAAAF,IAAA,GAAO,IAAIG,cAAA,CAAeH,IAAI,CAAI;IAEhD,KAAKI,KAAQ;IACb,KAAKC,MAAS;IAGd,IAAI,IAAK,CAAAN,MAAA,KAAW,IAAQ,IAAAP,OAAA,CAAQM,QAAA,KAAa,KACjD;MACI,KAAKQ,IAAK;IAAA;IAEd,IAAI,IAAK,CAAAP,MAAA,KAAW,IAAQ,SAAKG,MACjC;MACS,KAAAE,KAAA,GAAQG,OAAQ,CAAAC,OAAA,CAAQ,IAAI;MACjC,KAAKH,MAAS;MACT,KAAAI,YAAA,CAAa,IAAK,CAAAP,MAAA,CAAOQ,aAAa;IAAA;EAC/C;EAGMD,aAAaE,KACvB;EAKAL,IACAA,CAAA;IACI,IAAI,KAAKF,KACT;MACI,OAAO,IAAK,CAAAA,KAAA;IAAA;IAGX,KAAAA,KAAA,GAAQQ,KAAA,CAAM,IAAK,CAAAb,MAAM,EACzBc,IAAK,CAACC,QAAA,IAAaA,QAAS,CAAAC,IAAA,EAAM,CAClC,CAAAF,IAAA,CAAME,IAAS,IAAAA,IAAA,CAAKC,WAAA,EAAa,EACjCH,IAAK,CAACG,WACP;MACS,KAAAhB,IAAA,GAAO,IAAIiB,WAAA,CAAYD,WAAW;MAClC,KAAAd,MAAA,GAAS,IAAIC,cAAA,CAAea,WAAW;MAC5C,KAAKX,MAAS;MAEd,KAAKI,YAAA,CAAaO,WAAW;MAC7B,KAAKE,MAAO;MAEL;IAAA,CACV;IAEL,OAAO,IAAK,CAAAd,KAAA;EAAA;AAEpB"},"metadata":{},"sourceType":"module","externalDependencies":[]}