{"ast":null,"code":"import { ExtensionType, settings, extensions as extensions$1 } from '@pixi/core';\nlet storedGl;\nlet extensions;\nfunction getCompressedTextureExtensions() {\n  extensions = {\n    s3tc: storedGl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n    s3tc_sRGB: storedGl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n    etc: storedGl.getExtension(\"WEBGL_compressed_texture_etc\"),\n    etc1: storedGl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n    pvrtc: storedGl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || storedGl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n    atc: storedGl.getExtension(\"WEBGL_compressed_texture_atc\"),\n    astc: storedGl.getExtension(\"WEBGL_compressed_texture_astc\")\n  };\n}\nconst detectCompressedTextures = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 2\n  },\n  test: async () => {\n    const canvas = settings.ADAPTER.createCanvas();\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      console.warn(\"WebGL not available for compressed textures.\");\n      return false;\n    }\n    storedGl = gl;\n    return true;\n  },\n  add: async formats => {\n    if (!extensions) getCompressedTextureExtensions();\n    const textureFormats = [];\n    for (const extensionName in extensions) {\n      const extension = extensions[extensionName];\n      if (!extension) {\n        continue;\n      }\n      textureFormats.push(extensionName);\n    }\n    return [...textureFormats, ...formats];\n  },\n  remove: async formats => {\n    if (!extensions) getCompressedTextureExtensions();\n    return formats.filter(f => !(f in extensions));\n  }\n};\nextensions$1.add(detectCompressedTextures);\nexport { detectCompressedTextures };","map":{"version":3,"names":["storedGl","extensions","getCompressedTextureExtensions","s3tc","getExtension","s3tc_sRGB","etc","etc1","pvrtc","atc","astc","detectCompressedTextures","extension","type","ExtensionType","DetectionParser","priority","test","canvas","settings","ADAPTER","createCanvas","gl","getContext","console","warn","add","formats","textureFormats","extensionName","push","remove","filter","f","extensions$1"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\compressed-textures\\src\\loaders\\detectCompressedTextures.ts"],"sourcesContent":["import { extensions as ext, ExtensionType, settings } from '@pixi/core';\n\nimport type { FormatDetectionParser } from '@pixi/assets';\nimport type { CompressedTextureExtensionRef, CompressedTextureExtensions } from './compressedTextureExtensions';\n\nlet storedGl: WebGLRenderingContext;\nlet extensions: Partial<CompressedTextureExtensions>;\n\nfunction getCompressedTextureExtensions()\n{\n    extensions = {\n        s3tc: storedGl.getExtension('WEBGL_compressed_texture_s3tc'),\n        s3tc_sRGB: storedGl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n        etc: storedGl.getExtension('WEBGL_compressed_texture_etc'),\n        etc1: storedGl.getExtension('WEBGL_compressed_texture_etc1'),\n        pvrtc: storedGl.getExtension('WEBGL_compressed_texture_pvrtc')\n            || storedGl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n        atc: storedGl.getExtension('WEBGL_compressed_texture_atc'),\n        astc: storedGl.getExtension('WEBGL_compressed_texture_astc')\n    } as Partial<CompressedTextureExtensions>;\n}\n\nexport const detectCompressedTextures = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 2,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        const canvas = settings.ADAPTER.createCanvas();\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            // #if _DEBUG\n            console.warn('WebGL not available for compressed textures.');\n            // #endif\n\n            return false;\n        }\n\n        storedGl = gl;\n\n        return true;\n    },\n    add: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        const textureFormats = [];\n\n        // Assign all available compressed-texture formats\n        for (const extensionName in extensions)\n        {\n            const extension = extensions[extensionName as CompressedTextureExtensionRef];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            textureFormats.push(extensionName);\n        }\n\n        return [...textureFormats, ...formats];\n    },\n    remove: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        return formats.filter((f) => !(f in extensions));\n    },\n} as FormatDetectionParser;\n\next.add(detectCompressedTextures);\n"],"mappings":";AAKA,IAAIA,QAAA;AACJ,IAAIC,UAAA;AAEJ,SACAC,+BAAA;EACiBD,UAAA;IACTE,IAAA,EAAMH,QAAS,CAAAI,YAAA,CAAa,+BAA+B;IAC3DC,SAAA,EAAWL,QAAS,CAAAI,YAAA,CAAa,oCAAoC;IACrEE,GAAA,EAAKN,QAAS,CAAAI,YAAA,CAAa,8BAA8B;IACzDG,IAAA,EAAMP,QAAS,CAAAI,YAAA,CAAa,+BAA+B;IAC3DI,KAAA,EAAOR,QAAS,CAAAI,YAAA,CAAa,gCAAgC,CACtD,IAAAJ,QAAA,CAASI,YAAA,CAAa,uCAAuC;IACpEK,GAAA,EAAKT,QAAS,CAAAI,YAAA,CAAa,8BAA8B;IACzDM,IAAA,EAAMV,QAAS,CAAAI,YAAA,CAAa,+BAA+B;EAAA,CAC/D;AACJ;AAEO,MAAMO,wBAA2B;EACpCC,SAAW;IACPC,IAAA,EAAMC,aAAc,CAAAC,eAAA;IACpBC,QAAU;EAAA,CACd;EACAC,IAAA,EAAM,MAAAA,CAAA,KACN;IAEU,MAAAC,MAAA,GAASC,QAAS,CAAAC,OAAA,CAAQC,YAAa;IACvC,MAAAC,EAAA,GAAKJ,MAAO,CAAAK,UAAA,CAAW,OAAO;IAEpC,IAAI,CAACD,EACL;MAEIE,OAAA,CAAQC,IAAA,CAAK,8CAA8C;MAGpD;IAAA;IAGAzB,QAAA,GAAAsB,EAAA;IAEJ;EAAA,CACX;EACAI,GAAA,EAAK,MAAOC,OACZ;IACI,IAAI,CAAC1B,UAAA,EAA2CC,8BAAA;IAEhD,MAAM0B,cAAA,GAAiB,EAAC;IAGxB,WAAWC,aAAA,IAAiB5B,UAC5B;MACI,MAAMW,SAAA,GAAYX,UAAW,CAAA4B,aAAA;MAE7B,IAAI,CAACjB,SACL;QACI;MAAA;MAGJgB,cAAA,CAAeE,IAAA,CAAKD,aAAa;IAAA;IAGrC,OAAO,CAAC,GAAGD,cAAgB,KAAGD,OAAO;EAAA,CACzC;EACAI,MAAA,EAAQ,MAAOJ,OACf;IACI,IAAI,CAAC1B,UAAA,EAA2CC,8BAAA;IAEhD,OAAOyB,OAAA,CAAQK,MAAO,CAACC,CAAM,MAAAA,CAAA,IAAOhC,UAAW;EAAA;AAEvD;AAEAiC,YAAA,CAAIR,GAAA,CAAIf,wBAAwB"},"metadata":{},"sourceType":"module","externalDependencies":[]}