{"ast":null,"code":"import { BitmapFontData } from '../BitmapFontData.mjs';\nclass TextFormat {\n  static test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  }\n  static parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = new BitmapFontData();\n    rawData.info.forEach(info => font.info.push({\n      face: info.face,\n      size: parseInt(info.size, 10)\n    }));\n    rawData.common.forEach(common => font.common.push({\n      lineHeight: parseInt(common.lineHeight, 10)\n    }));\n    rawData.page.forEach(page => font.page.push({\n      id: parseInt(page.id, 10),\n      file: page.file\n    }));\n    rawData.char.forEach(char => font.char.push({\n      id: parseInt(char.id, 10),\n      page: parseInt(char.page, 10),\n      x: parseInt(char.x, 10),\n      y: parseInt(char.y, 10),\n      width: parseInt(char.width, 10),\n      height: parseInt(char.height, 10),\n      xoffset: parseInt(char.xoffset, 10),\n      yoffset: parseInt(char.yoffset, 10),\n      xadvance: parseInt(char.xadvance, 10)\n    }));\n    rawData.kerning.forEach(kerning => font.kerning.push({\n      first: parseInt(kerning.first, 10),\n      second: parseInt(kerning.second, 10),\n      amount: parseInt(kerning.amount, 10)\n    }));\n    rawData.distanceField.forEach(df => font.distanceField.push({\n      distanceRange: parseInt(df.distanceRange, 10),\n      fieldType: df.fieldType\n    }));\n    return font;\n  }\n}\nexport { TextFormat };","map":{"version":3,"names":["TextFormat","test","data","startsWith","parse","txt","items","match","rawData","info","common","page","char","chars","kerning","kernings","distanceField","i","name","attributeList","itemData","i2","split","key","strValue","replace","floatValue","parseFloat","value","isNaN","push","font","BitmapFontData","forEach","face","size","parseInt","lineHeight","id","file","x","y","width","height","xoffset","yoffset","xadvance","first","second","amount","df","distanceRange","fieldType"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\text-bitmap\\src\\formats\\TextFormat.ts"],"sourcesContent":["import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface IBitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string;\n        page: string;\n        x: string;\n        y: string;\n        width: string;\n        height: string;\n        xoffset: string;\n        yoffset: string;\n        xadvance: string;\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: string;\n        distanceRange: string;\n    }[]\n}\n\n/**\n * BitmapFont format that's Text-based.\n * @private\n */\nexport class TextFormat\n{\n    /**\n     * Check if resource refers to txt font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    }\n\n    /**\n     * Convert text font data to a javascript object.\n     * @param txt - Raw string data to be converted\n     * @returns - Parsed font data\n     */\n    static parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: IBitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font = new BitmapFontData();\n\n        rawData.info.forEach((info) => font.info.push({\n            face: info.face,\n            size: parseInt(info.size, 10),\n        }));\n\n        rawData.common.forEach((common) => font.common.push({\n            lineHeight: parseInt(common.lineHeight, 10),\n        }));\n\n        rawData.page.forEach((page) => font.page.push({\n            id: parseInt(page.id, 10),\n            file: page.file,\n        }));\n\n        rawData.char.forEach((char) => font.char.push({\n            id: parseInt(char.id, 10),\n            page: parseInt(char.page, 10),\n            x: parseInt(char.x, 10),\n            y: parseInt(char.y, 10),\n            width: parseInt(char.width, 10),\n            height: parseInt(char.height, 10),\n            xoffset: parseInt(char.xoffset, 10),\n            yoffset: parseInt(char.yoffset, 10),\n            xadvance: parseInt(char.xadvance, 10),\n        }));\n\n        rawData.kerning.forEach((kerning) => font.kerning.push({\n            first: parseInt(kerning.first, 10),\n            second: parseInt(kerning.second, 10),\n            amount: parseInt(kerning.amount, 10),\n        }));\n\n        rawData.distanceField.forEach((df) => font.distanceField.push({\n            distanceRange: parseInt(df.distanceRange, 10),\n            fieldType: df.fieldType,\n        }));\n\n        return font;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}