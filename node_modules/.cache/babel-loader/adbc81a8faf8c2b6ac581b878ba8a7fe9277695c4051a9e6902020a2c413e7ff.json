{"ast":null,"code":"import { Texture, settings, Rectangle, utils } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { TextStyle } from '@pixi/text';\nimport { HTMLTextStyle } from './HTMLTextStyle.mjs';\nconst _HTMLText = class extends Sprite {\n  constructor() {\n    let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(Texture.EMPTY);\n    this._text = null;\n    this._style = null;\n    this._autoResolution = true;\n    this._loading = false;\n    this.localStyleID = -1;\n    this.dirty = false;\n    this.ownsStyle = false;\n    const image = new Image();\n    const texture = Texture.from(image, {\n      scaleMode: settings.SCALE_MODE,\n      resourceOptions: {\n        autoLoad: false\n      }\n    });\n    texture.orig = new Rectangle();\n    texture.trim = new Rectangle();\n    this.texture = texture;\n    const nssvg = \"http://www.w3.org/2000/svg\";\n    const nsxhtml = \"http://www.w3.org/1999/xhtml\";\n    const svgRoot = document.createElementNS(nssvg, \"svg\");\n    const foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    const domElement = document.createElementNS(nsxhtml, \"div\");\n    const styleElement = document.createElementNS(nsxhtml, \"style\");\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    this.maxWidth = _HTMLText.defaultMaxWidth;\n    this.maxHeight = _HTMLText.defaultMaxHeight;\n    this._domElement = domElement;\n    this._styleElement = styleElement;\n    this._svgRoot = svgRoot;\n    this._foreignObject = foreignObject;\n    this._foreignObject.appendChild(styleElement);\n    this._foreignObject.appendChild(domElement);\n    this._image = image;\n    this._loadImage = new Image();\n    this._autoResolution = _HTMLText.defaultAutoResolution;\n    this._resolution = _HTMLText.defaultResolution ?? settings.RESOLUTION;\n    this.text = text;\n    this.style = style;\n  }\n  measureText(overrides) {\n    const {\n      text,\n      style,\n      resolution\n    } = Object.assign({\n      text: this._text,\n      style: this._style,\n      resolution: this._resolution\n    }, overrides);\n    Object.assign(this._domElement, {\n      innerHTML: text,\n      style: style.toCSS(resolution)\n    });\n    this._styleElement.textContent = style.toGlobalCSS();\n    document.body.appendChild(this._svgRoot);\n    const contentBounds = this._domElement.getBoundingClientRect();\n    this._svgRoot.remove();\n    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));\n    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));\n    this._svgRoot.setAttribute(\"width\", contentWidth.toString());\n    this._svgRoot.setAttribute(\"height\", contentHeight.toString());\n    if (text !== this._text) {\n      this._domElement.innerHTML = this._text;\n    }\n    if (style !== this._style) {\n      Object.assign(this._domElement, {\n        style: this._style?.toCSS(resolution)\n      });\n      this._styleElement.textContent = this._style?.toGlobalCSS();\n    }\n    return {\n      width: contentWidth + style.padding * 2,\n      height: contentHeight + style.padding * 2\n    };\n  }\n  async updateText() {\n    let respectDirty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const {\n      style,\n      _image: image,\n      _loadImage: loadImage\n    } = this;\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n    const {\n      width,\n      height\n    } = this.measureText();\n    image.width = loadImage.width = Math.ceil(Math.max(1, width));\n    image.height = loadImage.height = Math.ceil(Math.max(1, height));\n    if (!this._loading) {\n      this._loading = true;\n      await new Promise(resolve => {\n        loadImage.onload = async () => {\n          await style.onBeforeDraw();\n          this._loading = false;\n          image.src = loadImage.src;\n          loadImage.onload = null;\n          loadImage.src = \"\";\n          this.updateTexture();\n          resolve();\n        };\n        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);\n        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;\n      });\n    }\n  }\n  get source() {\n    return this._image;\n  }\n  updateTexture() {\n    const {\n      style,\n      texture,\n      _image: image,\n      resolution\n    } = this;\n    const {\n      padding\n    } = style;\n    const {\n      baseTexture\n    } = texture;\n    texture.trim.width = texture._frame.width = image.width / resolution;\n    texture.trim.height = texture._frame.height = image.height / resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2;\n    this._onTextureUpdate();\n    baseTexture.setRealSize(image.width, image.height, resolution);\n    this.dirty = false;\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._render(renderer);\n  }\n  _renderCanvas(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._renderCanvas(renderer);\n  }\n  getLocalBounds(rect) {\n    this.updateText(true);\n    return super.getLocalBounds(rect);\n  }\n  _calculateBounds() {\n    this.updateText(true);\n    this.calculateVertices();\n    this._bounds.addQuad(this.vertexData);\n  }\n  _onStyleChange() {\n    this.dirty = true;\n  }\n  destroy(options) {\n    if (typeof options === \"boolean\") {\n      options = {\n        children: options\n      };\n    }\n    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);\n    super.destroy(options);\n    const forceClear = null;\n    if (this.ownsStyle) {\n      this._style?.cleanFonts();\n    }\n    this._style = forceClear;\n    this._svgRoot?.remove();\n    this._svgRoot = forceClear;\n    this._domElement?.remove();\n    this._domElement = forceClear;\n    this._foreignObject?.remove();\n    this._foreignObject = forceClear;\n    this._styleElement?.remove();\n    this._styleElement = forceClear;\n    this._loadImage.src = \"\";\n    this._loadImage.onload = null;\n    this._loadImage = forceClear;\n    this._image.src = \"\";\n    this._image = forceClear;\n  }\n  get width() {\n    this.updateText(true);\n    return Math.abs(this.scale.x) * this._image.width / this.resolution;\n  }\n  set width(value) {\n    this.updateText(true);\n    const s = utils.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._image.width / this.resolution;\n    this._width = value;\n  }\n  get height() {\n    this.updateText(true);\n    return Math.abs(this.scale.y) * this._image.height / this.resolution;\n  }\n  set height(value) {\n    this.updateText(true);\n    const s = utils.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._image.height / this.resolution;\n    this._height = value;\n  }\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    if (this._style === style) {\n      return;\n    }\n    style = style || {};\n    if (style instanceof HTMLTextStyle) {\n      this.ownsStyle = false;\n      this._style = style;\n    } else if (style instanceof TextStyle) {\n      console.warn(\"[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle\");\n      this.ownsStyle = true;\n      this._style = HTMLTextStyle.from(style);\n    } else {\n      this.ownsStyle = true;\n      this._style = new HTMLTextStyle(style);\n    }\n    this.localStyleID = -1;\n    this.dirty = true;\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === \"\" || text === null || text === void 0 ? \" \" : text);\n    text = this.sanitiseText(text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n  sanitiseText(text) {\n    return text.replace(/<br>/gi, \"<br/>\").replace(/<hr>/gi, \"<hr/>\").replace(/&nbsp;/gi, \"&#160;\");\n  }\n};\nlet HTMLText = _HTMLText;\nHTMLText.defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nHTMLText.defaultMaxWidth = 2024;\nHTMLText.defaultMaxHeight = 2024;\nHTMLText.defaultAutoResolution = true;\nexport { HTMLText };","map":{"version":3,"names":["_HTMLText","Sprite","constructor","text","arguments","length","undefined","style","Texture","EMPTY","_text","_style","_autoResolution","_loading","localStyleID","dirty","ownsStyle","image","Image","texture","from","scaleMode","settings","SCALE_MODE","resourceOptions","autoLoad","orig","Rectangle","trim","nssvg","nsxhtml","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","setAttribute","overflow","appendChild","maxWidth","defaultMaxWidth","maxHeight","defaultMaxHeight","_domElement","_styleElement","_svgRoot","_foreignObject","_image","_loadImage","defaultAutoResolution","_resolution","defaultResolution","RESOLUTION","measureText","overrides","resolution","Object","assign","innerHTML","toCSS","textContent","toGlobalCSS","body","contentBounds","getBoundingClientRect","remove","contentWidth","Math","min","ceil","width","contentHeight","height","toString","padding","updateText","respectDirty","loadImage","styleID","max","Promise","resolve","onload","onBeforeDraw","src","updateTexture","svgURL","XMLSerializer","serializeToString","encodeURIComponent","source","baseTexture","_frame","x","y","_onTextureUpdate","setRealSize","_render","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","destroy","options","children","defaultDestroyOptions","forceClear","cleanFonts","abs","scale","value","s","utils","sign","_width","_height","HTMLTextStyle","TextStyle","console","warn","String","sanitiseText","replace","HTMLText"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\text-html\\src\\HTMLText.ts"],"sourcesContent":["import { Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { TextStyle } from '@pixi/text';\nimport { HTMLTextStyle } from './HTMLTextStyle';\n\nimport type { ImageResource, IRenderer, ISize, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { ITextStyle } from '@pixi/text';\n\n/**\n * Alternative to {@link PIXI.Text|Text} but supports multi-style HTML text. There are\n * few key differences between this and {@link PIXI.Text|Text}:\n * <br>&bull; HTMLText not support {@link https://caniuse.com/mdn-svg_elements_foreignobject|Internet Explorer}.\n * <br>&bull; Rendering is text asynchronous. If statically rendering, listen to `update` event on BaseTexture.\n * <br>&bull; Does not support all style options (e.g., `lineJoin`, `leading`, `textBaseline`, `trim`, `miterLimit`,\n *   `fillGradientStops`, `fillGradientType`)\n * @example\n * import { HTMLText } from 'pixi.js';\n *\n * const text = new HTMLText(\"Hello <b>World</b>\", { fontSize: 20 });\n *\n * text.texture.baseTexture.on('update', () => {\n *   console.log('Text is redrawn!');\n * });\n * @class\n * @memberof PIXI\n * @extends PIXI.Sprite\n * @since 7.2.0\n */\nexport class HTMLText extends Sprite\n{\n    /**\n     * Default opens when destroying.\n     * @type {PIXI.IDestroyOptions}\n     * @property {boolean} [texture=true] - Whether to destroy the texture.\n     * @property {boolean} [children=false] - Whether to destroy the children.\n     * @property {boolean} [baseTexture=true] - Whether to destroy the base texture.\n     */\n    public static defaultDestroyOptions: IDestroyOptions = {\n        texture: true,\n        children: false,\n        baseTexture: true,\n    };\n\n    /** Default maxWidth, set at construction */\n    public static defaultMaxWidth = 2024;\n\n    /** Default maxHeight, set at construction */\n    public static defaultMaxHeight = 2024;\n\n    /** Default resolution, make sure autoResolution or defaultAutoResolution is `false`. */\n    public static defaultResolution: number | undefined;\n\n    /** Default autoResolution for all HTMLText objects */\n    public static defaultAutoResolution = true;\n\n    /** The maximum width in rendered pixels that the content can be, any larger will be hidden */\n    public maxWidth: number;\n\n    /** The maximum height in rendered pixels that the content can be, any larger will be hidden */\n    public maxHeight: number;\n\n    private _domElement: HTMLElement;\n    private _styleElement: HTMLElement;\n    private _svgRoot: SVGSVGElement;\n    private _foreignObject: SVGForeignObjectElement;\n    private _image: HTMLImageElement;\n    private _loadImage: HTMLImageElement;\n    private _resolution: number;\n    private _text: string | null = null;\n    private _style: HTMLTextStyle | null = null;\n    private _autoResolution = true;\n    private _loading = false;\n    private localStyleID = -1;\n    private dirty = false;\n\n    /** The HTMLTextStyle object is owned by this instance */\n    private ownsStyle = false;\n\n    /**\n     * @param {string} [text] - Text contents\n     * @param {PIXI.HTMLTextStyle|PIXI.TextStyle|PIXI.ITextStyle} [style] - Style setting to use.\n     *        Strongly recommend using an HTMLTextStyle object. Providing a PIXI.TextStyle\n     *        will convert the TextStyle to an HTMLTextStyle and will no longer be linked.\n     */\n    constructor(text = '', style: HTMLTextStyle | TextStyle | Partial<ITextStyle> = {})\n    {\n        super(Texture.EMPTY);\n\n        const image = new Image();\n        const texture = Texture.from<ImageResource>(image, {\n            scaleMode: settings.SCALE_MODE,\n            resourceOptions: {\n                autoLoad: false,\n            },\n        });\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        this.texture = texture;\n\n        const nssvg = 'http://www.w3.org/2000/svg';\n        const nsxhtml = 'http://www.w3.org/1999/xhtml';\n        const svgRoot = document.createElementNS(nssvg, 'svg');\n        const foreignObject = document.createElementNS(nssvg, 'foreignObject');\n        const domElement = document.createElementNS(nsxhtml, 'div');\n        const styleElement = document.createElementNS(nsxhtml, 'style');\n\n        // Arbitrary max size\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n        svgRoot.appendChild(foreignObject);\n\n        this.maxWidth = HTMLText.defaultMaxWidth;\n        this.maxHeight = HTMLText.defaultMaxHeight;\n        this._domElement = domElement;\n        this._styleElement = styleElement;\n        this._svgRoot = svgRoot;\n        this._foreignObject = foreignObject;\n        this._foreignObject.appendChild(styleElement);\n        this._foreignObject.appendChild(domElement);\n        this._image = image;\n        this._loadImage = new Image();\n        this._autoResolution = HTMLText.defaultAutoResolution;\n        this._resolution = HTMLText.defaultResolution ?? settings.RESOLUTION;\n        this.text = text;\n        this.style = style;\n    }\n\n    /**\n     * Calculate the size of the output text without actually drawing it.\n     * This includes the `padding` in the `style` object.\n     * This can be used as a fast-pass to do things like text-fitting.\n     * @param {object} [overrides] - Overrides for the text, style, and resolution.\n     * @param {string} [overrides.text] - The text to measure, if not specified, the current text is used.\n     * @param {PIXI.HTMLTextStyle} [overrides.style] - The style to measure, if not specified, the current style is used.\n     * @param {number} [overrides.resolution] - The resolution to measure, if not specified, the current resolution is used.\n     * @returns {PIXI.ISize} Width and height of the measured text.\n     */\n    measureText(overrides?: { text?: string, style?: HTMLTextStyle, resolution?: number }): ISize\n    {\n        const { text, style, resolution } = Object.assign({\n            text: this._text,\n            style: this._style,\n            resolution: this._resolution,\n        }, overrides);\n\n        Object.assign(this._domElement, {\n            innerHTML: text,\n            style: style.toCSS(resolution),\n        });\n        this._styleElement.textContent = style.toGlobalCSS();\n\n        // Measure the contents using the shadow DOM\n        document.body.appendChild(this._svgRoot);\n        const contentBounds = this._domElement.getBoundingClientRect();\n\n        this._svgRoot.remove();\n\n        const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));\n        const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));\n\n        this._svgRoot.setAttribute('width', contentWidth.toString());\n        this._svgRoot.setAttribute('height', contentHeight.toString());\n\n        // Undo the changes to the DOM element\n        if (text !== this._text)\n        {\n            this._domElement.innerHTML = this._text as string;\n        }\n        if (style !== this._style)\n        {\n            Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });\n            this._styleElement.textContent = this._style?.toGlobalCSS() as string;\n        }\n\n        return {\n            width: contentWidth + (style.padding * 2),\n            height: contentHeight + (style.padding * 2),\n        };\n    }\n\n    /**\n     * Manually refresh the text.\n     * @public\n     * @param {boolean} respectDirty - Whether to abort updating the\n     *        text if the Text isn't dirty and the function is called.\n     */\n    async updateText(respectDirty = true): Promise<void>\n    {\n        const { style, _image: image, _loadImage: loadImage } = this;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        const { width, height } = this.measureText();\n\n        // Make sure canvas is at least 1x1 so it drawable\n        // for sub-pixel sizes, round up to avoid clipping\n        // we update both images, to make sure bounds are correct synchronously\n        image.width = loadImage.width = Math.ceil((Math.max(1, width)));\n        image.height = loadImage.height = Math.ceil((Math.max(1, height)));\n\n        if (!this._loading)\n        {\n            this._loading = true;\n            await new Promise<void>((resolve) =>\n            {\n                loadImage.onload = async () =>\n                {\n                    // Fake waiting for the image to load\n                    await style.onBeforeDraw();\n                    this._loading = false;\n\n                    // Swap image and loadImage, we do this to avoid\n                    // flashes between updateText calls, usually when\n                    // the onload time is longer than updateText time\n                    image.src = loadImage.src;\n                    loadImage.onload = null;\n                    loadImage.src = '';\n\n                    // Force update the texture\n                    this.updateTexture();\n                    resolve();\n                };\n                const svgURL = new XMLSerializer().serializeToString(this._svgRoot);\n\n                loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;\n            });\n        }\n    }\n\n    /** The raw image element that is rendered under-the-hood. */\n    public get source(): HTMLImageElement\n    {\n        return this._image;\n    }\n\n    /**\n     * Update the texture resource.\n     * @private\n     */\n    updateTexture()\n    {\n        const { style, texture, _image: image, resolution } = this;\n        const { padding } = style;\n        const { baseTexture } = texture;\n\n        texture.trim.width = texture._frame.width = image.width / resolution;\n        texture.trim.height = texture._frame.height = image.height / resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(image.width, image.height, resolution);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param {PIXI.Renderer} renderer - The renderer\n     * @private\n     */\n    _render(renderer: Renderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas Renderer.\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer: IRenderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Get the local bounds.\n     * @param {PIXI.Rectangle} rect - Input rectangle.\n     * @returns {PIXI.Rectangle} Local bounds\n     */\n    getLocalBounds(rect: Rectangle)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds(rect);\n    }\n\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        (this as any)._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Handle dirty style changes\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Destroy this Text object. Don't use after calling.\n     * @param {boolean|object} options - Same as Sprite destroy options.\n     */\n    destroy(options?: boolean | IDestroyOptions | undefined)\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, HTMLText.defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        const forceClear: any = null;\n\n        // Remove any loaded fonts if we created the HTMLTextStyle\n        if (this.ownsStyle)\n        {\n            this._style?.cleanFonts();\n        }\n        this._style = forceClear;\n        this._svgRoot?.remove();\n        this._svgRoot = forceClear;\n        this._domElement?.remove();\n        this._domElement = forceClear;\n        this._foreignObject?.remove();\n        this._foreignObject = forceClear;\n        this._styleElement?.remove();\n        this._styleElement = forceClear;\n\n        this._loadImage.src = '';\n        this._loadImage.onload = null;\n        this._loadImage = forceClear;\n        this._image.src = '';\n        this._image = forceClear;\n    }\n\n    /**\n     * Get the width in pixels.\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._image.width / this.resolution;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._image.width / this.resolution;\n        this._width = value;\n    }\n\n    /**\n     * Get the height in pixels.\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._image.height / this.resolution;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._image.height / this.resolution;\n        this._height = value;\n    }\n\n    /** The base style to render with text. */\n    get style(): HTMLTextStyle\n    {\n        return this._style as HTMLTextStyle;\n    }\n\n    set style(style: HTMLTextStyle | TextStyle | Partial<ITextStyle>) // eslint-disable-line require-jsdoc\n    {\n        // Don't do anything if we're re-assigning\n        if (this._style === style)\n        {\n            return;\n        }\n\n        style = style || {};\n\n        if (style instanceof HTMLTextStyle)\n        {\n            this.ownsStyle = false;\n            this._style = style;\n        }\n        // Clone TextStyle\n        else if (style instanceof TextStyle)\n        {\n            console.warn('[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle');\n\n            this.ownsStyle = true;\n            this._style = HTMLTextStyle.from(style);\n        }\n        else\n        {\n            this.ownsStyle = true;\n            this._style = new HTMLTextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Contents of text. This can be HTML text and include tags.\n     * @example\n     * const text = new HTMLText('This is a <em>styled</em> text!');\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n        text = this.sanitiseText(text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @member {number}\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number) // eslint-disable-line require-jsdoc\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n\n    /**\n     * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`\n     * @param text\n     * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3\n     */\n    private sanitiseText(text: string): string\n    {\n        return text\n            .replace(/<br>/gi, '<br/>')\n            .replace(/<hr>/gi, '<hr/>')\n            .replace(/&nbsp;/gi, '&#160;');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}