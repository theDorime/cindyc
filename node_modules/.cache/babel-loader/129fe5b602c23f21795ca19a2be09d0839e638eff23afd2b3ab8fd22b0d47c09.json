{"ast":null,"code":"import { settings, ExtensionType, BaseTexture, utils, extensions } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { WorkerManager } from '../WorkerManager.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\"image/jpeg\", \"image/png\", \"image/webp\", \"image/avif\"];\nasync function loadImageBitmap(url) {\n  const response = await settings.ADAPTER.fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  const imageBitmap = await createImageBitmap(imageBlob);\n  return imageBitmap;\n}\nconst loadTextures = {\n  name: \"loadTextures\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: \"anonymous\"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && (await WorkerManager.isImageBitmapSupported())) {\n        src = await WorkerManager.loadImageBitmap(url);\n      } else {\n        src = await loadImageBitmap(url);\n      }\n    } else {\n      src = await new Promise(resolve => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new BaseTexture(src, {\n      resolution: utils.getResolutionOfUrl(url),\n      ...asset.data\n    });\n    base.resource.src = url;\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\nextensions.add(loadTextures);\nexport { loadImageBitmap, loadTextures };","map":{"version":3,"names":["validImageExtensions","validImageMIMEs","loadImageBitmap","url","response","settings","ADAPTER","fetch","ok","Error","status","statusText","imageBlob","blob","imageBitmap","createImageBitmap","loadTextures","name","extension","type","ExtensionType","LoadParser","priority","LoaderParserPriority","High","config","preferWorkers","preferCreateImageBitmap","crossOrigin","test","checkDataUrl","checkExtension","load","asset","loader","src","globalThis","WorkerManager","isImageBitmapSupported","Promise","resolve","Image","complete","onload","base","BaseTexture","resolution","utils","getResolutionOfUrl","data","resource","createTexture","unload","texture","destroy","extensions","add"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\assets\\src\\loader\\parsers\\textures\\loadTextures.ts"],"sourcesContent":["import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the `loadTextures` loader plugin.\n * @memberof PIXI\n * @see PIXI.loadTextures\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * ```js\n * // Set the config\n * import { loadTextures } from '@pixi/assets';\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap\n *    // If false then this will also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof PIXI\n */\nexport const loadTextures = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions, LoadTextureConfig>;\n\nextensions.add(loadTextures);\n"],"mappings":";;;;;;AAYA,MAAMA,oBAAA,GAAuB,CAAC,SAAS,MAAQ,UAAQ,SAAS,OAAO;AACvE,MAAMC,eAAkB,IACpB,cACA,aACA,cACA,aACJ;AAoCA,eAAAC,gBAAsCC,GACtC;EACI,MAAMC,QAAW,SAAMC,QAAS,CAAAC,OAAA,CAAQC,KAAA,CAAMJ,GAAG;EAE7C,KAACC,QAAA,CAASI,EACd;IACI,MAAM,IAAIC,KAAM,sCAAqCN,GAAA,KAC5CC,QAAS,CAAAM,MAAA,IAAUN,QAAA,CAASO,UAAY;EAAA;EAG/C,MAAAC,SAAA,GAAY,MAAMR,QAAA,CAASS,IAAK;EAChC,MAAAC,WAAA,GAAc,MAAMC,iBAAA,CAAkBH,SAAS;EAE9C,OAAAE,WAAA;AACX;AAuBO,MAAME,YAAe;EAExBC,IAAM;EAENC,SAAW;IACPC,IAAA,EAAMC,aAAc,CAAAC,UAAA;IACpBC,QAAA,EAAUC,oBAAqB,CAAAC;EAAA,CACnC;EAEAC,MAAQ;IACJC,aAAe;IACfC,uBAAyB;IACzBC,WAAa;EAAA,CACjB;EAEAC,KAAK1B,GACL;IACI,OAAO2B,YAAA,CAAa3B,GAAK,EAAAF,eAAe,CAAK,IAAA8B,cAAA,CAAe5B,GAAA,EAAKH,oBAAoB;EAAA,CACzF;EAEA,MAAMgC,KAAK7B,GAAa,EAAA8B,KAAA,EAAuCC,MAC/D;IACI,IAAIC,GAAW;IAEf,IAAIC,UAAW,CAAArB,iBAAA,IAAqB,IAAK,CAAAU,MAAA,CAAOE,uBAChD;MACI,IAAI,KAAKF,MAAO,CAAAC,aAAA,KAAiB,MAAMW,aAAA,CAAcC,sBAAA,EACrD;QACUH,GAAA,SAAME,aAAc,CAAAnC,eAAA,CAAgBC,GAAG;MAAA,CAGjD;QACUgC,GAAA,SAAMjC,eAAA,CAAgBC,GAAG;MAAA;IACnC,CAGJ;MACIgC,GAAA,GAAM,MAAM,IAAII,OAAQ,CAACC,OACzB;QACIL,GAAA,GAAM,IAAIM,KAAM;QACZN,GAAA,CAAAP,WAAA,GAAc,KAAKH,MAAO,CAAAG,WAAA;QAE9BO,GAAA,CAAIA,GAAM,GAAAhC,GAAA;QACV,IAAIgC,GAAA,CAAIO,QACR;UACIF,OAAA,CAAQL,GAAG;QAAA,CAGf;UACIA,GAAA,CAAIQ,MAAA,GAAS,MACb;YACIH,OAAA,CAAQL,GAAG;UAAA,CACf;QAAA;MACJ,CACH;IAAA;IAGC,MAAAS,IAAA,GAAO,IAAIC,WAAA,CAAYV,GAAK;MAC9BW,UAAA,EAAYC,KAAM,CAAAC,kBAAA,CAAmB7C,GAAG;MACxC,GAAG8B,KAAM,CAAAgB;IAAA,CACZ;IAEDL,IAAA,CAAKM,QAAA,CAASf,GAAM,GAAAhC,GAAA;IAEb,OAAAgD,aAAA,CAAcP,IAAM,EAAAV,MAAA,EAAQ/B,GAAG;EAAA,CAC1C;EAEAiD,OAAOC,OACP;IACIA,OAAA,CAAQC,OAAA,CAAQ,IAAI;EAAA;AAE5B;AAEAC,UAAA,CAAWC,GAAA,CAAIxC,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}