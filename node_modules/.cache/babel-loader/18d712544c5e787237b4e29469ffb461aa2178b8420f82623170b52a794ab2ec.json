{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/extensions';\nclass ObjectRendererSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  render(displayObject, options) {\n    const renderer = this.renderer;\n    let renderTexture;\n    let clear;\n    let transform;\n    let skipUpdateTransform;\n    if (options) {\n      renderTexture = options.renderTexture;\n      clear = options.clear;\n      transform = options.transform;\n      skipUpdateTransform = options.skipUpdateTransform;\n    }\n    this.renderingToScreen = !renderTexture;\n    renderer.runners.prerender.emit();\n    renderer.emit(\"prerender\");\n    renderer.projection.transform = transform;\n    if (renderer.context.isLost) {\n      return;\n    }\n    if (!renderTexture) {\n      this.lastObjectRendered = displayObject;\n    }\n    if (!skipUpdateTransform) {\n      const cacheParent = displayObject.enableTempParent();\n      displayObject.updateTransform();\n      displayObject.disableTempParent(cacheParent);\n    }\n    renderer.renderTexture.bind(renderTexture);\n    renderer.batch.currentRenderer.start();\n    if (clear ?? renderer.background.clearBeforeRender) {\n      renderer.renderTexture.clear();\n    }\n    displayObject.render(renderer);\n    renderer.batch.currentRenderer.flush();\n    if (renderTexture) {\n      if (options.blit) {\n        renderer.framebuffer.blit();\n      }\n      renderTexture.baseTexture.update();\n    }\n    renderer.runners.postrender.emit();\n    renderer.projection.transform = null;\n    renderer.emit(\"postrender\");\n  }\n  destroy() {\n    this.renderer = null;\n    this.lastObjectRendered = null;\n  }\n}\nObjectRendererSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"objectRenderer\"\n};\nextensions.add(ObjectRendererSystem);\nexport { ObjectRendererSystem };","map":{"version":3,"names":["ObjectRendererSystem","constructor","renderer","render","displayObject","options","renderTexture","clear","transform","skipUpdateTransform","renderingToScreen","runners","prerender","emit","projection","context","isLost","lastObjectRendered","cacheParent","enableTempParent","updateTransform","disableTempParent","bind","batch","currentRenderer","start","background","clearBeforeRender","flush","blit","framebuffer","baseTexture","update","postrender","destroy","extension","type","ExtensionType","RendererSystem","name","extensions","add"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\render\\ObjectRendererSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Matrix } from '@pixi/math';\nimport type { IRenderableObject, IRendererRenderOptions } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { RenderTexture } from '../renderTexture/RenderTexture';\nimport type { ISystem } from '../system/ISystem';\n\n/**\n * system that provides a render function that focussing on rendering Pixi Scene Graph objects\n * to either the main view or to a renderTexture.  Used for Canvas `WebGL` contexts\n * @memberof PIXI\n */\nexport class ObjectRendererSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'objectRenderer',\n    };\n\n    renderer: Renderer;\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    renderingToScreen: boolean;\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    lastObjectRendered: IRenderableObject;\n\n    // renderers scene graph!\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the object to its WebGL view.\n     * @param displayObject - The object to be rendered.\n     * @param options - the options to be passed to the renderer\n     */\n    render(displayObject: IRenderableObject, options?: IRendererRenderOptions): void\n    {\n        const renderer = this.renderer;\n\n        let renderTexture: RenderTexture;\n        let clear: boolean;\n        let transform: Matrix;\n        let skipUpdateTransform: boolean;\n\n        if (options)\n        {\n            renderTexture = options.renderTexture;\n            clear = options.clear;\n            transform = options.transform;\n            skipUpdateTransform = options.skipUpdateTransform;\n        }\n\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        renderer.runners.prerender.emit();\n        renderer.emit('prerender');\n\n        // apply a transform at a GPU level\n        renderer.projection.transform = transform;\n\n        // no point rendering if our context has been blown up!\n        if (renderer.context.isLost)\n        {\n            return;\n        }\n\n        if (!renderTexture)\n        {\n            this.lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.enableTempParent();\n\n            displayObject.updateTransform();\n            displayObject.disableTempParent(cacheParent);\n            // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        renderer.renderTexture.bind(renderTexture);\n        renderer.batch.currentRenderer.start();\n\n        if (clear ?? renderer.background.clearBeforeRender)\n        {\n            renderer.renderTexture.clear();\n        }\n\n        displayObject.render(renderer);\n\n        // apply transform..\n        renderer.batch.currentRenderer.flush();\n\n        if (renderTexture)\n        {\n            if (options.blit)\n            {\n                renderer.framebuffer.blit();\n            }\n\n            renderTexture.baseTexture.update();\n        }\n\n        renderer.runners.postrender.emit();\n\n        // reset transform after render\n        renderer.projection.transform = null;\n\n        renderer.emit('postrender');\n    }\n\n    destroy(): void\n    {\n        // ka pow!\n        this.renderer = null;\n        this.lastObjectRendered = null;\n    }\n}\n\nextensions.add(ObjectRendererSystem);\n"],"mappings":";AAcO,MAAMA,oBACb;EAuBIC,YAAYC,QACZ;IACI,KAAKA,QAAW,GAAAA,QAAA;EAAA;EAQpBC,OAAOC,aAAA,EAAkCC,OACzC;IACI,MAAMH,QAAA,GAAW,IAAK,CAAAA,QAAA;IAElB,IAAAI,aAAA;IACA,IAAAC,KAAA;IACA,IAAAC,SAAA;IACA,IAAAC,mBAAA;IAEJ,IAAIJ,OACJ;MACIC,aAAA,GAAgBD,OAAQ,CAAAC,aAAA;MACxBC,KAAA,GAAQF,OAAQ,CAAAE,KAAA;MAChBC,SAAA,GAAYH,OAAQ,CAAAG,SAAA;MACpBC,mBAAA,GAAsBJ,OAAQ,CAAAI,mBAAA;IAAA;IAIlC,KAAKC,iBAAA,GAAoB,CAACJ,aAAA;IAEjBJ,QAAA,CAAAS,OAAA,CAAQC,SAAA,CAAUC,IAAK;IAChCX,QAAA,CAASW,IAAA,CAAK,WAAW;IAGzBX,QAAA,CAASY,UAAA,CAAWN,SAAY,GAAAA,SAAA;IAG5B,IAAAN,QAAA,CAASa,OAAA,CAAQC,MACrB;MACI;IAAA;IAGJ,IAAI,CAACV,aACL;MACI,KAAKW,kBAAqB,GAAAb,aAAA;IAAA;IAG9B,IAAI,CAACK,mBACL;MAEU,MAAAS,WAAA,GAAcd,aAAA,CAAce,gBAAiB;MAEnDf,aAAA,CAAcgB,eAAgB;MAC9BhB,aAAA,CAAciB,iBAAA,CAAkBH,WAAW;IAAA;IAItChB,QAAA,CAAAI,aAAA,CAAcgB,IAAA,CAAKhB,aAAa;IAChCJ,QAAA,CAAAqB,KAAA,CAAMC,eAAA,CAAgBC,KAAM;IAEjC,IAAAlB,KAAA,IAASL,QAAS,CAAAwB,UAAA,CAAWC,iBACjC;MACIzB,QAAA,CAASI,aAAA,CAAcC,KAAM;IAAA;IAGjCH,aAAA,CAAcD,MAAA,CAAOD,QAAQ;IAGpBA,QAAA,CAAAqB,KAAA,CAAMC,eAAA,CAAgBI,KAAM;IAErC,IAAItB,aACJ;MACI,IAAID,OAAA,CAAQwB,IACZ;QACI3B,QAAA,CAAS4B,WAAA,CAAYD,IAAK;MAAA;MAG9BvB,aAAA,CAAcyB,WAAA,CAAYC,MAAO;IAAA;IAG5B9B,QAAA,CAAAS,OAAA,CAAQsB,UAAA,CAAWpB,IAAK;IAGjCX,QAAA,CAASY,UAAA,CAAWN,SAAY;IAEhCN,QAAA,CAASW,IAAA,CAAK,YAAY;EAAA;EAG9BqB,OACAA,CAAA;IAEI,KAAKhC,QAAW;IAChB,KAAKe,kBAAqB;EAAA;AAElC;AAtHajB,oBAAA,CAGFmC,SAA+B;EAClCC,IAAA,EAAMC,aAAc,CAAAC,cAAA;EACpBC,IAAM;AACV;AAkHJC,UAAA,CAAWC,GAAA,CAAIzC,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}