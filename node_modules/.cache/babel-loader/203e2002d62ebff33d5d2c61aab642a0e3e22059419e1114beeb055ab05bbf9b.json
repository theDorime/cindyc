{"ast":null,"code":"import { ExtensionType, extensions } from '@pixi/extensions';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { AbstractMaskSystem } from './AbstractMaskSystem.mjs';\nconst tempMatrix = new Matrix();\nconst rectPool = [];\nconst _ScissorSystem = class extends AbstractMaskSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._scissorCounter;\n    }\n    return 0;\n  }\n  calcScissorRect(maskData) {\n    if (maskData._scissorRectLocal) {\n      return;\n    }\n    const prevData = maskData._scissorRect;\n    const {\n      maskObject\n    } = maskData;\n    const {\n      renderer\n    } = this;\n    const renderTextureSystem = renderer.renderTexture;\n    const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());\n    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    if (prevData) {\n      rect.fit(prevData);\n    }\n    maskData._scissorRectLocal = rect;\n  }\n  static isMatrixRotated(matrix) {\n    if (!matrix) {\n      return false;\n    }\n    const {\n      a,\n      b,\n      c,\n      d\n    } = matrix;\n    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n  }\n  testScissor(maskData) {\n    const {\n      maskObject\n    } = maskData;\n    if (!maskObject.isFastRect || !maskObject.isFastRect()) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {\n      return false;\n    }\n    this.calcScissorRect(maskData);\n    const rect = maskData._scissorRectLocal;\n    return rect.width > 0 && rect.height > 0;\n  }\n  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (_ScissorSystem.isMatrixRotated(transform)) {\n      return;\n    }\n    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.renderer.filter.transformAABB(transform, frame);\n    frame.fit(bindingDestinationFrame);\n    frame.x = Math.round(frame.x * resolution);\n    frame.y = Math.round(frame.y * resolution);\n    frame.width = Math.round(frame.width * resolution);\n    frame.height = Math.round(frame.height * resolution);\n  }\n  push(maskData) {\n    if (!maskData._scissorRectLocal) {\n      this.calcScissorRect(maskData);\n    }\n    const {\n      gl\n    } = this.renderer;\n    if (!maskData._scissorRect) {\n      gl.enable(gl.SCISSOR_TEST);\n    }\n    maskData._scissorCounter++;\n    maskData._scissorRect = maskData._scissorRectLocal;\n    this._useCurrent();\n  }\n  pop(maskData) {\n    const {\n      gl\n    } = this.renderer;\n    if (maskData) {\n      rectPool.push(maskData._scissorRectLocal);\n    }\n    if (this.getStackLength() > 0) {\n      this._useCurrent();\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n  _useCurrent() {\n    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n    let y;\n    if (this.renderer.renderTexture.current) {\n      y = rect.y;\n    } else {\n      y = this.renderer.height - rect.height - rect.y;\n    }\n    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n  }\n};\nlet ScissorSystem = _ScissorSystem;\nScissorSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"scissor\"\n};\nextensions.add(ScissorSystem);\nexport { ScissorSystem };","map":{"version":3,"names":["tempMatrix","Matrix","rectPool","_ScissorSystem","AbstractMaskSystem","constructor","renderer","glConst","settings","ADAPTER","getWebGLRenderingContext","SCISSOR_TEST","getStackLength","maskData","maskStack","length","_scissorCounter","calcScissorRect","_scissorRectLocal","prevData","_scissorRect","maskObject","renderTextureSystem","renderTexture","rect","getBounds","pop","Rectangle","roundFrameToPixels","current","resolution","sourceFrame","destinationFrame","projection","transform","fit","isMatrixRotated","matrix","a","b","c","d","Math","abs","testScissor","isFastRect","worldTransform","width","height","frame","bindingSourceFrame","bindingDestinationFrame","copyFrom","identity","translate","x","y","scale","filter","transformAABB","round","push","gl","enable","_useCurrent","disable","scissor","ScissorSystem","extension","type","ExtensionType","RendererSystem","name","extensions","add"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\mask\\ScissorSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { AbstractMaskSystem } from './AbstractMaskSystem';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { MaskData } from './MaskData';\n\nconst tempMatrix = new Matrix();\nconst rectPool: Rectangle[] = [];\n\n/**\n * System plugin to the renderer to manage scissor masking.\n *\n * Scissor masking discards pixels outside of a rectangle called the scissor box. The scissor box is in the framebuffer\n * viewport's space; however, the mask's rectangle is projected from world-space to viewport space automatically\n * by this system.\n * @memberof PIXI\n */\nexport class ScissorSystem extends AbstractMaskSystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'scissor',\n    };\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n    }\n\n    getStackLength(): number\n    {\n        const maskData = this.maskStack[this.maskStack.length - 1];\n\n        if (maskData)\n        {\n            return maskData._scissorCounter;\n        }\n\n        return 0;\n    }\n\n    /**\n     * evaluates _boundsTransformed, _scissorRect for MaskData\n     * @param maskData\n     */\n    calcScissorRect(maskData: MaskData): void\n    {\n        if (maskData._scissorRectLocal)\n        {\n            return;\n        }\n\n        const prevData = maskData._scissorRect;\n        const { maskObject } = maskData;\n        const { renderer } = this;\n        const renderTextureSystem = renderer.renderTexture;\n        const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());\n\n        this.roundFrameToPixels(rect,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform);\n\n        if (prevData)\n        {\n            rect.fit(prevData);\n        }\n        maskData._scissorRectLocal = rect;\n    }\n\n    private static isMatrixRotated(matrix: Matrix)\n    {\n        if (!matrix)\n        {\n            return false;\n        }\n        const { a, b, c, d } = matrix;\n\n        // Skip if skew/rotation present in matrix, except for multiple of 90° rotation. If rotation\n        // is a multiple of 90°, then either pair of (b,c) or (a,d) will be (0,0).\n        return ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n            && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4));\n    }\n\n    /**\n     * Test, whether the object can be scissor mask with current renderer projection.\n     * Calls \"calcScissorRect()\" if its true.\n     * @param maskData - mask data\n     * @returns whether Whether the object can be scissor mask\n     */\n    public testScissor(maskData: MaskData): boolean\n    {\n        const { maskObject } = maskData;\n\n        if (!maskObject.isFastRect || !maskObject.isFastRect())\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(maskObject.worldTransform))\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(this.renderer.projection.transform))\n        {\n            return false;\n        }\n\n        this.calcScissorRect(maskData);\n\n        const rect = maskData._scissorRectLocal;\n\n        return rect.width > 0 && rect.height > 0;\n    }\n\n    private roundFrameToPixels(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix,\n    )\n    {\n        if (ScissorSystem.isMatrixRotated(transform))\n        {\n            return;\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        (this.renderer.filter as any).transformAABB(transform, frame);\n\n        frame.fit(bindingDestinationFrame);\n        frame.x = Math.round(frame.x * resolution);\n        frame.y = Math.round(frame.y * resolution);\n        frame.width = Math.round(frame.width * resolution);\n        frame.height = Math.round(frame.height * resolution);\n    }\n\n    /**\n     * Applies the Mask and adds it to the current stencil stack.\n     * @author alvin\n     * @param maskData - The mask data.\n     */\n    push(maskData: MaskData): void\n    {\n        if (!maskData._scissorRectLocal)\n        {\n            this.calcScissorRect(maskData);\n        }\n\n        const { gl } = this.renderer;\n\n        if (!maskData._scissorRect)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n        }\n\n        maskData._scissorCounter++;\n        maskData._scissorRect = maskData._scissorRectLocal;\n        this._useCurrent();\n    }\n\n    /**\n     * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the\n     * last mask in the stack.\n     *\n     * This can also be called when you directly modify the scissor box and want to restore PixiJS state.\n     * @param maskData - The mask data.\n     */\n    pop(maskData?: MaskData): void\n    {\n        const { gl } = this.renderer;\n\n        if (maskData)\n        {\n            rectPool.push(maskData._scissorRectLocal);\n        }\n\n        if (this.getStackLength() > 0)\n        {\n            this._useCurrent();\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n    }\n\n    /**\n     * Setup renderer to use the current scissor data.\n     * @private\n     */\n    _useCurrent(): void\n    {\n        const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n        let y: number;\n\n        if (this.renderer.renderTexture.current)\n        {\n            y = rect.y;\n        }\n        else\n        {\n            // flipY. In future we'll have it over renderTextures as an option\n            y = this.renderer.height - rect.height - rect.y;\n        }\n\n        this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n    }\n}\n\nextensions.add(ScissorSystem);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}