{"ast":null,"code":"import { Color } from '@pixi/color';\nimport { ENV } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nimport { deprecation, premultiplyBlendMode, nextPow2, log2 } from '@pixi/utils';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer.mjs';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader.mjs';\nimport { State } from '../state/State.mjs';\nimport { BaseTexture } from '../textures/BaseTexture.mjs';\nimport { BatchDrawCall } from './BatchDrawCall.mjs';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport { BatchShaderGenerator } from './BatchShaderGenerator.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\nimport { canUploadSameBuffer } from './canUploadSameBuffer.mjs';\nimport { maxRecommendedTextures } from './maxRecommendedTextures.mjs';\nimport { ObjectRenderer } from './ObjectRenderer.mjs';\nimport defaultFragment from './texture.mjs';\nimport defaultVertex from './texture2.mjs';\nconst _BatchRenderer = class extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    this.setShaderGenerator();\n    this.geometryClass = BatchGeometry;\n    this.vertexSize = 6;\n    this.state = State.for2d();\n    this.size = _BatchRenderer.defaultBatchSize * 4;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n    this._bufferedElements = [];\n    this._bufferedTextures = [];\n    this._bufferSize = 0;\n    this._shader = null;\n    this._packedGeometries = [];\n    this._packedGeometryPoolSize = 2;\n    this._flushId = 0;\n    this._aBuffers = {};\n    this._iBuffers = {};\n    this.maxTextures = 1;\n    this.renderer.on(\"prerender\", this.onPrerender, this);\n    renderer.runners.contextChange.add(this);\n    this._dcIndex = 0;\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    this._tempBoundTextures = [];\n  }\n  static get defaultMaxTextures() {\n    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);\n    return this._defaultMaxTextures;\n  }\n  static set defaultMaxTextures(value) {\n    this._defaultMaxTextures = value;\n  }\n  static get canUploadSameBuffer() {\n    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();\n    return this._canUploadSameBuffer;\n  }\n  static set canUploadSameBuffer(value) {\n    this._canUploadSameBuffer = value;\n  }\n  get MAX_TEXTURES() {\n    deprecation(\"7.1.0\", \"BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures\");\n    return this.maxTextures;\n  }\n  static get defaultVertexSrc() {\n    return defaultVertex;\n  }\n  static get defaultFragmentTemplate() {\n    return defaultFragment;\n  }\n  setShaderGenerator() {\n    let {\n      vertex = _BatchRenderer.defaultVertexSrc,\n      fragment = _BatchRenderer.defaultFragmentTemplate\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n  }\n  contextChange() {\n    const gl = this.renderer.gl;\n    if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {\n      this.maxTextures = 1;\n    } else {\n      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);\n      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n    }\n    this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      this._packedGeometries[i] = new this.geometryClass();\n    }\n    this.initFlushBuffers();\n  }\n  initFlushBuffers() {\n    const {\n      _drawCallPool,\n      _textureArrayPool\n    } = _BatchRenderer;\n    const MAX_SPRITES = this.size / 4;\n    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n    while (_drawCallPool.length < MAX_SPRITES) {\n      _drawCallPool.push(new BatchDrawCall());\n    }\n    while (_textureArrayPool.length < MAX_TA) {\n      _textureArrayPool.push(new BatchTextureArray());\n    }\n    for (let i = 0; i < this.maxTextures; i++) {\n      this._tempBoundTextures[i] = null;\n    }\n  }\n  onPrerender() {\n    this._flushId = 0;\n  }\n  render(element) {\n    if (!element._texture.valid) {\n      return;\n    }\n    if (this._vertexCount + element.vertexData.length / 2 > this.size) {\n      this.flush();\n    }\n    this._vertexCount += element.vertexData.length / 2;\n    this._indexCount += element.indices.length;\n    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n    this._bufferedElements[this._bufferSize++] = element;\n  }\n  buildTexturesAndDrawCalls() {\n    const {\n      _bufferedTextures: textures,\n      maxTextures\n    } = this;\n    const textureArrays = _BatchRenderer._textureArrayPool;\n    const batch = this.renderer.batch;\n    const boundTextures = this._tempBoundTextures;\n    const touch = this.renderer.textureGC.count;\n    let TICK = ++BaseTexture._globalBatch;\n    let countTexArrays = 0;\n    let texArray = textureArrays[0];\n    let start = 0;\n    batch.copyBoundTextures(boundTextures, maxTextures);\n    for (let i = 0; i < this._bufferSize; ++i) {\n      const tex = textures[i];\n      textures[i] = null;\n      if (tex._batchEnabled === TICK) {\n        continue;\n      }\n      if (texArray.count >= maxTextures) {\n        batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n        this.buildDrawCalls(texArray, start, i);\n        start = i;\n        texArray = textureArrays[++countTexArrays];\n        ++TICK;\n      }\n      tex._batchEnabled = TICK;\n      tex.touched = touch;\n      texArray.elements[texArray.count++] = tex;\n    }\n    if (texArray.count > 0) {\n      batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n      this.buildDrawCalls(texArray, start, this._bufferSize);\n      ++countTexArrays;\n      ++TICK;\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      boundTextures[i] = null;\n    }\n    BaseTexture._globalBatch = TICK;\n  }\n  buildDrawCalls(texArray, start, finish) {\n    const {\n      _bufferedElements: elements,\n      _attributeBuffer,\n      _indexBuffer,\n      vertexSize\n    } = this;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let dcIndex = this._dcIndex;\n    let aIndex = this._aIndex;\n    let iIndex = this._iIndex;\n    let drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex;\n    drawCall.texArray = texArray;\n    for (let i = start; i < finish; ++i) {\n      const sprite = elements[i];\n      const tex = sprite._texture.baseTexture;\n      const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i] = null;\n      if (start < i && drawCall.blend !== spriteBlendMode) {\n        drawCall.size = iIndex - drawCall.start;\n        start = i;\n        drawCall = drawCalls[++dcIndex];\n        drawCall.texArray = texArray;\n        drawCall.start = iIndex;\n      }\n      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n      aIndex += sprite.vertexData.length / 2 * vertexSize;\n      iIndex += sprite.indices.length;\n      drawCall.blend = spriteBlendMode;\n    }\n    if (start < finish) {\n      drawCall.size = iIndex - drawCall.start;\n      ++dcIndex;\n    }\n    this._dcIndex = dcIndex;\n    this._aIndex = aIndex;\n    this._iIndex = iIndex;\n  }\n  bindAndClearTexArray(texArray) {\n    const textureSystem = this.renderer.texture;\n    for (let j = 0; j < texArray.count; j++) {\n      textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n      texArray.elements[j] = null;\n    }\n    texArray.count = 0;\n  }\n  updateGeometry() {\n    const {\n      _packedGeometries: packedGeometries,\n      _attributeBuffer: attributeBuffer,\n      _indexBuffer: indexBuffer\n    } = this;\n    if (!_BatchRenderer.canUploadSameBuffer) {\n      if (this._packedGeometryPoolSize <= this._flushId) {\n        this._packedGeometryPoolSize++;\n        packedGeometries[this._flushId] = new this.geometryClass();\n      }\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.bind(packedGeometries[this._flushId]);\n      this.renderer.geometry.updateBuffers();\n      this._flushId++;\n    } else {\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.updateBuffers();\n    }\n  }\n  drawBatches() {\n    const dcCount = this._dcIndex;\n    const {\n      gl,\n      state: stateSystem\n    } = this.renderer;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let curTexArray = null;\n    for (let i = 0; i < dcCount; i++) {\n      const {\n        texArray,\n        type,\n        size,\n        start,\n        blend\n      } = drawCalls[i];\n      if (curTexArray !== texArray) {\n        curTexArray = texArray;\n        this.bindAndClearTexArray(texArray);\n      }\n      this.state.blendMode = blend;\n      stateSystem.set(this.state);\n      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n    }\n  }\n  flush() {\n    if (this._vertexCount === 0) {\n      return;\n    }\n    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n    this._indexBuffer = this.getIndexBuffer(this._indexCount);\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._dcIndex = 0;\n    this.buildTexturesAndDrawCalls();\n    this.updateGeometry();\n    this.drawBatches();\n    this._bufferSize = 0;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n  }\n  start() {\n    this.renderer.state.set(this.state);\n    this.renderer.texture.ensureSamplerType(this.maxTextures);\n    this.renderer.shader.bind(this._shader);\n    if (_BatchRenderer.canUploadSameBuffer) {\n      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n    }\n  }\n  stop() {\n    this.flush();\n  }\n  destroy() {\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      if (this._packedGeometries[i]) {\n        this._packedGeometries[i].destroy();\n      }\n    }\n    this.renderer.off(\"prerender\", this.onPrerender, this);\n    this._aBuffers = null;\n    this._iBuffers = null;\n    this._packedGeometries = null;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    if (this._shader) {\n      this._shader.destroy();\n      this._shader = null;\n    }\n    super.destroy();\n  }\n  getAttributeBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 8));\n    const roundedSizeIndex = log2(roundedP2);\n    const roundedSize = roundedP2 * 8;\n    if (this._aBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._aBuffers[roundedSize];\n    if (!buffer) {\n      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n    }\n    return buffer;\n  }\n  getIndexBuffer(size) {\n    const roundedP2 = nextPow2(Math.ceil(size / 12));\n    const roundedSizeIndex = log2(roundedP2);\n    const roundedSize = roundedP2 * 12;\n    if (this._iBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._iBuffers[roundedSizeIndex];\n    if (!buffer) {\n      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n    }\n    return buffer;\n  }\n  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    const {\n      uint32View,\n      float32View\n    } = attributeBuffer;\n    const packedVertices = aIndex / this.vertexSize;\n    const uvs = element.uvs;\n    const indicies = element.indices;\n    const vertexData = element.vertexData;\n    const textureId = element._texture.baseTexture._batchLocation;\n    const alpha = Math.min(element.worldAlpha, 1);\n    const argb = Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);\n    for (let i = 0; i < vertexData.length; i += 2) {\n      float32View[aIndex++] = vertexData[i];\n      float32View[aIndex++] = vertexData[i + 1];\n      float32View[aIndex++] = uvs[i];\n      float32View[aIndex++] = uvs[i + 1];\n      uint32View[aIndex++] = argb;\n      float32View[aIndex++] = textureId;\n    }\n    for (let i = 0; i < indicies.length; i++) {\n      indexBuffer[iIndex++] = packedVertices + indicies[i];\n    }\n  }\n};\nlet BatchRenderer = _BatchRenderer;\nBatchRenderer.defaultBatchSize = 4096;\nBatchRenderer.extension = {\n  name: \"batch\",\n  type: ExtensionType.RendererPlugin\n};\nBatchRenderer._drawCallPool = [];\nBatchRenderer._textureArrayPool = [];\nextensions.add(BatchRenderer);\nexport { BatchRenderer };","map":{"version":3,"names":["_BatchRenderer","ObjectRenderer","constructor","renderer","setShaderGenerator","geometryClass","BatchGeometry","vertexSize","state","State","for2d","size","defaultBatchSize","_vertexCount","_indexCount","_bufferedElements","_bufferedTextures","_bufferSize","_shader","_packedGeometries","_packedGeometryPoolSize","_flushId","_aBuffers","_iBuffers","maxTextures","on","onPrerender","runners","contextChange","add","_dcIndex","_aIndex","_iIndex","_attributeBuffer","_indexBuffer","_tempBoundTextures","defaultMaxTextures","_defaultMaxTextures","maxRecommendedTextures","value","canUploadSameBuffer","_canUploadSameBuffer","MAX_TEXTURES","deprecation","defaultVertexSrc","defaultVertex","defaultFragmentTemplate","defaultFragment","vertex","fragment","arguments","length","undefined","shaderGenerator","BatchShaderGenerator","gl","settings","PREFER_ENV","ENV","WEBGL_LEGACY","Math","min","getParameter","MAX_TEXTURE_IMAGE_UNITS","checkMaxIfStatementsInShader","generateShader","i","initFlushBuffers","_drawCallPool","_textureArrayPool","MAX_SPRITES","MAX_TA","floor","push","BatchDrawCall","BatchTextureArray","render","element","_texture","valid","vertexData","flush","indices","baseTexture","buildTexturesAndDrawCalls","textures","textureArrays","batch","boundTextures","touch","textureGC","count","TICK","BaseTexture","_globalBatch","countTexArrays","texArray","start","copyBoundTextures","tex","_batchEnabled","boundArray","buildDrawCalls","touched","elements","finish","drawCalls","dcIndex","aIndex","iIndex","drawCall","sprite","spriteBlendMode","premultiplyBlendMode","alphaMode","blendMode","blend","packInterleavedGeometry","bindAndClearTexArray","textureSystem","texture","j","bind","ids","updateGeometry","packedGeometries","attributeBuffer","indexBuffer","_buffer","update","rawBinaryData","geometry","updateBuffers","drawBatches","dcCount","stateSystem","curTexArray","type","set","drawElements","UNSIGNED_SHORT","getAttributeBuffer","getIndexBuffer","ensureSamplerType","shader","stop","destroy","off","roundedP2","nextPow2","ceil","roundedSizeIndex","log2","roundedSize","buffer","ViewableBuffer","Uint16Array","uint32View","float32View","packedVertices","uvs","indicies","textureId","_batchLocation","alpha","worldAlpha","argb","Color","shared","setValue","_tintRGB","toPremultiplied","BatchRenderer","extension","name","ExtensionType","RendererPlugin","extensions"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\batch\\BatchRenderer.ts"],"sourcesContent":["import { Color } from '@pixi/color';\nimport { ENV } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nimport { deprecation, log2, nextPow2, premultiplyBlendMode } from '@pixi/utils';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader';\nimport { State } from '../state/State';\nimport { BaseTexture } from '../textures/BaseTexture';\nimport { BatchDrawCall } from './BatchDrawCall';\nimport { BatchGeometry } from './BatchGeometry';\nimport { BatchShaderGenerator } from './BatchShaderGenerator';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { canUploadSameBuffer } from './canUploadSameBuffer';\nimport { maxRecommendedTextures } from './maxRecommendedTextures';\nimport { ObjectRenderer } from './ObjectRenderer';\nimport defaultFragment from './texture.frag';\nimport defaultVertex from './texture.vert';\n\nimport type { BLEND_MODES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { Shader } from '../shader/Shader';\nimport type { Texture } from '../textures/Texture';\n\n/**\n * Interface for elements like Sprite, Mesh etc. for batching.\n * @memberof PIXI\n */\nexport interface IBatchableElement\n{\n    _texture: Texture;\n    vertexData: Float32Array;\n    indices: Uint16Array | Uint32Array | Array<number>;\n    uvs: Float32Array;\n    worldAlpha: number;\n    _tintRGB: number;\n    blendMode: BLEND_MODES;\n}\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * This is the default batch renderer. It buffers objects\n * with texture-based geometries and renders them in\n * batches. It uploads multiple textures to the GPU to\n * reduce to the number of draw calls.\n * @memberof PIXI\n */\nexport class BatchRenderer extends ObjectRenderer\n{\n    /**\n     * The maximum textures that this device supports.\n     * @static\n     * @default 32\n     */\n    public static get defaultMaxTextures(): number\n    {\n        this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);\n\n        return this._defaultMaxTextures;\n    }\n    public static set defaultMaxTextures(value: number)\n    {\n        this._defaultMaxTextures = value;\n    }\n\n    /** @ignore */\n    private static _defaultMaxTextures: number;\n\n    /**\n     * The default sprite batch size.\n     *\n     * The default aims to balance desktop and mobile devices.\n     * @static\n     */\n    public static defaultBatchSize = 4096;\n\n    /**\n     * Can we upload the same buffer in a single frame?\n     * @static\n     */\n    public static get canUploadSameBuffer(): boolean\n    {\n        this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();\n\n        return this._canUploadSameBuffer;\n    }\n    public static set canUploadSameBuffer(value: boolean)\n    {\n        this._canUploadSameBuffer = value;\n    }\n\n    /** @ignore */\n    private static _canUploadSameBuffer: boolean;\n\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'batch',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /**\n     * The number of bufferable objects before a flush\n     * occurs automatically.\n     * @default PIXI.BatchRenderer.defaultBatchSize * 4\n     */\n    public size: number;\n\n    /**\n     * Maximum number of textures that can be uploaded to\n     * the GPU under the current context. It is initialized\n     * properly in `this.contextChange`.\n     * @see PIXI.BatchRenderer#contextChange\n     * @readonly\n     */\n    public maxTextures: number;\n\n    /**\n     * This is used to generate a shader that can\n     * color each vertex based on a `aTextureId`\n     * attribute that points to an texture in `uSampler`.\n     *\n     * This enables the objects with different textures\n     * to be drawn in the same draw call.\n     *\n     * You can customize your shader by creating your\n     * custom shader generator.\n     */\n    protected shaderGenerator: BatchShaderGenerator;\n\n    /**\n     * The class that represents the geometry of objects\n     * that are going to be batched with this.\n     * @member {object}\n     * @default PIXI.BatchGeometry\n     */\n    protected geometryClass: typeof BatchGeometry;\n\n    /**\n     * Size of data being buffered per vertex in the\n     * attribute buffers (in floats). By default, the\n     * batch-renderer plugin uses 6:\n     *\n     * | aVertexPosition | 2 |\n     * |-----------------|---|\n     * | aTextureCoords  | 2 |\n     * | aColor          | 1 |\n     * | aTextureId      | 1 |\n     * @default 6\n     */\n    protected vertexSize: number;\n\n    /** Total count of all vertices used by the currently buffered objects. */\n    protected _vertexCount: number;\n\n    /** Total count of all indices used by the currently buffered objects. */\n    protected _indexCount: number;\n\n    /**\n     * Buffer of objects that are yet to be rendered.\n     * @member {PIXI.DisplayObject[]}\n     */\n    protected _bufferedElements: Array<IBatchableElement>;\n\n    /**\n     * Data for texture batch builder, helps to save a bit of CPU on a pass.\n     * @member {PIXI.BaseTexture[]}\n     */\n    protected _bufferedTextures: Array<BaseTexture>;\n\n    /** Number of elements that are buffered and are waiting to be flushed. */\n    protected _bufferSize: number;\n\n    /**\n     * This shader is generated by `this.shaderGenerator`.\n     *\n     * It is generated specifically to handle the required\n     * number of textures being batched together.\n     */\n    protected _shader: Shader;\n\n    /**\n     * A flush may occur multiple times in a single\n     * frame. On iOS devices or when\n     * `BatchRenderer.canUploadSameBuffer` is false, the\n     * batch renderer does not upload data to the same\n     * `WebGLBuffer` for performance reasons.\n     *\n     * This is the index into `packedGeometries` that points to\n     * geometry holding the most recent buffers.\n     */\n    protected _flushId: number;\n\n    /**\n     * Pool of `ViewableBuffer` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing attributes.\n     *\n     * The first buffer has a size of 8; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {PIXI.ViewableBuffer[]}\n     * @see PIXI.BatchRenderer#getAttributeBuffer\n     */\n    protected _aBuffers: Array<ViewableBuffer>;\n\n    /**\n     * Pool of `Uint16Array` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing indices.\n     *\n     * The first buffer has a size of 12; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {Uint16Array[]}\n     * @see PIXI.BatchRenderer#getIndexBuffer\n     */\n    protected _iBuffers: Array<Uint16Array>;\n    protected _dcIndex: number;\n    protected _aIndex: number;\n    protected _iIndex: number;\n    protected _attributeBuffer: ViewableBuffer;\n    protected _indexBuffer: Uint16Array;\n    protected _tempBoundTextures: BaseTexture[];\n\n    /**\n     * Pool of `this.geometryClass` geometry objects\n     * that store buffers. They are used to pass data\n     * to the shader on each draw call.\n     *\n     * These are never re-allocated again, unless a\n     * context change occurs; however, the pool may\n     * be expanded if required.\n     * @member {PIXI.Geometry[]}\n     * @see PIXI.BatchRenderer.contextChange\n     */\n    private _packedGeometries: Array<BatchGeometry>;\n\n    /**\n     * Size of `this._packedGeometries`. It can be expanded\n     * if more than `this._packedGeometryPoolSize` flushes\n     * occur in a single frame.\n     */\n    private _packedGeometryPoolSize: number;\n\n    /**\n     * This will hook onto the renderer's `contextChange`\n     * and `prerender` signals.\n     * @param {PIXI.Renderer} renderer - The renderer this works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.setShaderGenerator();\n        this.geometryClass = BatchGeometry;\n        this.vertexSize = 6;\n        this.state = State.for2d();\n        this.size = BatchRenderer.defaultBatchSize * 4;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n        this._bufferedElements = [];\n        this._bufferedTextures = [];\n        this._bufferSize = 0;\n        this._shader = null;\n        this._packedGeometries = [];\n        this._packedGeometryPoolSize = 2;\n        this._flushId = 0;\n        this._aBuffers = {} as any;\n        this._iBuffers = {} as any;\n\n        this.maxTextures = 1;\n\n        this.renderer.on('prerender', this.onPrerender, this);\n        renderer.runners.contextChange.add(this);\n\n        this._dcIndex = 0;\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n        this._tempBoundTextures = [];\n    }\n\n    /**\n     * @see PIXI.BatchRenderer#maxTextures\n     * @deprecated since 7.1.0\n     * @readonly\n     */\n    get MAX_TEXTURES(): number\n    {\n        // #if _DEBUG\n        deprecation('7.1.0', 'BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures');\n        // #endif\n\n        return this.maxTextures;\n    }\n\n    /**\n     * The default vertex shader source\n     * @readonly\n     */\n    static get defaultVertexSrc(): string\n    {\n        return defaultVertex;\n    }\n\n    /**\n     * The default fragment shader source\n     * @readonly\n     */\n    static get defaultFragmentTemplate(): string\n    {\n        return defaultFragment;\n    }\n\n    /**\n     * Set the shader generator.\n     * @param {object} [options]\n     * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source\n     * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template\n     */\n    public setShaderGenerator({\n        vertex = BatchRenderer.defaultVertexSrc,\n        fragment = BatchRenderer.defaultFragmentTemplate\n    }: { vertex?: string, fragment?: string } = {}): void\n    {\n        this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n    }\n\n    /**\n     * Handles the `contextChange` signal.\n     *\n     * It calculates `this.maxTextures` and allocating the packed-geometry object pool.\n     */\n    contextChange(): void\n    {\n        const gl = this.renderer.gl;\n\n        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n        {\n            this.maxTextures = 1;\n        }\n        else\n        {\n            // step 1: first check max textures the GPU can handle.\n            this.maxTextures = Math.min(\n                gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n                BatchRenderer.defaultMaxTextures);\n\n            // step 2: check the maximum number of if statements the shader can have too..\n            this.maxTextures = checkMaxIfStatementsInShader(\n                this.maxTextures, gl);\n        }\n\n        this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n\n        // we use the second shader as the first one depending on your browser\n        // may omit aTextureId as it is not used by the shader so is optimized out.\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            /* eslint-disable max-len */\n            this._packedGeometries[i] = new (this.geometryClass)();\n        }\n\n        this.initFlushBuffers();\n    }\n\n    /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */\n    initFlushBuffers(): void\n    {\n        const {\n            _drawCallPool,\n            _textureArrayPool,\n        } = BatchRenderer;\n        // max draw calls\n        const MAX_SPRITES = this.size / 4;\n        // max texture arrays\n        const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n\n        while (_drawCallPool.length < MAX_SPRITES)\n        {\n            _drawCallPool.push(new BatchDrawCall());\n        }\n        while (_textureArrayPool.length < MAX_TA)\n        {\n            _textureArrayPool.push(new BatchTextureArray());\n        }\n        for (let i = 0; i < this.maxTextures; i++)\n        {\n            this._tempBoundTextures[i] = null;\n        }\n    }\n\n    /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */\n    onPrerender(): void\n    {\n        this._flushId = 0;\n    }\n\n    /**\n     * Buffers the \"batchable\" object. It need not be rendered immediately.\n     * @param {PIXI.DisplayObject} element - the element to render when\n     *    using this renderer\n     */\n    render(element: IBatchableElement): void\n    {\n        if (!element._texture.valid)\n        {\n            return;\n        }\n\n        if (this._vertexCount + (element.vertexData.length / 2) > this.size)\n        {\n            this.flush();\n        }\n\n        this._vertexCount += element.vertexData.length / 2;\n        this._indexCount += element.indices.length;\n        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n        this._bufferedElements[this._bufferSize++] = element;\n    }\n\n    buildTexturesAndDrawCalls(): void\n    {\n        const {\n            _bufferedTextures: textures,\n            maxTextures,\n        } = this;\n        const textureArrays = BatchRenderer._textureArrayPool;\n        const batch = this.renderer.batch;\n        const boundTextures = this._tempBoundTextures;\n        const touch = this.renderer.textureGC.count;\n\n        let TICK = ++BaseTexture._globalBatch;\n        let countTexArrays = 0;\n        let texArray = textureArrays[0];\n        let start = 0;\n\n        batch.copyBoundTextures(boundTextures, maxTextures);\n\n        for (let i = 0; i < this._bufferSize; ++i)\n        {\n            const tex = textures[i];\n\n            textures[i] = null;\n            if (tex._batchEnabled === TICK)\n            {\n                continue;\n            }\n\n            if (texArray.count >= maxTextures)\n            {\n                batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n                this.buildDrawCalls(texArray, start, i);\n                start = i;\n                texArray = textureArrays[++countTexArrays];\n                ++TICK;\n            }\n\n            tex._batchEnabled = TICK;\n            tex.touched = touch;\n            texArray.elements[texArray.count++] = tex;\n        }\n\n        if (texArray.count > 0)\n        {\n            batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n            this.buildDrawCalls(texArray, start, this._bufferSize);\n            ++countTexArrays;\n            ++TICK;\n        }\n\n        // Clean-up\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            boundTextures[i] = null;\n        }\n        BaseTexture._globalBatch = TICK;\n    }\n\n    /**\n     * Populating drawcalls for rendering\n     * @param texArray\n     * @param start\n     * @param finish\n     */\n    buildDrawCalls(texArray: BatchTextureArray, start: number, finish: number): void\n    {\n        const {\n            _bufferedElements: elements,\n            _attributeBuffer,\n            _indexBuffer,\n            vertexSize,\n        } = this;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let dcIndex = this._dcIndex;\n        let aIndex = this._aIndex;\n        let iIndex = this._iIndex;\n\n        let drawCall = drawCalls[dcIndex];\n\n        drawCall.start = this._iIndex;\n        drawCall.texArray = texArray;\n\n        for (let i = start; i < finish; ++i)\n        {\n            const sprite = elements[i];\n            const tex = sprite._texture.baseTexture;\n            const spriteBlendMode = premultiplyBlendMode[\n                tex.alphaMode ? 1 : 0][sprite.blendMode];\n\n            elements[i] = null;\n\n            if (start < i && drawCall.blend !== spriteBlendMode)\n            {\n                drawCall.size = iIndex - drawCall.start;\n                start = i;\n                drawCall = drawCalls[++dcIndex];\n                drawCall.texArray = texArray;\n                drawCall.start = iIndex;\n            }\n\n            this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n            aIndex += sprite.vertexData.length / 2 * vertexSize;\n            iIndex += sprite.indices.length;\n\n            drawCall.blend = spriteBlendMode;\n        }\n\n        if (start < finish)\n        {\n            drawCall.size = iIndex - drawCall.start;\n            ++dcIndex;\n        }\n\n        this._dcIndex = dcIndex;\n        this._aIndex = aIndex;\n        this._iIndex = iIndex;\n    }\n\n    /**\n     * Bind textures for current rendering\n     * @param texArray\n     */\n    bindAndClearTexArray(texArray: BatchTextureArray): void\n    {\n        const textureSystem = this.renderer.texture;\n\n        for (let j = 0; j < texArray.count; j++)\n        {\n            textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n            texArray.elements[j] = null;\n        }\n        texArray.count = 0;\n    }\n\n    updateGeometry(): void\n    {\n        const {\n            _packedGeometries: packedGeometries,\n            _attributeBuffer: attributeBuffer,\n            _indexBuffer: indexBuffer,\n        } = this;\n\n        if (!BatchRenderer.canUploadSameBuffer)\n        { /* Usually on iOS devices, where the browser doesn't\n            like uploads to the same buffer in a single frame. */\n            if (this._packedGeometryPoolSize <= this._flushId)\n            {\n                this._packedGeometryPoolSize++;\n                packedGeometries[this._flushId] = new (this.geometryClass)();\n            }\n\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.bind(packedGeometries[this._flushId]);\n            this.renderer.geometry.updateBuffers();\n            this._flushId++;\n        }\n        else\n        {\n            // lets use the faster option, always use buffer number 0\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.updateBuffers();\n        }\n    }\n\n    drawBatches(): void\n    {\n        const dcCount = this._dcIndex;\n        const { gl, state: stateSystem } = this.renderer;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let curTexArray = null;\n\n        // Upload textures and do the draw calls\n        for (let i = 0; i < dcCount; i++)\n        {\n            const { texArray, type, size, start, blend } = drawCalls[i];\n\n            if (curTexArray !== texArray)\n            {\n                curTexArray = texArray;\n                this.bindAndClearTexArray(texArray);\n            }\n\n            this.state.blendMode = blend;\n            stateSystem.set(this.state);\n            gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n        }\n    }\n\n    /** Renders the content _now_ and empties the current batch. */\n    flush(): void\n    {\n        if (this._vertexCount === 0)\n        {\n            return;\n        }\n\n        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n        this._indexBuffer = this.getIndexBuffer(this._indexCount);\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._dcIndex = 0;\n\n        this.buildTexturesAndDrawCalls();\n        this.updateGeometry();\n        this.drawBatches();\n\n        // reset elements buffer for the next flush\n        this._bufferSize = 0;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n    }\n\n    /** Starts a new sprite batch. */\n    start(): void\n    {\n        this.renderer.state.set(this.state);\n\n        this.renderer.texture.ensureSamplerType(this.maxTextures);\n\n        this.renderer.shader.bind(this._shader);\n\n        if (BatchRenderer.canUploadSameBuffer)\n        {\n            // bind buffer #0, we don't need others\n            this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n        }\n    }\n\n    /** Stops and flushes the current batch. */\n    stop(): void\n    {\n        this.flush();\n    }\n\n    /** Destroys this `BatchRenderer`. It cannot be used again. */\n    destroy(): void\n    {\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            if (this._packedGeometries[i])\n            {\n                this._packedGeometries[i].destroy();\n            }\n        }\n\n        this.renderer.off('prerender', this.onPrerender, this);\n\n        this._aBuffers = null;\n        this._iBuffers = null;\n        this._packedGeometries = null;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n\n        if (this._shader)\n        {\n            this._shader.destroy();\n            this._shader = null;\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.\n     * @param size - minimum capacity required\n     * @returns - buffer than can hold atleast `size` floats\n     */\n    getAttributeBuffer(size: number): ViewableBuffer\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSize];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Fetches an index buffer from `this._iBuffers` that can\n     * have at least `size` capacity.\n     * @param size - minimum required capacity\n     * @returns - buffer that can fit `size` indices.\n     */\n    getIndexBuffer(size: number): Uint16Array\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Takes the four batching parameters of `element`, interleaves\n     * and pushes them into the batching attribute/index buffers given.\n     *\n     * It uses these properties: `vertexData` `uvs`, `textureId` and\n     * `indicies`. It also uses the \"tint\" of the base-texture, if\n     * present.\n     * @param {PIXI.DisplayObject} element - element being rendered\n     * @param attributeBuffer - attribute buffer.\n     * @param indexBuffer - index buffer\n     * @param aIndex - number of floats already in the attribute buffer\n     * @param iIndex - number of indices already in `indexBuffer`\n     */\n    packInterleavedGeometry(element: IBatchableElement, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array,\n        aIndex: number, iIndex: number): void\n    {\n        const {\n            uint32View,\n            float32View,\n        } = attributeBuffer;\n\n        const packedVertices = aIndex / this.vertexSize;\n        const uvs = element.uvs;\n        const indicies = element.indices;\n        const vertexData = element.vertexData;\n        const textureId = element._texture.baseTexture._batchLocation;\n\n        const alpha = Math.min(element.worldAlpha, 1.0);\n        const argb = Color.shared\n            .setValue(element._tintRGB)\n            .toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);\n\n        // lets not worry about tint! for now..\n        for (let i = 0; i < vertexData.length; i += 2)\n        {\n            float32View[aIndex++] = vertexData[i];\n            float32View[aIndex++] = vertexData[i + 1];\n            float32View[aIndex++] = uvs[i];\n            float32View[aIndex++] = uvs[i + 1];\n            uint32View[aIndex++] = argb;\n            float32View[aIndex++] = textureId;\n        }\n\n        for (let i = 0; i < indicies.length; i++)\n        {\n            indexBuffer[iIndex++] = packedVertices + indicies[i];\n        }\n    }\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    static _drawCallPool: Array<BatchDrawCall> = [];\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchTextureArray[]}\n     */\n    static _textureArrayPool: Array<BatchTextureArray> = [];\n}\n\n// Install BatchRenderer as default\nextensions.add(BatchRenderer);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}