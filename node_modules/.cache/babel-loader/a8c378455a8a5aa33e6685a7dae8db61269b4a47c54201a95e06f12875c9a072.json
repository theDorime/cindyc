{"ast":null,"code":"import { Matrix } from '@pixi/math';\nimport { Program } from '../shader/Program.mjs';\nimport { Shader } from '../shader/Shader.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\nclass BatchShaderGenerator {\n  constructor(vertexSrc, fragTemplate) {\n    this.vertexSrc = vertexSrc;\n    this.fragTemplate = fragTemplate;\n    this.programCache = {};\n    this.defaultGroupCache = {};\n    if (!fragTemplate.includes(\"%count%\")) {\n      throw new Error('Fragment template must contain \"%count%\".');\n    }\n    if (!fragTemplate.includes(\"%forloop%\")) {\n      throw new Error('Fragment template must contain \"%forloop%\".');\n    }\n  }\n  generateShader(maxTextures) {\n    if (!this.programCache[maxTextures]) {\n      const sampleValues = new Int32Array(maxTextures);\n      for (let i = 0; i < maxTextures; i++) {\n        sampleValues[i] = i;\n      }\n      this.defaultGroupCache[maxTextures] = UniformGroup.from({\n        uSamplers: sampleValues\n      }, true);\n      let fragmentSrc = this.fragTemplate;\n      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);\n      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n    }\n    const uniforms = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[maxTextures]\n    };\n    return new Shader(this.programCache[maxTextures], uniforms);\n  }\n  generateSampleSrc(maxTextures) {\n    let src = \"\";\n    src += \"\\n\";\n    src += \"\\n\";\n    for (let i = 0; i < maxTextures; i++) {\n      if (i > 0) {\n        src += \"\\nelse \";\n      }\n      if (i < maxTextures - 1) {\n        src += `if(vTextureId < ${i}.5)`;\n      }\n      src += \"\\n{\";\n      src += `\n\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`;\n      src += \"\\n}\";\n    }\n    src += \"\\n\";\n    src += \"\\n\";\n    return src;\n  }\n}\nexport { BatchShaderGenerator };","map":{"version":3,"names":["BatchShaderGenerator","constructor","vertexSrc","fragTemplate","programCache","defaultGroupCache","includes","Error","generateShader","maxTextures","sampleValues","Int32Array","i","UniformGroup","from","uSamplers","fragmentSrc","replace","generateSampleSrc","Program","uniforms","tint","Float32Array","translationMatrix","Matrix","default","Shader","src"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\batch\\BatchShaderGenerator.ts"],"sourcesContent":["import { Matrix } from '@pixi/math';\nimport { Program } from '../shader/Program';\nimport { Shader } from '../shader/Shader';\nimport { UniformGroup } from '../shader/UniformGroup';\n\n/**\n * Helper that generates batching multi-texture shader. Use it with your new BatchRenderer\n * @memberof PIXI\n */\nexport class BatchShaderGenerator\n{\n    /** Reference to the vertex shader source. */\n    public vertexSrc: string;\n\n    /** Reference to the fragment shader template. Must contain \"%count%\" and \"%forloop%\". */\n    public fragTemplate: string;\n\n    programCache: {[key: number]: Program};\n    defaultGroupCache: {[key: number]: UniformGroup};\n\n    /**\n     * @param vertexSrc - Vertex shader\n     * @param fragTemplate - Fragment shader template\n     */\n    constructor(vertexSrc: string, fragTemplate: string)\n    {\n        this.vertexSrc = vertexSrc;\n        this.fragTemplate = fragTemplate;\n\n        this.programCache = {};\n        this.defaultGroupCache = {};\n\n        if (!fragTemplate.includes('%count%'))\n        {\n            throw new Error('Fragment template must contain \"%count%\".');\n        }\n\n        if (!fragTemplate.includes('%forloop%'))\n        {\n            throw new Error('Fragment template must contain \"%forloop%\".');\n        }\n    }\n\n    generateShader(maxTextures: number): Shader\n    {\n        if (!this.programCache[maxTextures])\n        {\n            const sampleValues = new Int32Array(maxTextures);\n\n            for (let i = 0; i < maxTextures; i++)\n            {\n                sampleValues[i] = i;\n            }\n\n            this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);\n\n            let fragmentSrc = this.fragTemplate;\n\n            fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);\n            fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n\n            this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n        }\n\n        const uniforms = {\n            tint: new Float32Array([1, 1, 1, 1]),\n            translationMatrix: new Matrix(),\n            default: this.defaultGroupCache[maxTextures],\n        };\n\n        return new Shader(this.programCache[maxTextures], uniforms);\n    }\n\n    generateSampleSrc(maxTextures: number): string\n    {\n        let src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i > 0)\n            {\n                src += '\\nelse ';\n            }\n\n            if (i < maxTextures - 1)\n            {\n                src += `if(vTextureId < ${i}.5)`;\n            }\n\n            src += '\\n{';\n            src += `\\n\\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`;\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n}\n"],"mappings":";;;;AASO,MAAMA,oBACb;EAcIC,YAAYC,SAAA,EAAmBC,YAC/B;IACI,KAAKD,SAAY,GAAAA,SAAA;IACjB,KAAKC,YAAe,GAAAA,YAAA;IAEpB,KAAKC,YAAA,GAAe,EAAC;IACrB,KAAKC,iBAAA,GAAoB,EAAC;IAE1B,IAAI,CAACF,YAAA,CAAaG,QAAS,UAAS,CACpC;MACU,UAAIC,KAAA,CAAM,2CAA2C;IAAA;IAG/D,IAAI,CAACJ,YAAA,CAAaG,QAAS,YAAW,CACtC;MACU,UAAIC,KAAA,CAAM,6CAA6C;IAAA;EACjE;EAGJC,eAAeC,WACf;IACQ,KAAC,IAAK,CAAAL,YAAA,CAAaK,WACvB;MACU,MAAAC,YAAA,GAAe,IAAIC,UAAA,CAAWF,WAAW;MAE/C,SAASG,CAAI,MAAGA,CAAI,GAAAH,WAAA,EAAaG,CACjC;QACIF,YAAA,CAAaE,CAAK,IAAAA,CAAA;MAAA;MAGjB,KAAAP,iBAAA,CAAkBI,WAAA,IAAeI,YAAa,CAAAC,IAAA,CAAK;QAAEC,SAAW,EAAAL;MAAA,GAAgB,IAAI;MAEzF,IAAIM,WAAA,GAAc,IAAK,CAAAb,YAAA;MAEvBa,WAAA,GAAcA,WAAY,CAAAC,OAAA,CAAQ,WAAa,KAAGR,WAAa;MAC/DO,WAAA,GAAcA,WAAA,CAAYC,OAAQ,gBAAe,IAAK,CAAAC,iBAAA,CAAkBT,WAAW,CAAC;MAEpF,KAAKL,YAAA,CAAaK,WAAe,QAAIU,OAAQ,MAAKjB,SAAA,EAAWc,WAAW;IAAA;IAG5E,MAAMI,QAAW;MACbC,IAAA,EAAM,IAAIC,YAAa,EAAC,GAAG,CAAG,KAAG,CAAC,CAAC;MACnCC,iBAAA,EAAmB,IAAIC,MAAO;MAC9BC,OAAA,EAAS,KAAKpB,iBAAkB,CAAAI,WAAA;IAAA,CACpC;IAEA,OAAO,IAAIiB,MAAA,CAAO,IAAK,CAAAtB,YAAA,CAAaK,WAAA,GAAcW,QAAQ;EAAA;EAG9DF,kBAAkBT,WAClB;IACI,IAAIkB,GAAM;IAEHA,GAAA;IACAA,GAAA;IAEP,SAASf,CAAI,MAAGA,CAAI,GAAAH,WAAA,EAAaG,CACjC;MACI,IAAIA,CAAA,GAAI,CACR;QACWe,GAAA;MAAA;MAGP,IAAAf,CAAA,GAAIH,WAAA,GAAc,CACtB;QACIkB,GAAA,IAA0B,mBAAAf,CAAA;MAAA;MAGvBe,GAAA;MACAA,GAAA;AAAA,+BAAmCf,CAAA;MACnCe,GAAA;IAAA;IAGJA,GAAA;IACAA,GAAA;IAEA,OAAAA,GAAA;EAAA;AAEf"},"metadata":{},"sourceType":"module","externalDependencies":[]}