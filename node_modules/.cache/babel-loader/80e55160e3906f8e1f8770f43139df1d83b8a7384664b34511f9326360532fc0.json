{"ast":null,"code":"import { MASK_TYPES } from '@pixi/constants';\nimport { Filter } from '../filters/Filter.mjs';\nclass MaskData {\n  constructor() {\n    let maskObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.type = MASK_TYPES.NONE;\n    this.autoDetect = true;\n    this.maskObject = maskObject || null;\n    this.pooled = false;\n    this.isMaskData = true;\n    this.resolution = null;\n    this.multisample = Filter.defaultMultisample;\n    this.enabled = true;\n    this.colorMask = 15;\n    this._filters = null;\n    this._stencilCounter = 0;\n    this._scissorCounter = 0;\n    this._scissorRect = null;\n    this._scissorRectLocal = null;\n    this._colorMask = 15;\n    this._target = null;\n  }\n  get filter() {\n    return this._filters ? this._filters[0] : null;\n  }\n  set filter(value) {\n    if (value) {\n      if (this._filters) {\n        this._filters[0] = value;\n      } else {\n        this._filters = [value];\n      }\n    } else {\n      this._filters = null;\n    }\n  }\n  reset() {\n    if (this.pooled) {\n      this.maskObject = null;\n      this.type = MASK_TYPES.NONE;\n      this.autoDetect = true;\n    }\n    this._target = null;\n    this._scissorRectLocal = null;\n  }\n  copyCountersOrReset(maskAbove) {\n    if (maskAbove) {\n      this._stencilCounter = maskAbove._stencilCounter;\n      this._scissorCounter = maskAbove._scissorCounter;\n      this._scissorRect = maskAbove._scissorRect;\n    } else {\n      this._stencilCounter = 0;\n      this._scissorCounter = 0;\n      this._scissorRect = null;\n    }\n  }\n}\nexport { MaskData };","map":{"version":3,"names":["MaskData","constructor","maskObject","arguments","length","undefined","type","MASK_TYPES","NONE","autoDetect","pooled","isMaskData","resolution","multisample","Filter","defaultMultisample","enabled","colorMask","_filters","_stencilCounter","_scissorCounter","_scissorRect","_scissorRectLocal","_colorMask","_target","filter","value","reset","copyCountersOrReset","maskAbove"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\core\\src\\mask\\MaskData.ts"],"sourcesContent":["import { MASK_TYPES } from '@pixi/constants';\nimport { Filter } from '../filters/Filter';\n\nimport type { COLOR_MASK_BITS, MSAA_QUALITY } from '@pixi/constants';\nimport type { Matrix, Rectangle } from '@pixi/math';\nimport type { IFilterTarget } from '../filters/IFilterTarget';\nimport type { ISpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter';\nimport type { Renderer } from '../Renderer';\n\nexport interface IMaskTarget extends IFilterTarget\n{\n    renderable: boolean;\n    isSprite?: boolean;\n    worldTransform: Matrix;\n    isFastRect?(): boolean;\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle;\n    render(renderer: Renderer): void;\n}\n/**\n * Component for masked elements.\n *\n * Holds mask mode and temporary data about current mask.\n * @memberof PIXI\n */\nexport class MaskData\n{\n    /** Mask type */\n    public type: MASK_TYPES;\n\n    /**\n     * Whether we know the mask type beforehand\n     * @default true\n     */\n    public autoDetect: boolean;\n\n    /**\n     * Which element we use to mask\n     * @member {PIXI.DisplayObject}\n     */\n    public maskObject: IMaskTarget;\n\n    /** Whether it belongs to MaskSystem pool */\n    public pooled: boolean;\n\n    /** Indicator of the type (always true for {@link PIXI.MaskData} objects) */\n    public isMaskData: boolean;// webdoc crashes if the type is true because reasons... (will fix)\n\n    /**\n     * Resolution of the sprite mask filter.\n     * If set to `null` or `0`, the resolution of the current render target is used.\n     * @default null\n     */\n    public resolution: number;\n\n    /**\n     * Number of samples of the sprite mask filter.\n     * If set to `null`, the sample count of the current render target is used.\n     * @default PIXI.Filter.defaultMultisample\n     */\n    public multisample: MSAA_QUALITY;\n\n    /** If enabled is true the mask is applied, if false it will not. */\n    public enabled: boolean;\n\n    /** Color mask. */\n    public colorMask: COLOR_MASK_BITS;\n\n    /**\n     * The sprite mask filter wrapped in an array.\n     * @private\n     */\n    _filters: ISpriteMaskFilter[];\n\n    /**\n     * Stencil counter above the mask in stack\n     * @private\n     */\n    _stencilCounter: number;\n\n    /**\n     * Scissor counter above the mask in stack\n     * @private\n     */\n    _scissorCounter: number;\n\n    /**\n     * Scissor operation above the mask in stack.\n     * Null if _scissorCounter is zero, rectangle instance if positive.\n     * @private\n     */\n    _scissorRect: Rectangle;\n\n    /**\n     * pre-computed scissor rect\n     * does become _scissorRect when mask is actually pushed\n     * @private\n     */\n    _scissorRectLocal: Rectangle;\n\n    /**\n     * pre-computed color mask\n     * @private\n     */\n    _colorMask: number;\n\n    /**\n     * Targeted element. Temporary variable set by MaskSystem\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    _target: IMaskTarget;\n\n    /**\n     * Create MaskData\n     * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n     */\n    constructor(maskObject: IMaskTarget = null)\n    {\n        this.type = MASK_TYPES.NONE;\n        this.autoDetect = true;\n        this.maskObject = maskObject || null;\n        this.pooled = false;\n        this.isMaskData = true;\n        this.resolution = null;\n        this.multisample = Filter.defaultMultisample;\n        this.enabled = true;\n        this.colorMask = 0xf;\n        this._filters = null;\n        this._stencilCounter = 0;\n        this._scissorCounter = 0;\n        this._scissorRect = null;\n        this._scissorRectLocal = null;\n        this._colorMask = 0xf;\n        this._target = null;\n    }\n\n    /**\n     * The sprite mask filter.\n     * If set to `null`, the default sprite mask filter is used.\n     * @default null\n     */\n    get filter(): ISpriteMaskFilter\n    {\n        return this._filters ? this._filters[0] : null;\n    }\n\n    set filter(value: ISpriteMaskFilter)\n    {\n        if (value)\n        {\n            if (this._filters)\n            {\n                this._filters[0] = value;\n            }\n            else\n            {\n                this._filters = [value];\n            }\n        }\n        else\n        {\n            this._filters = null;\n        }\n    }\n\n    /** Resets the mask data after popMask(). */\n    reset(): void\n    {\n        if (this.pooled)\n        {\n            this.maskObject = null;\n\n            this.type = MASK_TYPES.NONE;\n\n            this.autoDetect = true;\n        }\n\n        this._target = null;\n        this._scissorRectLocal = null;\n    }\n\n    /**\n     * Copies counters from maskData above, called from pushMask().\n     * @param maskAbove\n     */\n    copyCountersOrReset(maskAbove?: MaskData): void\n    {\n        if (maskAbove)\n        {\n            this._stencilCounter = maskAbove._stencilCounter;\n            this._scissorCounter = maskAbove._scissorCounter;\n            this._scissorRect = maskAbove._scissorRect;\n        }\n        else\n        {\n            this._stencilCounter = 0;\n            this._scissorCounter = 0;\n            this._scissorRect = null;\n        }\n    }\n}\n"],"mappings":";;AAwBO,MAAMA,QACb;EA2FIC,YAAA,EACA;IAAA,IADYC,UAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA0B,IACtC;IACI,KAAKG,IAAA,GAAOC,UAAW,CAAAC,IAAA;IACvB,KAAKC,UAAa;IAClB,KAAKP,UAAA,GAAaA,UAAc;IAChC,KAAKQ,MAAS;IACd,KAAKC,UAAa;IAClB,KAAKC,UAAa;IAClB,KAAKC,WAAA,GAAcC,MAAO,CAAAC,kBAAA;IAC1B,KAAKC,OAAU;IACf,KAAKC,SAAY;IACjB,KAAKC,QAAW;IAChB,KAAKC,eAAkB;IACvB,KAAKC,eAAkB;IACvB,KAAKC,YAAe;IACpB,KAAKC,iBAAoB;IACzB,KAAKC,UAAa;IAClB,KAAKC,OAAU;EAAA;EAQnB,IAAIC,MACJA,CAAA;IACI,OAAO,IAAK,CAAAP,QAAA,GAAW,IAAK,CAAAA,QAAA,CAAS,CAAK;EAAA;EAG9C,IAAIO,OAAOC,KACX;IACI,IAAIA,KACJ;MACI,IAAI,KAAKR,QACT;QACI,KAAKA,QAAA,CAAS,CAAK,IAAAQ,KAAA;MAAA,CAGvB;QACS,KAAAR,QAAA,GAAW,CAACQ,KAAK;MAAA;IAC1B,CAGJ;MACI,KAAKR,QAAW;IAAA;EACpB;EAIJS,KACAA,CAAA;IACI,IAAI,KAAKjB,MACT;MACI,KAAKR,UAAa;MAElB,KAAKI,IAAA,GAAOC,UAAW,CAAAC,IAAA;MAEvB,KAAKC,UAAa;IAAA;IAGtB,KAAKe,OAAU;IACf,KAAKF,iBAAoB;EAAA;EAO7BM,oBAAoBC,SACpB;IACI,IAAIA,SACJ;MACI,KAAKV,eAAA,GAAkBU,SAAU,CAAAV,eAAA;MACjC,KAAKC,eAAA,GAAkBS,SAAU,CAAAT,eAAA;MACjC,KAAKC,YAAA,GAAeQ,SAAU,CAAAR,YAAA;IAAA,CAGlC;MACI,KAAKF,eAAkB;MACvB,KAAKC,eAAkB;MACvB,KAAKC,YAAe;IAAA;EACxB;AAER"},"metadata":{},"sourceType":"module","externalDependencies":[]}