{"ast":null,"code":"import { Point, BatchGeometry, WRAP_MODES, BaseTexture, BatchDrawCall, BatchTextureArray, DRAW_MODES, Color } from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { GraphicsData } from './GraphicsData.mjs';\nimport { DRAW_CALL_POOL, BATCH_POOL, FILL_COMMANDS } from './utils/index.mjs';\nimport { BatchPart } from './utils/BatchPart.mjs';\nimport { buildPoly } from './utils/buildPoly.mjs';\nimport { buildLine } from './utils/buildLine.mjs';\nconst tmpPoint = new Point();\nconst _GraphicsGeometry = class extends BatchGeometry {\n  constructor() {\n    super();\n    this.closePointEps = 1e-4;\n    this.boundsPadding = 0;\n    this.uvsFloat32 = null;\n    this.indicesUint16 = null;\n    this.batchable = false;\n    this.points = [];\n    this.colors = [];\n    this.uvs = [];\n    this.indices = [];\n    this.textureIds = [];\n    this.graphicsData = [];\n    this.drawCalls = [];\n    this.batchDirty = -1;\n    this.batches = [];\n    this.dirty = 0;\n    this.cacheDirty = -1;\n    this.clearDirty = 0;\n    this.shapeIndex = 0;\n    this._bounds = new Bounds();\n    this.boundsDirty = -1;\n  }\n  get bounds() {\n    this.updateBatches();\n    if (this.boundsDirty !== this.dirty) {\n      this.boundsDirty = this.dirty;\n      this.calculateBounds();\n    }\n    return this._bounds;\n  }\n  invalidate() {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    for (let i = 0; i < this.batches.length; i++) {\n      const batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  }\n  clear() {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  }\n  drawShape(shape) {\n    let fillStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let lineStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let matrix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  }\n  drawHole(shape) {\n    let matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    const data = new GraphicsData(shape, null, null, matrix);\n    const lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  }\n  containsPoint(point) {\n    const graphicsData = this.graphicsData;\n    for (let i = 0; i < graphicsData.length; ++i) {\n      const data = graphicsData[i];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          let hitHole = false;\n          if (data.holes) {\n            for (let i2 = 0; i2 < data.holes.length; i2++) {\n              const hole = data.holes[i2];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  updateBatches() {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    const uvs = this.uvs;\n    const graphicsData = this.graphicsData;\n    let batchPart = null;\n    let currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (let i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      const data = graphicsData[i];\n      const fillStyle = data.fillStyle;\n      const lineStyle = data.lineStyle;\n      const command = FILL_COMMANDS[data.type];\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n      for (let j = 0; j < 2; j++) {\n        const style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible) continue;\n        const nextTexture = style.texture.baseTexture;\n        const index2 = this.indices.length;\n        const attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES.REPEAT;\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        const size = this.points.length / 2 - attribIndex;\n        if (size === 0) continue;\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index2, attribIndex);\n          batchPart = null;\n        }\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index2, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    const index = this.indices.length;\n    const attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      this.batchable = true;\n      return;\n    }\n    const need32 = attrib > 65535;\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  }\n  _compareStyles(styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  }\n  validateBatching() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (let i = 0, l = this.graphicsData.length; i < l; i++) {\n      const data = this.graphicsData[i];\n      const fill = data.fillStyle;\n      const line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid) return false;\n      if (line && !line.texture.baseTexture.valid) return false;\n    }\n    return true;\n  }\n  packBatches() {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    const batches = this.batches;\n    for (let i = 0, l = batches.length; i < l; i++) {\n      const batch = batches[i];\n      for (let j = 0; j < batch.size; j++) {\n        const index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  }\n  isBatchable() {\n    if (this.points.length > 65535 * 2) {\n      return false;\n    }\n    const batches = this.batches;\n    for (let i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;\n  }\n  buildDrawCalls() {\n    let TICK = ++BaseTexture._globalBatch;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    let currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.texArray = new BatchTextureArray();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = DRAW_MODES.TRIANGLES;\n    let textureCount = 0;\n    let currentTexture = null;\n    let textureId = 0;\n    let native = false;\n    let drawMode = DRAW_MODES.TRIANGLES;\n    let index = 0;\n    this.drawCalls.push(currentGroup);\n    for (let i = 0; i < this.batches.length; i++) {\n      const data = this.batches[i];\n      const maxTextures = 8;\n      const style = data.style;\n      const nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n        currentTexture = null;\n        textureCount = maxTextures;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === maxTextures) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.texArray = new BatchTextureArray();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          nextTexture.touched = 1;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = WRAP_MODES.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    BaseTexture._globalBatch = TICK;\n    this.packAttributes();\n  }\n  packAttributes() {\n    const verts = this.points;\n    const uvs = this.uvs;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    const f32 = new Float32Array(glPoints);\n    const u32 = new Uint32Array(glPoints);\n    let p = 0;\n    for (let i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  }\n  processFill(data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      const command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  }\n  processLine(data) {\n    buildLine(data, this);\n    for (let i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  }\n  processHoles(holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  }\n  calculateBounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    bounds.addVertexData(this.points, 0, this.points.length);\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  }\n  transformPoints(points, matrix) {\n    for (let i = 0; i < points.length / 2; i++) {\n      const x = points[i * 2];\n      const y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  }\n  addColors(colors, color, alpha, size) {\n    let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    const bgr = Color.shared.setValue(color).toLittleEndianNumber();\n    const result = Color.shared.setValue(bgr).toPremultiplied(alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      colors[offset + i] = result;\n    }\n  }\n  addTextureIds(textureIds, id, size) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      textureIds[offset + i] = id;\n    }\n  }\n  addUvs(verts, uvs, texture, start, size) {\n    let matrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let index = 0;\n    const uvsStart = uvs.length;\n    const frame = texture.frame;\n    while (index < size) {\n      let x = verts[(start + index) * 2];\n      let y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        const nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n    const baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  }\n  adjustUvs(uvs, texture, start, size) {\n    const baseTexture = texture.baseTexture;\n    const eps = 1e-6;\n    const finish = start + size * 2;\n    const frame = texture.frame;\n    const scaleX = frame.width / baseTexture.width;\n    const scaleY = frame.height / baseTexture.height;\n    let offsetX = frame.x / frame.width;\n    let offsetY = frame.y / frame.height;\n    let minX = Math.floor(uvs[start] + eps);\n    let minY = Math.floor(uvs[start + 1] + eps);\n    for (let i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (let i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  }\n};\nlet GraphicsGeometry = _GraphicsGeometry;\nGraphicsGeometry.BATCHABLE_SIZE = 100;\nexport { GraphicsGeometry };","map":{"version":3,"names":["tmpPoint","Point","_GraphicsGeometry","BatchGeometry","constructor","closePointEps","boundsPadding","uvsFloat32","indicesUint16","batchable","points","colors","uvs","indices","textureIds","graphicsData","drawCalls","batchDirty","batches","dirty","cacheDirty","clearDirty","shapeIndex","_bounds","Bounds","boundsDirty","bounds","updateBatches","calculateBounds","invalidate","length","i","texArray","clear","DRAW_CALL_POOL","push","batchPart","reset","BATCH_POOL","drawShape","shape","fillStyle","arguments","undefined","lineStyle","matrix","data","GraphicsData","drawHole","lastShape","holes","destroy","indexBuffer","containsPoint","point","visible","applyInverse","copyFrom","contains","x","y","hitHole","i2","hole","validateBatching","currentStyle","style","command","FILL_COMMANDS","type","build","transformPoints","processHoles","j","nextTexture","texture","baseTexture","index2","attribIndex","wrapMode","WRAP_MODES","REPEAT","processFill","processLine","size","_compareStyles","end","pop","BatchPart","begin","addUvs","index","attrib","need32","BYTES_PER_ELEMENT","set","Uint32Array","Uint16Array","isBatchable","packBatches","buildDrawCalls","styleA","styleB","color","alpha","native","l","fill","line","valid","Float32Array","batch","start","attribStart","BATCHABLE_SIZE","TICK","BaseTexture","_globalBatch","currentGroup","BatchDrawCall","BatchTextureArray","count","DRAW_MODES","TRIANGLES","textureCount","currentTexture","textureId","drawMode","maxTextures","LINES","_batchEnabled","touched","_batchLocation","elements","addColors","attribSize","addTextureIds","packAttributes","verts","glPoints","ArrayBuffer","f32","u32","p","_buffer","update","_indexBuffer","buildPoly","triangulate","buildLine","addVertexData","pad","a","c","tx","b","d","ty","offset","bgr","Color","shared","setValue","toLittleEndianNumber","result","toPremultiplied","Math","max","id","uvsStart","frame","nx","width","height","adjustUvs","eps","finish","scaleX","scaleY","offsetX","offsetY","minX","floor","minY","min","GraphicsGeometry"],"sources":["C:\\Users\\cheng\\OneDrive\\Desktop\\site\\cindyjcheng.github.io\\node_modules\\@pixi\\graphics\\src\\GraphicsGeometry.ts"],"sourcesContent":["import {\n    BaseTexture,\n    BatchDrawCall,\n    BatchGeometry,\n    BatchTextureArray,\n    Color,\n    DRAW_MODES,\n    Point,\n    WRAP_MODES\n} from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { GraphicsData } from './GraphicsData';\nimport {\n    BATCH_POOL, BatchPart, buildLine,\n    buildPoly,\n    DRAW_CALL_POOL,\n    FILL_COMMANDS\n} from './utils';\n\nimport type { IPointData, IShape, Matrix, Texture } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\nconst tmpPoint = new Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /** The maximum number of points to consider an object \"batchable\", able to be batched by the renderer's batch system. */\n    public static BATCHABLE_SIZE = 100;\n\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.\n     * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered\n     * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}\n     * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        this.updateBatches();\n\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches(): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        const need32 = attrib > 0xffff;\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length\n            && need32 === (this.indicesUint16.BYTES_PER_ELEMENT > 2))\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall = DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const maxTextures = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = maxTextures;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === maxTextures)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     * @param data\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     * @param data\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     * @param holes\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n        bounds.addVertexData((this.points as any), 0, this.points.length);\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        const bgr = Color.shared\n            .setValue(color)\n            .toLittleEndianNumber();\n\n        const result = Color.shared\n            .setValue(bgr)\n            .toPremultiplied(alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = result;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     * @param textureIds\n     * @param id\n     * @param size\n     * @param offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}